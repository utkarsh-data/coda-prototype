<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoDA: Cognitive Data Assistant Prototype</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter (for body) & Roboto Mono (for code) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:400;500;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js CDN for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Darker, professional gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
            padding: 0; /* Remove padding to allow app to go truly full screen */
            overflow: hidden; /* Prevent scrollbar from background animation */
            position: relative;
        }

        /* Subtle background animation - Darker bubbles */
        .background-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }

        .bubble {
            position: absolute;
            background: rgba(74, 85, 104, 0.1); /* Darker, less opaque bubbles */
            border-radius: 50%;
            animation: bubble-flow 25s infinite ease-in-out alternate;
            filter: blur(2px); /* Slightly blur them for softness */
        }
        .bubble:nth-child(1) { width: 80px; height: 80px; left: 15%; top: 10%; animation-duration: 22s; opacity: 0.05; }
        .bubble:nth-child(2) { width: 120px; height: 120px; left: 35%; top: 80%; animation-duration: 25s; opacity: 0.04; }
        .bubble:nth-child(3) { width: 90px; height: 90px; left: 70%; top: 15%; animation-duration: 19s; opacity: 0.06; }
        .bubble:nth-child(4) { width: 140px; height: 140px; left: 90%; top: 50%; animation-duration: 28s; opacity: 0.03; }
        .bubble:nth-child(5) { width: 70px; height: 70px; left: 5%; top: 60%; animation-duration: 21s; opacity: 0.07; }
        .bubble:nth-child(6) { width: 100px; height: 100px; left: 50%; top: 30%; animation-duration: 23s; opacity: 0.05; }

        @keyframes bubble-flow {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(70px, -70px) scale(1.1); }
            100% { transform: translate(0, 0) scale(1); }
        }

        /* Custom scrollbar for chat and results */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium grey thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Lighter grey on hover */
        }

        /* Animation for new messages */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-message {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Gradient for AI avatar */
        .ai-avatar-gradient {
            background: linear-gradient(45deg, #4299e1, #3182ce); /* Techy blue gradient */
        }

        /* Gradient for Send button */
        .send-button-gradient {
            background: linear-gradient(90deg, #4299e1, #3182ce); /* Techy blue gradient */
            transition: all 0.3s ease-in-out;
        }
        .send-button-gradient:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 15px rgba(66, 153, 225, 0.4);
        }
        .send-button-gradient:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(66, 153, 225, 0.2);
        }

        /* Code block styling - Now just for displaying JSON/raw data if needed, not explanations */
        .code-block {
            background-color: #2d3748; /* Dark code background */
            border-left: 4px solid #4299e1; /* Techy blue left border */
            padding: 1rem;
            border-radius: 0.75rem;
            font-family: 'Roboto Mono', monospace; /* Techy monospace font */
            color: #edf2f7; /* Light text for dark background */
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break words for very long lines */
            overflow-x: auto;
            max-height: 200px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); /* Inner shadow for depth */
        }

        /* Input field focus glow */
        input:focus {
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.6); /* Blue glow */
            border-color: #4299e1;
        }

        /* Chart Canvas Styling */
        .chart-container {
            position: relative;
            height: 300px; /* Fixed height for consistency */
            width: 100%;
            margin-top: 1.5rem;
            background-color: #1a202c; /* Dark background for charts */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: column;
        }
        .chart-container canvas {
            max-height: 100%;
            max-width: 100%;
        }

        /* Table specific styles for the command list */
        .command-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
            text-align: left;
        }
        .command-table th, .command-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #4a5568; /* Slightly lighter border for table rows */
        }
        .command-table th {
            background-color: #2d3748; /* Darker header background */
            font-weight: 600;
            color: #a0aec0; /* Lighter text for headers */
        }
        .command-table tbody tr:hover {
            background-color: #4a5568; /* Hover effect for rows */
        }
        .command-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Styles for shrunk header */
        .header-shrunk {
            padding-top: 1rem !important; /* Smaller top padding */
            padding-bottom: 0.5rem !important; /* Smaller bottom padding */
        }
        .header-shrunk #mainTitle {
            font-size: 1.5rem !important; /* Smaller title */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #subTitle {
            font-size: 0.875rem !important; /* Smaller subtitle (sm) */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #createdBy {
            font-size: 0.75rem !important; /* Even smaller "Created by" (xs) */
            margin-bottom: 0.5rem !important;
        }
        .header-shrunk #toggleButtons {
            margin-bottom: 0rem !important; /* No bottom margin */
            /* justify-content: flex-start !important; This is already handled by the permanent change */
            flex-wrap: wrap; /* Allow wrapping if buttons get too long */
        }
        .header-shrunk #toggleButtons button {
            padding-top: 0.4rem !important;
            padding-bottom: 0.4rem !important;
            font-size: 0.8rem !important;
        }

        /* Proactive Insights Card Styling */
        .insight-card {
            background-color: #2d3748; /* Darker background for cards */
            border-radius: 1.5rem; /* More rounded corners */
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4); /* Deeper shadow */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 1px solid #4a5568; /* Subtle border */
        }
        .insight-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }

        .insight-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            color: #90cdf4; /* Light blue for headers */
        }
        .insight-header i {
            font-size: 1.8rem;
            margin-right: 0.8rem;
            color: #4299e1; /* Brighter blue icon */
        }
        .insight-header h4 {
            font-size: 1.3rem; /* Slightly larger heading */
            font-weight: 700; /* Bold heading */
        }

        .insight-message {
            color: #e2e8f0; /* Light text for message */
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .insight-action {
            display: inline-block;
            background-color: #4299e1; /* Blue background for action button */
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(66, 153, 225, 0.3);
        }
        .insight-action:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(66, 153, 225, 0.4);
        }

        /* Collapsible content styles */
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out; /* Slower, smoother transition */
        }

        .collapsible-content.show {
            max-height: 9999px; /* Ensures it expands fully regardless of content height */
        }

        /* Modernized Data Panel Styling */
        #data-panel {
            background: linear-gradient(180deg, #2d3748 0%, #1a202c 100%); /* Subtle vertical gradient */
            border-right: 1px solid rgba(74, 85, 104, 0.5); /* Finer border */
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5); /* More pronounced shadow from the side */
            padding: 0rem; /* Remove top/bottom padding from main panel to give inner divs control */
        }
        /* Inner div for top content of data panel */
        #data-panel > div:first-child {
            padding: 2rem; /* Restore padding for the main header and file management section */
            padding-bottom: 1rem; /* Adjust bottom padding to create a gap */
        }
        /* Inner div for schema section */
        #data-panel > div:last-child {
            padding: 1rem 2rem 2rem 2rem; /* Adjust padding around schema */
        }


        /* Upload Box Refinement */
        #data-panel .border-dashed {
            border-color: #4299e1; /* Brighter blue dashed border */
            background-color: #2d3748; /* Darker background for upload area */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3); /* Inner shadow for depth */
            transition: all 0.3s ease-in-out;
        }
        #data-panel .border-dashed:hover {
            border-color: #63b3ed; /* Lighter blue on hover */
            background-color: #3a475a; /* Slightly lighter on hover */
            box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 0 0 15px rgba(66, 153, 225, 0.5); /* Outer glow on hover */
        }

        /* Data Schema Section Refinement */
        #schemaDisplay {
            background-color: #2d3748; /* Darker background for schema */
            border: 1px solid #4a5568; /* Subtle border */
            box-shadow: inset 0 0 8px rgba(0,0,0,0.3); /* Inner shadow */
        }
        #schemaDisplay p.text-gray-400 {
            color: #a0aec0; /* Lighter grey for placeholder text */
        }
        #schemaDisplay .list-disc {
            color: #e2e8f0; /* Lighter text for list items */
        }
        #schemaDisplay .font-bold {
            color: #90cdf4; /* Light blue for column names */
        }
        #schemaDisplay .font-medium {
            color: #63b3ed; /* Medium blue for types */
        }

        /* File Management Button Styling (New/Updated) */
        #toggleFileManagementBtn {
            background: linear-gradient(90deg, #4299e1, #3182ce); /* Blue gradient */
            color: white; /* White text */
            font-weight: 700; /* Bold font */
            border: none;
            box-shadow: 0 4px 10px rgba(66, 153, 225, 0.3); /* Soft shadow */
            transition: all 0.3s ease-in-out; /* Smooth transitions */
        }

        #toggleFileManagementBtn:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.01); /* Slight lift and scale */
            box-shadow: 0 6px 15px rgba(66, 153, 225, 0.5); /* More pronounced shadow */
        }

        #toggleFileManagementBtn i.fa-chevron-down {
            transition: transform 0.3s ease-in-out; /* Smooth rotation for chevron */
        }
    </style>
</head>
<body class="relative bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center h-screen w-screen">
    <!-- Background Bubbles Animation -->
    <div class="background-bubbles">
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
    </div>

    <div id="main-container" class="relative z-10 flex flex-col md:flex-row bg-gray-900 text-gray-200 rounded-3xl shadow-2xl overflow-hidden w-full h-full transform transition-all duration-300 border border-gray-700">
        <!-- Left Pane: CSV Upload & Data Preview -->
        <!-- This pane is now conditionally hidden/shown by JavaScript, default hidden on md+ -->
        <div id="data-panel" class="flex-col rounded-l-3xl overflow-y-auto custom-scrollbar hidden md:w-0 md:hidden">
            <div class="p-8 pb-4 bg-transparent"> <!-- Adjusted padding here for overall panel -->
                <h2 class="text-4xl font-extrabold text-blue-400 mb-2 text-center tracking-tight">CoDA <span class="text-blue-600">AI</span></h2>
                <p class="text-md text-gray-400 mb-2 text-center italic">Your Private, Conversational Data Analyst</p>
                <p class="text-sm text-gray-500 mb-6 text-center">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

                <!-- New: File Management Section Toggle Button -->
                <button id="toggleFileManagementBtn" class="px-4 py-3 rounded-xl shadow-lg flex items-center justify-between w-full mb-4">
                    <span class="font-semibold text-lg"><i class="fas fa-folder-open mr-3"></i>File Management</span>
                    <i class="fas fa-chevron-down transform transition-transform duration-300"></i>
                </button>

                <!-- New: Collapsible File Management Section -->
                <div id="fileManagementSection" class="collapsible-content show"> <!-- Start expanded -->
                    <div class="mb-4 border-2 border-dashed border-blue-600 bg-gray-700 rounded-2xl p-5 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-600 transition duration-300 ease-in-out shadow-inner-lg">
                        <label for="csvFileInput" class="cursor-pointer text-blue-300 hover:text-blue-100 font-bold text-base flex flex-col items-center justify-center">
                            <i class="fas fa-cloud-upload-alt text-4xl mb-3 text-blue-500"></i>
                            <span class="block text-lg">Upload CSV File</span>
                            <span class="block text-xs text-gray-400 mt-2">Click or drag & drop</span>
                        </label>
                        <input type="file" id="csvFileInput" accept=".csv" class="hidden">
                        <p id="fileNameDisplay" class="mt-3 text-gray-300 text-sm font-medium"></p>
                        <p id="uploadStatus" class="mt-1 text-xs font-semibold text-gray-300"></p>
                    </div>

                    <button id="downloadCsvBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-base font-bold w-full">
                        <i class="fas fa-download"></i>
                        <span>Download Modified CSV</span>
                    </button>

                    <button id="showProactiveInsightsBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-base font-bold w-full">
                        <i class="fas fa-lightbulb"></i>
                        <span>Show Proactive Insights</span>
                    </button>
                </div>
            </div>

            <div class="px-8 pt-4 pb-8"> <!-- Separate padding for schema section -->
                <h3 class="text-2xl font-bold text-gray-200 mb-4 border-b pb-2 border-gray-600">Data Schema</h3>
                <div id="schemaDisplay" class="bg-gray-700 p-5 rounded-2xl flex-grow overflow-y-auto custom-scrollbar text-sm text-gray-300 shadow-lg border border-gray-600 min-h-[250px]">
                    <p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>
                </div>
            </div>
        </div>

        <!-- Right Pane: Conversational Interface & Results - Now takes full width on larger screens by default -->
        <div id="chat-panel" class="w-full flex flex-col bg-gray-900 rounded-3xl">
            <div id="headerContainer" class="px-8 pt-6 pb-2 transition-all duration-500 ease-in-out"> <!-- Condensed padding for header content -->
                <h2 class="text-4xl font-extrabold text-blue-400 mb-1 text-center tracking-tight" id="mainTitle">CoDA <span class="text-blue-600">AI</span></h2>
                <p class="text-md text-gray-400 mb-1 text-center italic" id="subTitle">Your Private, Conversational Data Analyst</p>
                <p class="text-sm text-gray-500 mb-4 text-center" id="createdBy">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

                <!-- Toggle Buttons for Data Panel and Command Guide - Positioned together and left-aligned -->
                <div class="flex justify-start space-x-3 mb-2" id="toggleButtons">
                    <button id="toggleDataPanelBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out hidden md:flex items-center space-x-2">
                        <i class="fas fa-eye mr-2"></i> <span id="toggleButtonText">Show Data Panel</span>
                    </button>
                    <button id="toggleCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                        <i class="fas fa-book mr-2"></i> <span id="toggleCommandGuideText">Show Command Guide</span>
                    </button>
                </div>
            </div>

            <!-- Chat Area - Now takes up all available space -->
            <div id="chatArea" class="flex-grow bg-gray-800 px-6 py-6 rounded-2xl overflow-y-auto custom-scrollbar shadow-lg border border-gray-700 mx-8">
                <!-- Initial AI message -->
                <div class="flex items-start mb-4 fade-in-message">
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">Hello! Welcome to CoDA. Upload your CSV data to begin our private, client-side analysis. I'm ready to collaborate!</p>
                    </div>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="flex items-center space-x-3 px-8 pb-6 pt-4"> <!-- Adjusted padding for input area -->
                <input type="text" id="chatInput" placeholder="Ask CoDA a question about your data, e.g., 'Show me the average sales'..." class="flex-grow p-4 border border-gray-600 bg-gray-700 text-gray-200 rounded-full focus:outline-none focus:ring-4 focus:ring-blue-600 shadow-lg text-base transition duration-300 ease-in-out">
                <button id="sendMessageBtn" class="send-button-gradient text-white p-4 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
                    <i class="fas fa-paper-plane text-xl"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Command Guide Overlay (hidden by default) -->
    <div id="commandGuideOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-3xl font-extrabold text-blue-400">CoDA AI Command Guide</h3>
            <button id="closeCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Guide</span>
            </button>
        </div>
        <div id="commandGuideContent" class="flex-grow text-gray-200">
            <!-- Command guide content will be inserted here -->
        </div>
    </div>

    <!-- Proactive Insights Overlay (hidden by default) -->
    <div id="proactiveInsightsOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <!-- Updated Proactive Insights Heading for better blending -->
            <h3 class="text-3xl font-extrabold text-blue-300 flex items-center">
                <i class="fas fa-brain text-blue-500 mr-3 text-4xl"></i>
                <span>CoDA's <span class="text-white">Proactive Insights</span></span>
            </h3>
            <button id="closeProactiveInsightsBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Insights</span>
            </button>
        </div>
        <!-- Search and Filter Controls -->
        <div class="mb-6 flex flex-wrap items-center gap-4">
            <input type="text" id="insightSearchInput" placeholder="Search insights..." class="flex-grow p-3 border border-gray-600 bg-gray-700 text-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-600 shadow-inner max-w-full md:max-w-xs">
            <div class="flex flex-wrap gap-2">
                <button class="filter-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="all">All</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="anomaly"><i class="fas fa-exclamation-triangle mr-2"></i>Anomaly</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="trend"><i class="fas fa-chart-line mr-2"></i>Trend</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="correlation"><i class="fas fa-link mr-2"></i>Correlation</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="distribution"><i class="fas fa-chart-pie mr-2"></i>Distribution</button>
            </div>
        </div>
        <div id="proactiveInsightsContent" class="flex-grow text-gray-200">
            <!-- Proactive insights content will be inserted here -->
            <p class="text-gray-400 text-center py-4">No proactive insights available yet. Upload a CSV file to generate proactive insights.</p>
        </div>
    </div>


    <script>
        let rawData = []; // Stores the parsed CSV data
        let schema = {}; // Stores the column names and inferred types
        let pendingCleaningSuggestion = null; // Stores details of a pending cleaning action
        let myChart = null; // Holds the Chart.js instance for dynamic updates
        let lastProactiveInsights = []; // Store last generated insights as an array of objects
        let hasProactiveAlertBeenShown = false; // Flag to prevent repetitive proactive alerts

        const chatArea = document.getElementById('chatArea');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const csvFileInput = document.getElementById('csvFileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const uploadStatus = document.getElementById('uploadStatus');
        const schemaDisplay = document.getElementById('schemaDisplay');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn'); // New button element
        const toggleDataPanelBtn = document.getElementById('toggleDataPanelBtn'); // New toggle button for data panel
        const dataPanel = document.getElementById('data-panel'); // Reference to the data panel
        const chatPanel = document.getElementById('chat-panel'); // Reference to the chat panel
        const toggleButtonText = document.getElementById('toggleButtonText'); // Text for data panel toggle button

        const toggleCommandGuideBtn = document.getElementById('toggleCommandGuideBtn'); // New toggle button for command guide
        const commandGuideOverlay = document.getElementById('commandGuideOverlay'); // The new overlay div
        const commandGuideContent = document.getElementById('commandGuideContent'); // Content area inside the overlay
        const closeCommandGuideBtn = document.getElementById('closeCommandGuideBtn'); // Button to close the overlay
        const toggleCommandGuideText = document.getElementById('toggleCommandGuideText'); // Text for command guide toggle button
        const headerContainer = document.getElementById('headerContainer'); // Reference to the header container

        // New elements for proactive insights overlay
        const showProactiveInsightsBtn = document.getElementById('showProactiveInsightsBtn');
        const proactiveInsightsOverlay = document.getElementById('proactiveInsightsOverlay');
        const proactiveInsightsContent = document.getElementById('proactiveInsightsContent');
        const closeProactiveInsightsBtn = document.getElementById('closeProactiveInsightsBtn');
        const insightSearchInput = document.getElementById('insightSearchInput'); // Search input
        const filterButtons = document.querySelectorAll('.filter-btn'); // Filter buttons

        // Elements for File Management Section
        const toggleFileManagementBtn = document.getElementById('toggleFileManagementBtn');
        const fileManagementSection = document.getElementById('fileManagementSection');
        const fileManagementChevron = toggleFileManagementBtn.querySelector('.fa-chevron-down');


        let isHeaderShrunk = false; // New flag to track header state


        // Function to parse CSV data
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(header => header.trim().replace(/"/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(value => value.trim().replace(/"/g, ''));
                if (values.length === headers.length) { // Ensure row has correct number of columns
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
            }
            return data;
        }

        // Function to infer schema (basic type inference)
        function inferSchema(data) {
            if (data.length === 0) return {};
            const inferredSchema = {};
            const sampleRow = data[0];

            for (const key in sampleRow) {
                let type = 'string';
                // Very basic type inference: check if all values in column can be parsed as numbers
                const isNumeric = data.every(row => {
                    const value = row[key];
                    return value === '' || !isNaN(Number(value)); // Empty string or parseable as number
                });

                if (isNumeric) {
                    type = 'number';
                }
                inferredSchema[key] = type;
            }
            return inferredSchema;
        }

        // Function to display schema in the UI
        function displaySchema(schema) {
            schemaDisplay.innerHTML = '';
            if (Object.keys(schema).length === 0) {
                schemaDisplay.innerHTML = '<p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>';
                return;
            }
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside space-y-3'; // Added space-y for better spacing
            for (const key in schema) {
                const li = document.createElement('li');
                li.className = 'mb-1 text-gray-300';
                li.innerHTML = `<span class="font-bold text-blue-400">${key}</span>: <span class="text-blue-300 font-medium">${schema[key]}</span>`;
                ul.appendChild(li);
            }
            schemaDisplay.appendChild(ul);
        }

        // Helper function to calculate average of a numeric column
        function calculateColumnAverage(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            const sum = numericValues.reduce((acc, val) => acc + val, 0);
            return sum / numericValues.length;
        }

        // Helper function to calculate sum of a numeric column
        function calculateColumnSum(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            return numericValues.reduce((acc, val) => acc + val, 0);
        }

        // Helper function to find min/max of a numeric column
        function calculateColumnMinMax(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return { min: null, max: null };
            return { min: Math.min(...numericValues), max: Math.max(...numericValues) };
        }

        // Helper to calculate median
        function calculateMedian(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return null;
            const mid = Math.floor(numericValues.length / 2);
            return numericValues.length % 2 === 0 ? (numericValues[mid - 1] + numericValues[mid]) / 2 : numericValues[mid];
        }

        // Helper to calculate standard deviation
        function calculateStandardDeviation(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length < 2) return null;
            const mean = calculateColumnAverage(columnName, data);
            const sumOfSquares = numericValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
            return Math.sqrt(sumOfSquares / (numericValues.length - 1)); // Sample standard deviation
        }

        // Helper to calculate quartiles (Q1, Median, Q3, IQR)
        function calculateQuartiles(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { q1: null, median: null, q3: null, iqr: null };

            const getMedian = arr => {
                const mid = Math.floor(arr.length / 2);
                return arr.length % 2 === 0 ? (arr[mid - 1] + arr[mid]) / 2 : arr[mid];
            };

            const median = getMedian(numericValues);
            const q1 = getMedian(numericValues.slice(0, Math.floor(numericValues.length / 2)));
            const q3 = getMedian(numericValues.slice(Math.ceil(numericValues.length / 2)));
            const iqr = q3 - q1;

            return { q1: q1.toFixed(2), median: median.toFixed(2), q3: q3.toFixed(2), iqr: iqr.toFixed(2) };
        }

        // Helper to calculate Pearson correlation coefficient
        function calculateCorrelation(col1, col2, data) {
            const validData = data.filter(row => !isNaN(Number(row[col1])) && !isNaN(Number(row[col2])));
            if (validData.length < 2) return null; // Need at least two data points

            const xValues = validData.map(row => Number(row[col1]));
            const yValues = validData.map(row => Number(row[col2]));

            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + (x * yValues[i]), 0);
            const sumX2 = xValues.reduce((sum, x) => sum + (x * x), 0);
            const sumY2 = yValues.reduce((sum, y) => sum + (y * y), 0);

            const n = validData.length;

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            if (denominator === 0) return 0; // Avoid division by zero, implies no variance
            return numerator / denominator;
        }

        // Helper to find outliers using IQR method
        function findOutliers(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { outliers: [], lowerBound: null, upperBound: null };

            const { q1, q3, iqr } = calculateQuartiles(columnName, data); // Uses existing function
            if (q1 === null || q3 === null || iqr === null) return { outliers: [], lowerBound: null, upperBound: null };

            const lowerBound = parseFloat(q1) - 1.5 * parseFloat(iqr);
            const upperBound = parseFloat(q3) + 1.5 * parseFloat(iqr);

            const outliers = numericValues.filter(val => val < lowerBound || val > upperBound);

            return { outliers, lowerBound: lowerBound.toFixed(2), upperBound: upperBound.toFixed(2) };
        }

        // Helper to perform simple linear regression
        function performLinearRegression(xCol, yCol, data) {
            const validData = data.filter(row => !isNaN(Number(row[xCol])) && !isNaN(Number(row[yCol])));
            if (validData.length < 2) return null; // Need at least two points for regression

            const xValues = validData.map(row => Number(row[xCol]));
            const yValues = validData.map(row => Number(row[yCol]));

            const n = validData.length;
            const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;
            const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;

            let sumXY = 0;
            let sumX2 = 0;
            let sumY2 = 0; // For R-squared calculation

            for (let i = 0; i < n; i++) {
                sumXY += (xValues[i] - meanX) * (yValues[i] - meanY);
                sumX2 += (xValues[i] - meanX) * (xValues[i] - meanX);
                sumY2 += (yValues[i] - meanY) * (yValues[i] - meanY); // For R-squared
            }

            const slope = sumX2 === 0 ? 0 : sumXY / sumX2; // b1
            const intercept = meanY - slope * meanX; // b0

            // Calculate R-squared
            let ssResidual = 0;
            let ssTotal = 0;
            for (let i = 0; i < n; i++) {
                const yPredicted = slope * xValues[i] + intercept;
                ssResidual += Math.pow(yValues[i] - yPredicted, 2);
                ssTotal += Math.pow(yValues[i] - meanY, 2);
            }
            const rSquared = ssTotal === 0 ? 0 : (1 - (ssResidual / ssTotal));

            return { slope: slope.toFixed(4), intercept: intercept.toFixed(4), rSquared: rSquared.toFixed(4) };
        }

        // Helper for grouping and aggregating data for charts (e.g., for bar charts)
        function groupByAndAggregate(data, groupByColumn, aggregateColumn, aggregateType) {
            const groupedData = {};
            data.forEach(row => {
                const groupKey = row[groupByColumn];
                const value = Number(row[aggregateColumn]);

                if (!isNaN(value)) {
                    if (!groupedData[groupKey]) {
                        groupedData[groupKey] = { sum: 0, count: 0 };
                    }
                    groupedData[groupKey].sum += value;
                    groupedData[groupKey].count++;
                }
            });

            const labels = [];
            const values = [];

            for (const key in groupedData) {
                labels.push(key);
                if (aggregateType === 'average') {
                    values.push(groupedData[key].sum / groupedData[key].count);
                } else { // default to sum
                    values.push(groupedData[key].sum);
                }
            }
            return { labels, data: values };
        }

        // Advanced Feature: Check for missing values and suggest cleaning
        function checkAndSuggestDataCleaning(data, currentSchema) {
            let suggestions = [];
            for (const col in currentSchema) {
                if (currentSchema[col] === 'number') {
                    const missingCount = data.filter(row => row[col] === '' || row[col] === undefined || row[col] === null).length;
                    if (missingCount > 0) {
                        suggestions.push({
                            column: col,
                            type: 'missing_numeric',
                            count: missingCount,
                            action: 'fill_average'
                        });
                    }
                }
            }

            if (suggestions.length > 0) {
                const firstSuggestion = suggestions[0];
                pendingCleaningSuggestion = firstSuggestion;
                appendMessage('AI', `I noticed ${firstSuggestion.count} missing values in the numeric column "<strong>${firstSuggestion.column}</strong>". Would you like me to fill them with the column's average? (Type "yes" to confirm)`, 'ai');
            } else {
                pendingCleaningSuggestion = null;
            }
        }

        // --- Charting Functions ---

        // Helper to get consistent chart colors
        function getChartColors(count) {
            const colors = [
                'rgba(66, 153, 225, 0.8)', // Blue
                'rgba(144, 202, 249, 0.8)', // Light Blue
                'rgba(74, 222, 128, 0.8)', // Green
                'rgba(251, 191, 36, 0.8)', // Yellow
                'rgba(248, 113, 113, 0.8)', // Red
                'rgba(192, 132, 252, 0.8)', // Purple
                'rgba(129, 140, 248, 0.8)', // Indigo
                'rgba(244, 114, 182, 0.8)', // Pink
            ];
            // Cycle through colors if more data points than defined colors
            return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
        }

        // Function to create a chart (now with axis label options)
        function createChart(chartType, chartTitle, labels, data, xAxisLabelText = '', yAxisLabelText = '', options = {}) {
            // Destroy existing chart if it exists
            if (myChart) {
                myChart.destroy();
            }

            // Create the AI message that introduces the chart
            const chartMessageDiv = document.createElement('div');
            chartMessageDiv.className = 'flex items-start mb-4 fade-in-message';
            chartMessageDiv.innerHTML = `
                <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md">
                    <p class="leading-relaxed">Here's the **${chartType} chart** for **${chartTitle}**:</p>
                </div>
            `;
            chatArea.appendChild(chartMessageDiv); // Append the AI text bubble

            // Create the chart container
            const chartCanvas = document.createElement('canvas');
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container'; // This class has margin-top for spacing
            chartContainer.appendChild(chartCanvas);
            
            chatArea.appendChild(chartContainer); // Append the chart below the text bubble
            // Scroll to the bottom of the chat area to show the latest chart
            chatArea.scrollTop = chatArea.scrollHeight;


            const ctx = chartCanvas.getContext('2d');
            myChart = new Chart(ctx, {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: chartTitle, // Use chartTitle for dataset label
                        data: data,
                        backgroundColor: getChartColors(data.length),
                        borderColor: getChartColors(data.length).map(color => color.replace('0.8', '1')), // Opaque borders
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e2e8f0' // Light text for legend on dark background
                            }
                        },
                        title: { // Chart title moved here for consistency
                            display: true,
                            text: chartTitle,
                            color: '#e2e8f0'
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)' // Very subtle grid lines
                            },
                            title: { // X-axis title
                                display: xAxisLabelText !== '',
                                text: xAxisLabelText,
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            },
                            title: { // Y-axis title
                                display: yAxisLabelText !== '',
                                text: yAxisLabelText,
                                color: '#e2e8f0'
                            }
                        }
                    },
                    ...options // Merge custom options
                }
            });
        }

        // Function to get the HTML for the command list table
        function getCommandListHtml() {
            return `<p class="leading-relaxed mb-4">I'm ready to help with your data analysis! Here's a quick guide to what I can do:</p>
                <table class="command-table">
                    <thead>
                        <tr>
                            <th>Sr. No.</th>
                            <th>Category</th>
                            <th>Command</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>General Overview</td>
                            <td>Show all data</td>
                            <td><code>show all data</code></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>General Overview</td>
                            <td>Show specific column data</td>
                            <td><code>show [column name]</code> (e.g., <code>show City</code>)</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>General Overview</td>
                            <td>Count rows</td>
                            <td><code>count rows</code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>General Overview</td>
                            <td>Describe dataset</td>
                            <td><code>describe my dataset</code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>General Overview</td>
                            <td>Show schema</td>
                            <td><code>show schema</code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Statistical Analysis</td>
                            <td>Sum a numeric column</td>
                            <td><code>sum [numeric column]</code> (e.g., <code>sum sales</code>)</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Statistical Analysis</td>
                            <td>Average a numeric column</td>
                            <td><code>average [numeric column]</code> (e.g., <code>average age</code>)</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>Statistical Analysis</td>
                            <td>Median of a numeric column</td>
                            <td><code>median [numeric column]</code> (e.g., <code>median income</code>)</td>
                        </tr>
                        <tr>
                            <td>9</td>
                            <td>Statistical Analysis</td>
                            <td>Standard deviation of a numeric column</td>
                            <td><code>standard deviation [numeric column]</code> (e.g., <code>standard deviation price</code>)</td>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td>Statistical Analysis</td>
                            <td>Quartiles of a numeric column</td>
                            <td><code>quartiles [numeric column]</code> (e.g., <code>quartiles score</code>)</td>
                        </tr>
                        <tr>
                            <td>11</td>
                            <td>Statistical Analysis</td>
                            <td>Count unique values in a column</td>
                            <td><code>count unique [column name]</code> (e.g., <code>count unique city</code>)</td>
                        </tr>
                        <tr>
                            <td>12</td>
                            <td>Statistical Analysis</td>
                            <td>Show frequency/top values</td>
                            <td><code>show frequency of [column name]</code> or <code>top values in [column name]</code> (e.g., <code>show frequency of product type</code>)</td>
                        </tr>
                        <tr>
                            <td>13</td>
                            <td>Statistical Analysis</td>
                            <td>Min/Max of a numeric column</td>
                            <td><code>min [numeric column]</code> or <code>max [numeric column]</code> (e.g., <code>min temperature</code>)</td>
                        </tr>
                        <tr>
                            <td>14</td>
                            <td>Statistical Analysis</td>
                            <td>Average a numeric column by categorical group</td>
                            <td><code>average [numeric column] by [categorical column]</code> (e.g., <code>average sales by region</code>)</td>
                        </tr>
                        <tr>
                            <td>15</td>
                            <td>Statistical Analysis</td>
                            <td>Correlation between two numeric columns</td>
                            <td><code>show correlation between [numeric_col1] and [numeric_col2]</code> (e.g., <code>show correlation between Age and Income</code>)</td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td>Statistical Analysis</td>
                            <td>Find outliers in a numeric column</td>
                            <td><code>find outliers in [numeric column]</code> (e.g., <code>find outliers in Sales</code>)</td>
                        </tr>
                        <tr>
                            <td>17</td>
                            <td>Data Manipulation</td>
                            <td>Filter data</td>
                            <td><code>filter data where [column] [operator] [value]</code> (e.g., <code>sales > 1000</code> or <code>city = "London"</code>)</td>
                        </tr>
                        <tr>
                            <td>18</td>
                            <td>Data Manipulation</td>
                            <td>Add a new calculated column</td>
                            <td><code>add column [new_name] as [col1] [operator] [col2]</code> (Operators: 'plus', 'minus', 'times', 'divided by'. E.g., <code>add column profit as revenue minus cost</code>)</td>
                        </tr>
                        <tr>
                            <td>19</td>
                            <td>Data Manipulation</td>
                            <td>Categorize numeric data into bins</td>
                            <td><code>categorize [numeric_col] into [num_bins] bins as [new_col_name]</code> (e.g., <code>categorize Age into 5 bins as Age_Group</code>)</td>
                        </tr>
                        <tr>
                            <td>20</td>
                            <td>Data Manipulation</td>
                            <td>Remove duplicate rows</td>
                            <td><code>remove duplicate rows</code></td>
                        </tr>
                        <tr>
                            <td>21</td>
                            <td>Data Manipulation</td>
                            <td>Rename column</td>
                            <td><code>rename column [old_name] to [new_name]</code> (e.g., <code>rename column Product_ID to SKU</code>)</td>
                        </tr>
                        <tr>
                            <td>22</td>
                            <td>Business Intelligence</td>
                            <td>Summarize numeric by categorical</td>
                            <td><code>summarize [numeric_col] by [categorical_col]</code> (e.g., <code>summarize Sales by Region</code>)</td>
                        </tr>
                        <tr>
                            <td>23</td>
                            <td>Business Intelligence</td>
                            <td>Show overall business overview</td>
                            <td><code>show overall business overview</code></td>
                        </tr>
                        <tr>
                            <td colspan="4" class="text-center font-bold text-blue-300 bg-gray-700">New Feature: Data Export</td>
                        </tr>
                        <tr>
                            <td>24</td>
                            <td>Data Export</td>
                            <td>Download modified dataset</td>
                            <td>Click the "Download Modified CSV" button</td>
                        </tr>
                        <tr>
                            <td>25</td>
                            <td>Charting & Visualization</td>
                            <td>Show Bar Chart</td>
                            <td><code>show bar chart of [numeric_col] by [categorical_col] [as sum/average]</code> (e.g., <code>show bar chart of sales by region as average</code>)</td>
                        </tr>
                        <tr>
                            <td>26</td>
                            <td>Charting & Visualization</td>
                            <td>Show Line Chart</td>
                            <td><code>show line chart with X as [column] and Y as [numeric_column]</code> (e.g., <code>show line chart with X as Date and Y as Stock Price</code>)</td>
                        </tr>
                        <tr>
                            <td>27</td>
                            <td>Charting & Visualization</td>
                            <td>Show Scatter Plot</td>
                            <td><code>show scatter plot with X as [numeric_column1] and Y as [numeric_column2]</code> (e.g., <code>show scatter plot with X as Age and Y as Income</code>)</td>
                        </tr>
                        <tr>
                            <td>28</td>
                            <td>Charting & Visualization</td>
                            <td>Show Pie Chart</td>
                            <td><code>show pie chart of [column]</code> (e.g., <code>show pie chart of Gender</code>) or <code>show pie chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>29</td>
                            <td>Charting & Visualization</td>
                            <td>Show Doughnut Chart</td>
                            <td><code>show doughnut chart of [column]</code> (e.g., <code>show doughnut chart of Region</code>) or <code>show doughnut chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>30</td>
                            <td>Charting & Visualization</td>
                            <td>Show Polar Area Chart</td>
                            <td><code>show polar area chart of [column]</code> (e.g., <code>show polar area chart of Status</code>) or <code>show polar area chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>31</td>
                            <td>Modeling</td>
                            <td>Perform Simple Linear Regression</td>
                            <td><code>perform regression with Y as [numeric_col_y] and X as [numeric_col_x]</code> (e.g., <code>perform regression with Y as Sales and X as Advertising</code>)</td>
                        </tr>
                        <tr>
                            <td colspan="4" class="text-center font-bold text-blue-300 bg-gray-700">New Feature: Proactive Insights</td>
                        </tr>
                        <tr>
                            <td>32</td>
                            <td>Automated Insights</td>
                            <td>Show Proactive Insights</td>
                            <td><code>show proactive insights</code> or <code>what insights do you have?</code></td>
                        </tr>
                    </tbody>
                </table>
                <p class="mt-4">If I've made a cleaning suggestion, you can simply type <strong>'yes'</strong> to confirm.</p>`;
        }


        // Handle CSV file input change
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                fileNameDisplay.textContent = `File: ${file.name}`;
                uploadStatus.textContent = 'Loading and parsing...';
                uploadStatus.className = 'mt-1 text-xs font-semibold text-blue-400 animate-pulse';

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        rawData = parseCSV(e.target.result);
                        schema = inferSchema(rawData);
                        displaySchema(schema);
                        uploadStatus.textContent = `Successfully loaded ${rawData.length} rows.`;
                        uploadStatus.className = 'mt-1 text-xs font-semibold text-green-500';

                        // Reset the flag for proactive alert when new data is loaded
                        hasProactiveAlertBeenShown = false; // NEW

                        // Proactively check for data cleaning needs
                        // This function will append a message if a suggestion is found
                        checkAndSuggestDataCleaning(rawData, schema);
                        
                        // Generate and *store* proactive insights, but don't display automatically
                        generateProactiveInsights();


                    } catch (error) {
                        uploadStatus.textContent = `Error parsing CSV: ${error.message}`;
                        uploadStatus.className = 'mt-1 text-xs font-semibold text-red-500';
                        appendMessage('AI', 'Oops! There was an error loading your CSV. Please ensure it\'s a valid CSV format with correct delimiters.', 'ai');
                    }
                };
                reader.readAsText(file);
            } else {
                fileNameDisplay.textContent = '';
                uploadStatus.textContent = 'No file selected.';
                uploadStatus.className = 'mt-1 text-xs font-semibold text-gray-400';
            }
        });

        // Function to append messages to the chat area
        function appendMessage(sender, text, type = 'user') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex mb-4 ${type === 'user' ? 'justify-end' : 'items-start'} fade-in-message`;

            if (type === 'user') {
                messageDiv.innerHTML = `
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                `;
            } else { // AI message
                messageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                `;
            }
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight; // Scroll to the bottom
        }

        // Helper to find a column by name (case-insensitive and partial match)
        function findColumnByName(rawName) {
            if (!rawName) return null; // Handle null/undefined input
            const lowerRawName = rawName.toLowerCase();
            for (const col in schema) {
                // Prioritize exact case-insensitive match
                if (col.toLowerCase() === lowerRawName) {
                    return col;
                }
            }
            // Fallback to partial case-insensitive match if no exact match
            for (const col in schema) {
                if (col.toLowerCase().includes(lowerRawName)) {
                    return col;
                }
            }
            return null;
        }

        // Helper to find a numeric column by name
        function findNumericColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'number') {
                return col;
            }
            return null;
        }

        // Helper to find a categorical column by name
        function findCategoricalColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'string') {
                return col;
            }
            return null;
        }

        // Helper for basic descriptive statistics for a numeric column
        function getDescriptiveStats(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return null;

            const sum = numericValues.reduce((a, b) => a + b, 0);
            const mean = sum / numericValues.length;

            const sorted = [...numericValues].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];

            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);

            const sumOfSquares = numericValues.reduce((s, val) => s + Math.pow(val - mean, 2), 0);
            const variance = sumOfSquares / (numericValues.length - 1);
            const stdDev = Math.sqrt(variance);

            return {
                count: numericValues.length,
                mean: mean,
                median: median,
                min: min,
                max: max,
                stdDev: stdDev,
                sum: sum
            };
        }

        // New Feature: Categorize numeric column into bins
        function categorizeNumericColumn(columnName, numBins, newColName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0 || numBins <= 0) return { success: false, message: 'Invalid data or number of bins.' };

            const minVal = Math.min(...numericValues);
            const maxVal = Math.max(...numericValues);
            const binSize = (maxVal - minVal) / numBins;

            if (binSize === 0) { // All values are the same
                rawData = rawData.map(row => ({
                    ...row,
                    [newColName]: `${minVal.toFixed(2)} - ${maxVal.toFixed(2)}`
                }));
                schema[newColName] = 'string';
                displaySchema(schema);
                return { success: true, message: `All values in "${columnName}" are the same. Created a single bin for "${newColName}".` };
            }

            rawData = rawData.map(row => {
                const value = Number(row[columnName]);
                if (isNaN(value)) {
                    return { ...row, [newColName]: 'N/A' };
                }
                let binIndex = Math.floor((value - minVal) / binSize);
                // Ensure the max value falls into the last bin
                if (binIndex === numBins) {
                    binIndex = numBins - 1;
                }

                const binStart = minVal + binIndex * binSize;
                const binEnd = minVal + (binIndex + 1) * binSize;
                return {
                    ...row,
                    [newColName]: `${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`
                };
            });
            schema[newColName] = 'string';
            displaySchema(schema);
            return { success: true, message: `Categorized "<strong>${columnName}</strong>" into <strong>${numBins} bins</strong> and created a new column "<strong>${newColName}</strong>".` };
        }

        // New Feature: Remove duplicate rows
        function removeDuplicateRows(data) {
            const initialLength = data.length;
            const seen = new Set();
            const uniqueData = [];

            data.forEach(row => {
                const rowString = JSON.stringify(row); // Simple serialization for comparison
                if (!seen.has(rowString)) {
                    seen.add(rowString);
                    uniqueData.push(row);
                }
            });
            rawData = uniqueData; // Update global rawData
            const removedCount = initialLength - rawData.length;
            return { success: true, removedCount };
        }

        // New Feature: Rename column
        function renameColumn(oldName, newName) {
            const actualOldName = findColumnByName(oldName);
            if (!actualOldName) {
                return { success: false, message: `Column "<strong>${oldName}</strong>" not found.` };
            }
            if (Object.keys(schema).includes(newName)) {
                return { success: false, message: `Column "<strong>${newName}</strong>" already exists.` };
            }

            rawData = rawData.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === actualOldName) {
                        newRow[newName] = row[key];
                    } else {
                        newRow[key] = row[key];
                    }
                }
                return newRow;
            });

            // Update schema
            const newSchema = {};
            for (const key in schema) {
                if (key === actualOldName) {
                    newSchema[newName] = schema[key];
                } else {
                    newSchema[key] = schema[key];
                }
            }
            schema = newSchema;
            displaySchema(schema);
            return { success: true, message: `Column "<strong>${actualOldName}</strong>" successfully renamed to "<strong>${newName}</strong>".` };
        }

        // Function to download the current rawData as a CSV file
        function downloadCSV() {
            if (rawData.length === 0 || Object.keys(schema).length === 0) {
                appendMessage('AI', 'There is no data loaded to download. Please upload a CSV first!', 'ai');
                return;
            }

            const headers = Object.keys(schema);
            const csvRows = [];

            // Add headers row
            csvRows.push(headers.map(header => `"${header}"`).join(','));

            // Add data rows
            rawData.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header];
                    // Escape double quotes by doubling them, and wrap in quotes if contains comma or double quote
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvRows.push(values.join(','));
            });

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'CoDA_Modified_Data.csv');
            link.style.visibility = 'hidden'; // Hide the link
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link); // Clean up
            URL.revokeObjectURL(url); // Free up memory

            appendMessage('AI', 'Your modified dataset has been downloaded as **CoDA_Modified_Data.csv**!', 'ai');
        }

        // Event listener for the download button
        downloadCsvBtn.addEventListener('click', downloadCSV);

        // --- Data Panel Toggle Logic ---
        // Initial setup for data panel: ensure it starts hidden and button reflects this
        dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden'); // Ensure it starts hidden and collapses on md+
        chatPanel.classList.remove('md:w-2/3'); // Ensure chat panel takes full width initially on md+
        chatPanel.classList.add('md:w-full');
        toggleButtonText.textContent = 'Show Data Panel';
        toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2';

        toggleDataPanelBtn.addEventListener('click', () => {
            // Determine visibility by checking for 'hidden' class
            const isCurrentlyHidden = dataPanel.classList.contains('hidden');

            if (isCurrentlyHidden) {
                // Show data panel
                dataPanel.classList.remove('hidden', 'md:w-0', 'md:hidden');
                dataPanel.classList.add('flex', 'md:w-1/3');
                chatPanel.classList.remove('md:w-full');
                chatPanel.classList.add('md:w-2/3');
                toggleButtonText.textContent = 'Hide Data Panel';
                toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye-slash mr-2';
            } else {
                // Hide data panel
                dataPanel.classList.remove('flex', 'md:w-1/3');
                dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden');
                chatPanel.classList.remove('md:w-2/3');
                chatPanel.classList.add('md:w-full');
                toggleButtonText.textContent = 'Show Data Panel';
                toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2';
            }
        });

        // Event listener for the toggle command guide button
        toggleCommandGuideBtn.addEventListener('click', () => {
            // Show the overlay
            commandGuideOverlay.classList.remove('hidden');
            commandGuideContent.innerHTML = getCommandListHtml(); // Populate the content
            // Update the text/icon of the toggle button itself to reflect it's "hiding" the guide
            toggleCommandGuideText.textContent = 'Hide Command Guide';
            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
        });

        // Event listener for the close button INSIDE the overlay
        closeCommandGuideBtn.addEventListener('click', () => {
            // Hide the overlay
            commandGuideOverlay.classList.add('hidden');
            // Reset the toggle button's text/icon
            toggleCommandGuideText.textContent = 'Show Command Guide';
            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';
        });

        // Event listener for the new "Show Proactive Insights" button
        showProactiveInsightsBtn.addEventListener('click', () => {
            generateProactiveInsights(); // This now populates lastProactiveInsights
            renderProactiveInsights(); // Then render them with current filters
            proactiveInsightsOverlay.classList.remove('hidden'); // Show the overlay
        });

        // Event listener for the close button INSIDE the proactive insights overlay
        closeProactiveInsightsBtn.addEventListener('click', () => {
            proactiveInsightsOverlay.classList.add('hidden'); // Hide the overlay
        });

        /**
         * Helper function to parse dates. Handles common formats.
         * @param {string} dateString
         * @returns {Date | null} Parsed Date object or null if invalid.
         */
        function parseDate(dateString) {
            try {
                const date = new Date(dateString);
                // Check if date is valid (e.g., handles "Invalid Date")
                return isNaN(date.getTime()) ? null : date;
            } catch (e) {
                console.warn(`Could not parse date string: ${dateString}`);
                return null;
            }
        }

        /**
         * Helper to get sum of a numeric column for a filtered dataset.
         * @param {string} colName - The name of the numeric column.
         * @param {Array<Object>} dataSubset - The subset of data to calculate the sum for.
         * @returns {number} The sum of the column, or 0 if no valid numbers.
         */
        function getSumFromSubset(colName, dataSubset) {
            return dataSubset.reduce((acc, row) => {
                const val = Number(row[colName]);
                return acc + (isNaN(val) ? 0 : val);
            }, 0);
        }

        /**
         * Generates and returns proactive insights as an HTML string.
         * This includes anomaly detection and identifying top/bottom performers, and correlations.
         * @returns {string | null} An HTML string containing the insights, or null if no data.
         */
        function generateProactiveInsights() {
            if (rawData.length === 0) {
                lastProactiveInsights = []; // Clear previous insights if data is gone
                return; // No data to analyze
            }

            let insights = [];
            let currentAlertMessages = []; // Array to hold messages for the single initial alert

            // Dynamically get numeric and categorical columns
            const numericCols = Object.keys(schema).filter(col => schema[col] === 'number');
            const categoricalCols = Object.keys(schema).filter(col => schema[col] === 'string');

            // 1. Sales Drop Anomaly Detection with Root Cause Suggestion (if relevant columns exist)
            const dateCol = findColumnByName('Date') || findColumnByName('Order Date') || findColumnByName('Transaction Date');
            const salesCol = findNumericColumn('Sales') || findNumericColumn('Revenue') || findNumericColumn('Amount');
            const regionCol = findCategoricalColumn('Region') || findCategoricalColumn('Area') || findCategoricalColumn('Territory');
            const marketingSpendCol = findNumericColumn('Marketing_Spend') || findNumericColumn('Ad_Spend') || findNumericColumn('Campaign_Cost');

            if (dateCol && salesCol && regionCol) {
                // Get all unique dates and sort them to find the latest
                const uniqueDates = [...new Set(rawData.map(row => row[dateCol]))]
                                    .map(parseDate)
                                    .filter(d => d !== null)
                                    .sort((a, b) => a.getTime() - b.getTime());

                if (uniqueDates.length >= 8) { // Need at least 8 days for 1 current + 7 historical
                    const latestDate = uniqueDates[uniqueDates.length - 1];
                    const eightDaysAgo = new Date(latestDate.getTime());
                    eightDaysAgo.setDate(latestDate.getDate() - 7); // Start of the 7-day lookback period

                    const regions = [...new Set(rawData.map(row => row[regionCol]))].filter(r => r); // Get unique regions

                    regions.forEach(region => {
                        const regionData = rawData.filter(row => row[regionCol] === region && parseDate(row[dateCol]) !== null);

                        const currentDaySalesData = regionData.filter(row => {
                            const date = parseDate(row[dateCol]);
                            return date && date.getDate() === latestDate.getDate() &&
                                   date.getMonth() === latestDate.getMonth() &&
                                   date.getFullYear() === latestDate.getFullYear();
                        });
                        const currentDaySales = getSumFromSubset(salesCol, currentDaySalesData);

                        const last7DaysSalesData = regionData.filter(row => {
                            const date = parseDate(row[dateCol]);
                            return date && date.getTime() >= eightDaysAgo.getTime() && date.getTime() < latestDate.getTime();
                        });
                        const last7DaysAvgSales = last7DaysSalesData.length > 0 ? getSumFromSubset(salesCol, last7DaysSalesData) / last7DaysSalesData.length : 0;

                        if (last7DaysAvgSales > 0) {
                            const salesDropPercentage = ((last7DaysAvgSales - currentDaySales) / last7DaysAvgSales) * 100;
                            const dropThreshold = 15; // Define significant drop threshold

                            if (salesDropPercentage > dropThreshold) {
                                let alertMessage = `**Sales Drop:** ${region} region sales are down ${salesDropPercentage.toFixed(1)}% on ${latestDate.toLocaleDateString()}.`;
                                if (marketingSpendCol) {
                                    const currentDayMarketingSpend = getSumFromSubset(marketingSpendCol, currentDaySalesData);
                                    const last7DaysMarketingSpend = last7DaysSalesData.length > 0 ? getSumFromSubset(marketingSpendCol, last7DaysSalesData) / last7DaysSalesData.length : 0;
                                    const marketingSpendDeviation = last7DaysMarketingSpend > 0 ? Math.abs((currentDayMarketingSpend - last7DaysMarketingSpend) / last7DaysMarketingSpend) * 100 : Infinity;
                                    const marketingConsistencyThreshold = 10;
                                    if (marketingSpendDeviation <= marketingConsistencyThreshold) {
                                        alertMessage += ` (Consistent marketing spend)`;
                                    } else {
                                        alertMessage += ` (Marketing spend changed)`;
                                    }
                                }
                                currentAlertMessages.push(alertMessage);

                                insights.push({
                                    type: 'anomaly',
                                    icon: 'fas fa-chart-line-down',
                                    title: `Significant Sales Drop Detected in ${region} Region!`,
                                    message: `Sales in the **${region} region** are **down ${salesDropPercentage.toFixed(1)}%** on ${latestDate.toLocaleDateString()} compared to the last 7-day average. This deviation is significant.` + (marketingSpendCol ? (marketingSpendDeviation <= marketingConsistencyThreshold ? ` This is despite a **consistent marketing spend** in the region.` : ` It also appears **marketing spend has changed** significantly in this period.`) : '') + `<br><br><strong>Recommendation:</strong>
                                        <ol>
                                            <li><strong>Investigate Sales Transactions:</strong> Examine specific sales transactions in ${region} for ${latestDate.toLocaleDateString()} to identify immediate patterns. Type: \`filter data where ${regionCol} = "${region}" and ${dateCol} = "${latestDate.toLocaleDateString('en-US', {year: 'numeric', month: '2-digit', day: '2-digit'})}"\`</li>
                                            <li><strong>Review External Factors:</strong> This suggests external factors may be at play. Consider reviewing recent mobile app updates, website traffic analytics, or local events that might impact sales in the ${region} region.</li>
                                            <li><strong>Engage Relevant Teams:</strong> If external analysis points to a technical issue, consider alerting your mobile development or product team.</li>
                                        </ol>
                                        <em>(Note: CoDA is a client-side tool and cannot directly interact with external systems like email or Jira.)</em>`,
                                    action: `filter data where ${regionCol} = "${region}" and ${dateCol} = "${latestDate.toLocaleDateString('en-US', {year: 'numeric', month: '2-digit', day: '2-digit'})}"`
                                });
                            }
                        }
                    });
                }
            }


            // 2. Anomaly Detection (Outliers) - for ALL numeric columns
            if (numericCols.length > 0) { // Only proceed if there are numeric columns
                numericCols.forEach(col => {
                    const { outliers, lowerBound, upperBound } = findOutliers(col, rawData);
                    if (outliers.length > 0) {
                        const outlierMessage = `**Anomaly detected:** ${outliers.length} outliers in "<strong>${col}</strong>".`;
                        currentAlertMessages.push(outlierMessage);

                        insights.push({
                            type: 'anomaly',
                            icon: 'fas fa-exclamation-triangle',
                            title: `Outliers Detected in ${col} Column`,
                            message: `I've detected **${outliers.length} potential outliers** in the numeric column "<strong>${col}</strong>". These values fall outside the IQR bounds (${lowerBound} - ${upperBound}). This could indicate data entry errors or unusual events that warrant further investigation.`,
                            action: `find outliers in ${col}`
                        });
                    }
                });
            }

            // 3. Top/Bottom Performer Identification for numeric values by categorical groups
            if (categoricalCols.length > 0 && numericCols.length > 0) { // Only proceed if both types of columns exist
                categoricalCols.forEach(catCol => {
                    if (catCol === dateCol || catCol === regionCol) return; // Skip date and region columns for this specific insight type

                    numericCols.forEach(numCol => {
                        const groupedData = {};
                        rawData.forEach(row => {
                            const category = row[catCol];
                            const numericValue = Number(row[numCol]);

                            if (!isNaN(numericValue)) {
                                if (!groupedData[category]) {
                                    groupedData[category] = { sum: 0, count: 0 };
                                }
                                groupedData[category].sum += numericValue;
                                groupedData[category].count++;
                            }
                        });

                        const sortedBySum = Object.entries(groupedData).sort(([, a], [, b]) => b.sum - a.sum);
                        const sortedByAvg = Object.entries(groupedData)
                                                .map(([category, data]) => [category, data.sum / data.count])
                                                .filter(([, avg]) => !isNaN(avg))
                                                .sort(([, a], [, b]) => b - a);

                        if (sortedBySum.length > 1) {
                            const topSumCat = sortedBySum[0];
                            const bottomSumCat = sortedBySum[sortedBySum.length - 1];
                            
                            // New alert for significant top/bottom performers (e.g., top 1 has significantly more than next)
                            if (sortedBySum.length >= 2 && topSumCat[1].sum > 0) {
                                const ratio = topSumCat[1].sum / sortedBySum[1][1].sum;
                                if (ratio > 2 && topSumCat[1].sum > 100) { // Top performer is at least 2x the next and has substantial sum
                                    currentAlertMessages.push(`**Key Trend:** "<strong>${topSumCat[0]}</strong>" is a dominant performer in "<strong>${catCol}</strong>" for **total ${numCol}**.`);
                                }
                            }

                            insights.push({
                                type: 'trend',
                                icon: 'fas fa-chart-line',
                                title: `Top/Bottom ${numCol} by ${catCol} (Total)`,
                                message: `For **total ${numCol}**, "<strong>${topSumCat[0]}</strong>" in **${catCol}** has the highest sum (${topSumCat[1].sum.toFixed(2)}), while "<strong>${bottomSumCat[0]}</strong>" has the lowest (${bottomSumCat[1].sum.toFixed(2)}). This highlights key areas of high and low aggregate performance.`,
                                action: `show bar chart of ${numCol} by ${catCol} as sum`
                            });
                        }

                        if (sortedByAvg.length > 1) {
                            const topAvgCat = sortedByAvg[0];
                            const bottomAvgCat = sortedByAvg[sortedByAvg.length - 1];
                            // New alert for significant top/bottom performers (average)
                            if (sortedByAvg.length >= 2 && topAvgCat[1] > 0) {
                                const ratio = topAvgCat[1] / sortedByAvg[1][1];
                                if (ratio > 2 && topAvgCat[1] > 10) { // Top performer (average) is at least 2x the next and has substantial average
                                    currentAlertMessages.push(`**Efficiency Highlight:** "<strong>${topAvgCat[0]}</strong>" has a significantly high average for "<strong>${numCol}</strong>" in "<strong>${catCol}</strong>".`);
                                }
                            }

                            insights.push({
                                type: 'trend',
                                    icon: 'fas fa-chart-bar',
                                title: `Top/Bottom ${numCol} by ${catCol} (Average)`,
                                message: `For **average ${numCol}**, "<strong>${topAvgCat[0]}</strong>" in **${catCol}** shows the highest average (${topAvgCat[1].toFixed(2)}), whereas "<strong>${bottomAvgCat[0]}</strong>" has the lowest (${bottomAvgCat[1].toFixed(2)}). This reveals efficiency or intensity per category.`,
                                action: `show bar chart of ${numCol} by ${catCol} as average`
                            });
                        }
                    });
                });
            }

            // 4. Correlation Insights between numeric columns
            if (numericCols.length >= 2) { // Need at least two numeric columns for correlation
                for (let i = 0; i < numericCols.length; i++) {
                    for (let j = i + 1; j < numericCols.length; j++) {
                        const col1 = numericCols[i];
                        const col2 = numericCols[j];
                        const correlation = calculateCorrelation(col1, col2, rawData);
                        if (correlation !== null && !isNaN(correlation)) {
                            const absCorrelation = Math.abs(correlation);
                            if (absCorrelation >= 0.7) { // Define "strong" correlation as alert-worthy
                                const direction = correlation > 0 ? 'positive' : 'negative';
                                const correlationAlert = `**Strong Correlation:** ${direction} correlation (${correlation.toFixed(2)}) between "<strong>${col1}</strong>" and "<strong>${col2}</strong>".`;
                                currentAlertMessages.push(correlationAlert);

                                insights.push({
                                    type: 'correlation',
                                    icon: 'fas fa-link',
                                    title: `Correlation between ${col1} and ${col2}`,
                                    message: `There's a **very strong** ${direction} correlation (${correlation.toFixed(2)}) between "<strong>${col1}</strong>" and "<strong>${col2}</strong>". These columns move very closely together, indicating a strong direct or inverse relationship.`,
                                    action: `show scatter plot with X as ${col1} and Y as ${col2}`
                                });
                            }
                        }
                    }
                }
            }

            // 5. Categorical Distribution - Top N most/least frequent values
            if (categoricalCols.length > 0) { // Only proceed if there are categorical columns
                categoricalCols.forEach(catCol => {
                    if (catCol === dateCol || catCol === regionCol) return; // Skip date and region columns for this specific insight type

                    const values = rawData.map(row => row[catCol]);
                    const valueCounts = {};
                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                    if (sortedCounts.length > 0) {
                        let topValues = sortedCounts.slice(0, Math.min(3, sortedCounts.length)).map(item => `"${item[0]}" (${((item[1]/values.length)*100).toFixed(1)}%)`).join(', ');
                        
                        // For distribution, alert if there's a highly skewed distribution (e.g., one value dominates significantly)
                        if (values.length > 0 && sortedCounts.length > 1) {
                             const topPercentage = (sortedCounts[0][1] / values.length) * 100;
                             if (topPercentage > 70) { // If one category is over 70% of the total values
                                currentAlertMessages.push(`**Skewed Distribution:** "<strong>${sortedCounts[0][0]}</strong>" dominates in "<strong>${catCol}</strong>" (${topPercentage.toFixed(1)}%).`);
                             }
                        }

                        insights.push({
                            type: 'distribution',
                            icon: 'fas fa-chart-pie',
                            title: `Distribution of ${catCol}`,
                            message: `In "<strong>${catCol}</strong>", the top values are: ${topValues}. There are ${sortedCounts.length} unique values in total. Understanding these distributions is crucial for market segmentation or resource allocation.`,
                            action: `show frequency of ${catCol}`
                        });
                    }
                });
            }

            // After all insights are gathered and `currentAlertMessages` is populated:
            // Condition for showing the alert message is removed here as requested by user
            /*
            if (currentAlertMessages.length > 0 && !hasProactiveAlertBeenShown) {
                const combinedAlert = `**Heads up! I found some significant insights in your data:**<br><ul><li>${currentAlertMessages.join('</li><li>')}</li></ul><br>_You can find more details and suggested actions in "Proactive Insights" (click the <i class="fas fa-lightbulb"></i> button)._`;
                appendMessage('AI', combinedAlert, 'ai');
                hasProactiveAlertBeenShown = true;
            }
            */

            lastProactiveInsights = insights;
        }

        // Helper function to render insights based on current filters and search
        function renderProactiveInsights(filterType = 'all', searchTerm = '') {
            proactiveInsightsContent.innerHTML = ''; // Clear previous content

            if (lastProactiveInsights.length === 0) {
                proactiveInsightsContent.innerHTML = '<p class="text-gray-400 text-center py-4">No proactive insights available yet. Upload a CSV file to generate proactive insights.</p>';
                return;
            }

            let filteredInsights = lastProactiveInsights.filter(insight => {
                const matchesFilter = filterType === 'all' || insight.type === filterType;
                const matchesSearch = searchTerm === '' ||
                                      insight.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                      insight.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                      insight.action.toLowerCase().includes(searchTerm.toLowerCase());
                return matchesFilter && matchesSearch;
            });

            if (filteredInsights.length === 0) {
                proactiveInsightsContent.innerHTML = `<p class="text-gray-400 text-center py-4">No insights match your current filters and search criteria.</p>`;
                return;
            }

            filteredInsights.forEach((insight, index) => {
                const insightCard = document.createElement('div');
                insightCard.className = 'insight-card';
                // Replace action button with a more flexible structure for multi-line recommendations
                // The 'Suggested Action' part should now correctly parse HTML from the message.
                insightCard.innerHTML = `
                    <div class="insight-header cursor-pointer" data-insight-index="${index}">
                        <i class="${insight.icon}"></i>
                        <h4>${insight.title}</h4>
                        <i class="fas fa-chevron-down ml-auto transition-transform"></i>
                    </div>
                    <div class="collapsible-content">
                        <p class="insight-message">${insight.message}</p>
                        ${insight.action ? `<span class="text-sm text-blue-100 italic">Suggested Command: </span><a href="#" class="insight-action" onclick="typeIntoChatAndSubmit('${insight.action.replace(/'/g, "\\'")}'); return false;">'${insight.action}'</a>` : ''}
                    </div>
                `;
                proactiveInsightsContent.appendChild(insightCard);
            });

            // Add event listeners for collapsing
            document.querySelectorAll('.insight-header').forEach(header => {
                header.addEventListener('click', (event) => {
                    const content = header.nextElementSibling; // Get the .collapsible-content
                    const icon = header.querySelector('.fa-chevron-down');

                    if (content.classList.contains('show')) {
                        content.classList.remove('show');
                        icon.classList.remove('rotate-180');
                    } else {
                        // Hide all other open insights
                        document.querySelectorAll('.collapsible-content.show').forEach(openContent => {
                            openContent.classList.remove('show');
                            openContent.previousElementSibling.querySelector('.fa-chevron-down').classList.remove('rotate-180');
                        });
                        content.classList.add('show');
                        icon.classList.add('rotate-180');
                    }
                });
            });
        }


        // Helper function to simulate typing into chat and submitting
        function typeIntoChatAndSubmit(command) {
            chatInput.value = command;
            sendMessageBtn.click();
            proactiveInsightsOverlay.classList.add('hidden'); // Close the insights overlay
        }

        // LLM Integration - Structured Response Schema
        const llmResponseSchema = {
            type: "OBJECT",
            properties: {
                command: {
                    type: "STRING",
                    enum: [
                        "show_all_data", "show_column", "count_rows", "describe_dataset", "show_schema",
                        "sum", "average", "median", "standard_deviation", "quartiles",
                        "count_unique", "show_frequency", "min", "max", "average_by",
                        "correlation", "find_outliers", "filter_data", "add_column", "categorize",
                        "remove_duplicates", "rename_column", "summarize_by", "business_overview",
                        "show_bar_chart", "show_line_chart", "show_scatter_plot", "show_pie_chart",
                        "show_doughnut_chart", "show_polar_area_chart", "perform_regression",
                        "show_proactive_insights", "show_command_guide", "confirm_cleaning",
                        "unrecognized_command" // Fallback for commands not understood by LLM
                    ]
                },
                parameters: {
                    type: "OBJECT",
                    properties: {
                        columnName: { "type": "STRING" },
                        numericColumn: { "type": "STRING" },
                        categoricalColumn: { "type": "STRING" },
                        operator: { "type": "STRING" }, // For filter: e.g., ">", "<", "=", "!="
                        value: { "type": "STRING" },    // For filter: value to compare against
                        newColumnName: { "type": "STRING" }, // For add_column, categorize
                        col1: { "type": "STRING" },      // For add_column, correlation, regression
                        col2: { "type": "STRING" },      // For add_column, correlation, regression
                        mathOperator: { "type": "STRING", "enum": ["plus", "minus", "times", "divided by"] }, // For add_column
                        aggregateType: { "type": "STRING", "enum": ["sum", "average"] }, // For aggregated charts/summaries
                        numBins: { "type": "NUMBER" },   // For categorize
                        oldName: { "type": "STRING" },   // For rename_column
                        newName: { "type": "STRING" },   // For rename_column
                        xColumn: { "type": "STRING" },   // For charts
                        yColumn: { "type": "STRING" }    // For charts, regression
                    },
                    additionalProperties: true // Allow LLM to return other properties if needed
                }
            },
            required: ["command"],
            additionalProperties: false
        };

        // LLM endpoint configuration
        const API_KEY = "AIzaSyAPKzY43U4DfSMrUb43KiFBbD6n7JnhFU8"; // Your provided API key
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;


        async function simulateAIResponse(query) {
            let aiResponseText = '';
            let analysisContent = '';
            const lowerQuery = query.toLowerCase();

            if (rawData.length === 0 && !lowerQuery.includes('command guide') && lowerQuery !== 'yes' && lowerQuery !== 'y') {
                appendMessage('AI', "Please upload a CSV file first before asking questions. I'm ready when you are!", 'ai');
                return;
            }

            // --- Handle Cleaning Confirmation (Pre-LLM processing) ---
            if (pendingCleaningSuggestion && (lowerQuery === 'yes' || lowerQuery === 'y' || lowerQuery.includes('confirm') || lowerQuery.includes('go ahead'))) {
                const colToClean = pendingCleaningSuggestion.column;
                if (pendingCleaningSuggestion.action === 'fill_average') {
                    const average = calculateColumnAverage(colToClean, rawData);
                    rawData = rawData.map(row => {
                        if (row[colToClean] === '' || isNaN(Number(row[colToClean])) || row[colToClean] === null || row[colToClean] === undefined) {
                            row[colToClean] = average.toFixed(2); // Fill with average, keeping two decimal places
                        }
                        return row;
                    });
                    aiResponseText = `Great! I've successfully filled the ${pendingCleaningSuggestion.count} missing values in the column "<strong>${colToClean}</strong>" with the calculated average of <strong>${average.toFixed(2)}</strong>. Your data has been updated locally and privately.`;
                    pendingCleaningSuggestion = null; // Clear the suggestion after execution
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }
            // --- End Cleaning Confirmation ---

            // --- LLM Call Logic ---
            let thinkingMessageDiv; // Declare outside try-catch to be accessible by finally
            try {
                // Add a thinking message
                thinkingMessageDiv = document.createElement('div');
                thinkingMessageDiv.className = 'flex items-start mb-4 fade-in-message';
                thinkingMessageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md">
                        <p class="leading-relaxed">...Thinking...</p>
                    </div>
                `;
                chatArea.appendChild(thinkingMessageDiv);
                chatArea.scrollTop = chatArea.scrollHeight;

                // Prepare chat history for the LLM. For simplicity, we'll only send the current query.
                // In a full chatbot, you'd maintain a history.
                // Adding a system instruction to guide the LLM's structured response.
                const systemInstruction = `You are CoDA, a Cognitive Data Assistant. Your primary function is to help users analyze CSV data locally.
Your responses MUST be a JSON object conforming to the following schema:
${JSON.stringify(llmResponseSchema, null, 2)}

Based on the user's query and the available data operations, determine the most appropriate 'command' and its 'parameters'.
If you cannot understand the user's intent or it does not map to any available command, respond with:
{ "command": "unrecognized_command" }

Available columns in the dataset are: ${Object.keys(schema).join(', ') || 'N/A'}.
Available column types are: ${JSON.stringify(schema)}.
If the user asks for a chart, always try to infer both X and Y columns, and if aggregation is implied, specify 'sum' or 'average'.
Prioritize using existing column names accurately. If a column is numeric, use numeric operations; if string, use categorical operations.
When performing calculations, ensure the columns are numeric.
When creating new columns, use 'plus', 'minus', 'times', or 'divided by'.
When filtering, use '>', '<', '>=', '<=', '=', '!='.
`;

                let chatHistory = [
                    { role: "system", parts: [{ text: systemInstruction }] },
                    { role: "user", parts: [{ text: query }] }
                ];

                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: llmResponseSchema,
                        temperature: 0.1 // Keep it low for more deterministic command outputs
                    },
                    safetySettings: [ // Add safety settings as a good practice
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    ],
                };

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // Check for HTTP errors (e.g., 400, 401, 500)
                if (!response.ok) {
                    const errorData = await response.json(); // Try to get error details
                    console.error("LLM API Error:", response.status, response.statusText, errorData);
                    throw new Error(`LLM API returned an error: ${response.status} ${response.statusText}. Details: ${JSON.stringify(errorData.error.message || errorData)}`);
                }

                const result = await response.json();
                
                // Remove thinking message
                if (thinkingMessageDiv) {
                    thinkingMessageDiv.remove();
                }

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    const jsonString = result.candidates[0].content.parts[0].text;
                    let parsedCommand;
                    try {
                        parsedCommand = JSON.parse(jsonString);
                        console.log("Parsed LLM Command:", parsedCommand); // Log parsed command for debugging
                    } catch (e) {
                        console.error("Failed to parse LLM JSON response. Raw response was:", jsonString, "Error:", e);
                        aiResponseText = "I received a response, but couldn't understand its format. Could you please rephrase?";
                        appendMessage('AI', aiResponseText, 'ai');
                        return;
                    }

                    const command = parsedCommand.command;
                    const params = parsedCommand.parameters || {};

                    // Check if LLM returned "unrecognized_command" or if the command is not in our enum
                    if (command === "unrecognized_command" || !llmResponseSchema.properties.command.enum.includes(command)) {
                         aiResponseText = `I'm sorry, I didn't understand that request. Please try rephrasing, or refer to the <a href="#" onclick="toggleCommandGuideBtn.click(); return false;" class="text-blue-400 hover:text-blue-200 underline">command guide</a>.`;
                         appendMessage('AI', aiResponseText, 'ai');
                         return;
                    }


                    // --- Execute Command based on LLM's parsed intent ---
                    switch (command) {
                        case 'show_all_data':
                            analysisContent = `<p class="text-gray-300 mt-2">Here's a preview of the **first 10 rows** from your dataset:</p>
                                                <div class="code-block mt-2">${rawData.slice(0, 10).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>
                                                <p class="text-sm text-gray-400 mt-2">You have a total of ${rawData.length} rows. This data is processed entirely on your device!</p>`;
                            aiResponseText = `Understood! Here's your data:`;
                            break;
                        case 'show_column':
                            const colNameShow = findColumnByName(params.columnName);
                            if (colNameShow) {
                                const columnValues = rawData.map(row => row[colNameShow]);
                                analysisContent = `<p class="text-gray-300 mt-2">Here are the **first 10 values** from the "<strong>${colNameShow}</strong>" column:</p>
                                                  <div class="code-block mt-2">${columnValues.slice(0, 10).join('\n')}</div>
                                                  <p class="text-sm text-gray-400 mt-2">There are ${columnValues.length} total values in this column.</p>`;
                                aiResponseText = `Absolutely! Here's the data for column "${colNameShow}", retrieved instantly from your local dataset.`;
                            } else {
                                aiResponseText = `I couldn't find the column "<strong>${params.columnName}</strong>". Please check your column name.`;
                            }
                            break;
                        case 'count_rows':
                            const numRows = rawData.length;
                            aiResponseText = `Your dataset currently contains **${numRows} rows** (records).`;
                            break;
                        case 'describe_dataset':
                            let numDsRows = rawData.length;
                            let numDsCols = Object.keys(schema).length;
                            let descriptionNarrative = `<p class="text-gray-300 leading-relaxed mb-3">Alright, let's take a look at your dataset. It appears you have <strong>${numDsRows} rows</strong>, which means ${numDsRows} individual records, and <strong>${numDsCols} columns</strong>, representing ${numDsCols} different types of information.</p>
                                                        <h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Here's a breakdown of what I found in each column:</h5>
                                                        <ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;

                            for (const col in schema) {
                                descriptionNarrative += `<li class="font-medium">${col}: (<span class="text-blue-400">${schema[col]}</span> type) `;
                                const values = rawData.map(row => row[col]);

                                if (schema[col] === 'number') {
                                    const numericValues = values.map(Number).filter(n => !isNaN(n));
                                    const { min: minVal, max: maxVal } = calculateColumnMinMax(col, rawData);
                                    const avgVal = calculateColumnAverage(col, rawData);
                                    const medianVal = calculateMedian(col, rawData);
                                    const stdDevVal = calculateStandardDeviation(col, rawData);
                                    const quartiles = calculateQuartiles(col, rawData);

                                    if (numericValues.length > 0) {
                                        descriptionNarrative += `This column contains numerical data, ranging from <strong>${minVal}</strong> to <strong>${maxVal}</strong>, with an average value of approximately <strong>${avgVal.toFixed(2)}</strong>.`;
                                        if (medianVal !== null) descriptionNarrative += ` The median is <strong>${medianVal.toFixed(2)}</strong>.`;
                                        if (stdDevVal !== null) descriptionNarrative += ` Standard deviation is <strong>${stdDevVal.toFixed(2)}</strong>.`;
                                        if (quartiles.q1 !== null) descriptionNarrative += ` Q1 is <strong>${quartiles.q1}</strong>, Q3 is <strong>${quartiles.q3}</strong>, and the IQR is <strong>${quartiles.iqr}</strong>.`;
                                        const correlationWithOtherNumerics = [];
                                        for (const otherCol in schema) {
                                            if (otherCol !== col && schema[otherCol] === 'number') {
                                                const corr = calculateCorrelation(col, otherCol, rawData);
                                                if (corr !== null && !isNaN(corr)) {
                                                    correlationWithOtherNumerics.push(`${otherCol}: ${corr.toFixed(2)}`);
                                                }
                                            }
                                        }
                                        if (correlationWithOtherNumerics.length > 0) {
                                            descriptionNarrative += ` It shows correlations with other numeric columns: ${correlationWithOtherNumerics.join(', ')}.`;
                                        }
                                    } else {
                                        descriptionNarrative += `This numeric column currently has no valid numerical entries.`;
                                    }
                                } else { // string type
                                    const uniqueValues = [...new Set(values)];
                                    const valueCounts = {};
                                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                                    descriptionNarrative += `This column holds text information. I found <strong>${uniqueValues.length} unique values</strong>. The most frequent entries are: ${sortedCounts.slice(0, 5).map(item => `"${item[0]}" appearing ${item[1]} times`).join(', ')}.`;
                                }
                                descriptionNarrative += `</li>`;
                            }
                            descriptionNarrative += `</ul>`;
                            analysisContent = descriptionNarrative;
                            aiResponseText = `Certainly! Here's a comprehensive overview and description of your dataset, crafted to give you quick insights. This analysis was performed entirely client-side, ensuring your data's privacy.`;
                            break;
                        case 'show_schema':
                            analysisContent = `<p class="text-gray-300 mt-2">Here's the **schema I inferred** from your uploaded data:</p>
                                                <div class="code-block mt-2">${JSON.stringify(schema, null, 2)}</div>`;
                            aiResponseText = `Certainly! I've extracted the schema for you. All schema inference happens privately in your browser.`;
                            break;
                        case 'sum':
                            const foundSumCol = findNumericColumn(params.columnName);
                            if (foundSumCol) {
                                const sum = calculateColumnSum(foundSumCol, rawData);
                                analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The sum of "${foundSumCol}" is: ${sum.toFixed(2)}</p>`;
                                aiResponseText = `Alright, I've calculated the **total sum** for the column "<strong>${foundSumCol}</strong>". Here's the result:`;
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the sum for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'average':
                            const foundAvgCol = findNumericColumn(params.columnName);
                            if (foundAvgCol) {
                                const average = calculateColumnAverage(foundAvgCol, rawData);
                                analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The average of "${foundAvgCol}" is: ${average.toFixed(2)}</p>`;
                                aiResponseText = `Understood! Here's the **average value** for the "<strong>${foundAvgCol}</strong>" column:`;
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the average for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'median':
                            const foundMedianCol = findNumericColumn(params.columnName);
                            if (foundMedianCol) {
                                const median = calculateMedian(foundMedianCol, rawData);
                                if (median !== null) {
                                    aiResponseText = `The **median** for the column "<strong>${foundMedianCol}</strong>" is: <strong>${median.toFixed(2)}</strong>.`;
                                } else {
                                    aiResponseText = `I couldn't calculate the median for "<strong>${foundMedianCol}</strong>" as it contains no valid numeric data.`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the median for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'standard_deviation':
                            const foundStdDevCol = findNumericColumn(params.columnName);
                            if (foundStdDevCol) {
                                const stdDev = calculateStandardDeviation(foundStdDevCol, rawData);
                                if (stdDev !== null) {
                                    aiResponseText = `The **standard deviation** for the column "<strong>${foundStdDevCol}</strong>" is: <strong>${stdDev.toFixed(2)}</strong>.`;
                                } else {
                                    aiResponseText = `I couldn't calculate the standard deviation for "<strong>${foundStdDevCol}</strong>" as it contains insufficient numeric data (at least 2 values are needed).`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the standard deviation for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'quartiles':
                            const foundQuartilesCol = findNumericColumn(params.columnName);
                            if (foundQuartilesCol) {
                                const quartiles = calculateQuartiles(foundQuartilesCol, rawData);
                                if (quartiles.median !== null) {
                                    aiResponseText = `For the column "<strong>${foundQuartilesCol}</strong>":<br>
                                                    **Q1 (25th percentile)**: <strong>${quartiles.q1}</strong><br>
                                                    **Median (50th percentile)**: <strong>${quartiles.median}</strong><br>
                                                    **Q3 (75th percentile)**: <strong>${quartiles.q3}</strong><br>
                                                    **IQR (Interquartile Range)**: <strong>${quartiles.iqr}</strong>.`;
                                } else {
                                    aiResponseText = `I couldn't calculate quartiles for "<strong>${foundQuartilesCol}</strong>" as it contains no valid numeric data.`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate quartiles for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'count_unique':
                            const foundUniqueCol = findColumnByName(params.columnName);
                            if (foundUniqueCol) {
                                const values = rawData.map(row => row[foundUniqueCol]);
                                const uniqueCount = new Set(values).size;
                                aiResponseText = `The column "<strong>${foundUniqueCol}</strong>" has **${uniqueCount} unique values**.`;
                            } else {
                                aiResponseText = `I couldn't find the column "<strong>${params.columnName}</strong>" to count unique values. Please specify a valid column name.`;
                            }
                            break;
                        case 'show_frequency':
                            const foundFreqCol = findColumnByName(params.columnName);
                            if (foundFreqCol) {
                                const values = rawData.map(row => row[foundFreqCol]);
                                const valueCounts = {};
                                values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                                let frequencyList = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                sortedCounts.slice(0, 5).forEach(([value, count]) => {
                                    const percentage = ((count / values.length) * 100).toFixed(1);
                                    frequencyList += `<li>"<strong>${value}</strong>": ${count} occurrences (${percentage}%)</li>`;
                                });
                                frequencyList += `</ul>`;
                                aiResponseText = `Here's the **frequency distribution** for "<strong>${foundFreqCol}</strong>", showing the top 5 most common values:`;
                                analysisContent = frequencyList;
                            } else {
                                aiResponseText = `I couldn't find the column "<strong>${params.columnName}</strong>" to show its frequency. Please specify a valid column name.`;
                            }
                            break;
                        case 'min':
                            const foundMinCol = findNumericColumn(params.columnName);
                            if (foundMinCol) {
                                const { min } = calculateColumnMinMax(foundMinCol, rawData);
                                if (min !== null) {
                                    aiResponseText = `For the numeric column "<strong>${foundMinCol}</strong>":<br>The **minimum value** is: <strong>${min}</strong>.`;
                                } else {
                                    aiResponseText = `There are no valid numeric entries in "<strong>${foundMinCol}</strong>" to calculate the minimum.`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the minimum for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'max':
                            const foundMaxCol = findNumericColumn(params.columnName);
                            if (foundMaxCol) {
                                const { max } = calculateColumnMinMax(foundMaxCol, rawData);
                                if (max !== null) {
                                    aiResponseText = `For the numeric column "<strong>${foundMaxCol}</strong>":<br>The **maximum value** is: <strong>${max}</strong>.`;
                                } else {
                                    aiResponseText = `There are no valid numeric entries in "<strong>${foundMaxCol}</strong>" to calculate the maximum.`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to calculate the maximum for. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'average_by':
                            const avgByNumericCol = findNumericColumn(params.numericColumn);
                            const avgByCategoricalCol = findCategoricalColumn(params.categoricalColumn);

                            if (avgByNumericCol && avgByCategoricalCol) {
                                const groupedAverages = {};
                                const counts = {};

                                rawData.forEach(row => {
                                    const category = row[avgByCategoricalCol];
                                    const numericValue = Number(row[avgByNumericCol]);

                                    if (!isNaN(numericValue)) {
                                        if (!groupedAverages[category]) {
                                            groupedAverages[category] = 0;
                                            counts[category] = 0;
                                        }
                                        groupedAverages[category] += numericValue;
                                        counts[category]++;
                                    }
                                });

                                let resultsHtml = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                for (const category in groupedAverages) {
                                    const avg = (groupedAverages[category] / counts[category]).toFixed(2);
                                    resultsHtml += `<li><strong>${category}</strong>: Average ${avgByNumericCol} is <strong>${avg}</strong> (${counts[category]} entries)</li>`;
                                }
                                resultsHtml += `</ul>`;
                                aiResponseText = `Here's the **average of "${avgByNumericCol}" grouped by "${avgByCategoricalCol}"**:`;
                                analysisContent = resultsHtml;
                            } else {
                                aiResponseText = `I need both a valid numeric column and a valid categorical column to perform that aggregation. Please check your column names and types.`;
                            }
                            break;
                        case 'correlation':
                            const corrCol1 = findNumericColumn(params.col1);
                            const corrCol2 = findNumericColumn(params.col2);

                            if (corrCol1 && corrCol2) {
                                const correlation = calculateCorrelation(corrCol1, corrCol2, rawData);
                                if (correlation !== null) {
                                    let interpretation = '';
                                    if (correlation >= 0.7) interpretation = 'a **strong positive correlation**';
                                    else if (correlation >= 0.3) interpretation = 'a **moderate positive correlation**';
                                    else if (correlation > -0.3 && correlation < 0.3) interpretation = 'a **very weak or no linear correlation**';
                                    else if (correlation > -0.7) interpretation = 'a **moderate negative correlation**';
                                    else interpretation = 'a **strong negative correlation**';
                                    aiResponseText = `The **Pearson correlation coefficient** between "<strong>${corrCol1}</strong>" and "<strong>${corrCol2}</strong>" is: <strong>${correlation.toFixed(4)}</strong>. This indicates ${interpretation}.`;
                                } else {
                                    aiResponseText = `I couldn't calculate the correlation between "<strong>${corrCol1}</strong>" and "<strong>${corrCol2}</strong>" due to insufficient or invalid numeric data.`;
                                }
                            } else {
                                aiResponseText = `I need two valid numeric columns. Please check your column names and types.`;
                            }
                            break;
                        case 'find_outliers':
                            const findOutliersCol = findNumericColumn(params.columnName);
                            if (findOutliersCol) {
                                const { outliers, lowerBound, upperBound } = findOutliers(findOutliersCol, rawData);
                                if (outliers.length > 0) {
                                    aiResponseText = `I found **${outliers.length} potential outliers** in the column "<strong>${findOutliersCol}</strong>".<br>
                                                    These values fall outside the IQR bounds of <strong>${lowerBound}</strong> and <strong>${upperBound}</strong>.<br>
                                                    Outlier values (first 10): <strong>${outliers.slice(0, 10).join(', ')}</strong>.`;
                                } else {
                                    aiResponseText = `No significant outliers were detected in the column "<strong>${findOutliersCol}</strong>" based on the IQR method.`;
                                }
                            } else {
                                aiResponseText = `I couldn't find a numeric column named "<strong>${params.columnName}</strong>" to find outliers. Please specify a valid numeric column.`;
                            }
                            break;
                        case 'filter_data':
                            const filterColName = findColumnByName(params.columnName);
                            if (filterColName && params.operator && params.value) {
                                let filteredData = [];
                                let parsedValue;

                                if (schema[filterColName] === 'number') {
                                    parsedValue = Number(params.value);
                                    if (isNaN(parsedValue)) {
                                        aiResponseText = `It looks like the value "${params.value}" for numeric column "${filterColName}" isn't a valid number. Please provide a numeric value for filtering.`;
                                        break;
                                    }
                                    filteredData = rawData.filter(row => {
                                        const cellValue = Number(row[filterColName]);
                                        if (isNaN(cellValue)) return false;
                                        switch (params.operator) {
                                            case '>': return cellValue > parsedValue;
                                            case '<': return cellValue < parsedValue;
                                            case '>=': return cellValue >= parsedValue;
                                            case '<=': return cellValue <= parsedValue;
                                            case '=': return cellValue === parsedValue;
                                            case '!=': return cellValue !== parsedValue;
                                            default: return false;
                                        }
                                    });
                                } else { // string or other types
                                    parsedValue = params.value.toLowerCase();
                                    filteredData = rawData.filter(row => {
                                        const cellValue = (row[filterColName] || '').toLowerCase();
                                        switch (params.operator) {
                                            case '=': return cellValue === parsedValue;
                                            case '!=': return cellValue !== parsedValue;
                                            default: return false;
                                        }
                                    });
                                }
                                analysisContent = `<p class="text-gray-300 mt-2">I found <strong>${filteredData.length} rows</strong> that match your condition where **${filterColName} ${params.operator} "${params.value}"**.</p>
                                                  <p class="text-sm text-gray-400 mt-2">Here's a preview of the first 5 matching entries (remember, all processing is client-side!):</p>
                                                  <div class="code-block mt-2">${filteredData.slice(0, 5).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>`;
                                aiResponseText = `Filtering complete! I've processed your data based on the condition "${filterColName} ${params.operator} "${params.value}"". Here's the summary:`;
                            } else {
                                aiResponseText = `I couldn't filter data. Please ensure you provide a valid column, operator, and value.`;
                            }
                            break;
                        case 'add_column':
                            const addCol1 = findNumericColumn(params.col1);
                            const addCol2 = findNumericColumn(params.col2);

                            if (addCol1 && addCol2 && params.newColumnName && params.mathOperator) {
                                let operatorSymbol = '';
                                switch (params.mathOperator.toLowerCase()) {
                                    case 'plus': operatorSymbol = '+'; break;
                                    case 'minus': operatorSymbol = '-'; break;
                                    case 'times': operatorSymbol = '*'; break;
                                    case 'divided by': operatorSymbol = '/'; break;
                                }

                                if (operatorSymbol) {
                                    rawData = rawData.map(row => {
                                        const val1 = Number(row[addCol1]);
                                        const val2 = Number(row[addCol2]);
                                        let result;

                                        if (!isNaN(val1) && !isNaN(val2) && val1 !== null && val2 !== null) {
                                            if (operatorSymbol === '+') result = val1 + val2;
                                            else if (operatorSymbol === '-') result = val1 - val2;
                                            else if (operatorSymbol === '*') result = val1 * val2;
                                            else if (operatorSymbol === '/') result = val2 !== 0 ? val1 / val2 : 0;
                                        } else {
                                            result = '';
                                        }
                                        return { ...row, [params.newColumnName]: result !== '' ? result.toFixed(2) : '' };
                                    });
                                    schema[params.newColumnName] = 'number';
                                    displaySchema(schema);
                                    aiResponseText = `I've successfully added a new column named "<strong>${params.newColumnName}</strong>" to your dataset. It calculates "${addCol1} ${params.mathOperator} ${addCol2}". Your schema has been updated!`;
                                } else {
                                    aiResponseText = `I couldn't understand the operator "${params.mathOperator}". Please use 'plus', 'minus', 'times', or 'divided by'.`;
                                }
                            } else {
                                aiResponseText = `To add a calculated column, I need a new column name, two valid numeric columns, and a math operator.`;
                            }
                            break;
                        case 'categorize':
                            const catColName = findNumericColumn(params.columnName);
                            if (catColName && params.numBins && params.newColumnName) {
                                const result = categorizeNumericColumn(catColName, params.numBins, params.newColumnName, rawData);
                                aiResponseText = result.message;
                            } else {
                                aiResponseText = `I couldn't categorize. Please specify a numeric column, number of bins, and a new column name.`;
                            }
                            break;
                        case 'remove_duplicates':
                            const result = removeDuplicateRows(rawData);
                            if (result.success) {
                                aiResponseText = `Successfully removed <strong>${result.removedCount} duplicate row(s)</strong> from your dataset. Total rows now: <strong>${rawData.length}</strong>.`;
                            } else {
                                aiResponseText = `An error occurred while trying to remove duplicate rows.`;
                            }
                            break;
                        case 'rename_column':
                            const renameResult = renameColumn(params.oldName, params.newName);
                            aiResponseText = renameResult.message;
                            break;
                        case 'summarize_by':
                            const sumByNumericCol = findNumericColumn(params.numericColumn);
                            const sumByCategoricalCol = findCategoricalColumn(params.categoricalColumn);

                            if (sumByNumericCol && sumByCategoricalCol) {
                                const groupedStats = {};
                                rawData.forEach(row => {
                                    const category = row[sumByCategoricalCol];
                                    const value = Number(row[sumByNumericCol]);

                                    if (!isNaN(value)) {
                                        if (!groupedStats[category]) {
                                            groupedStats[category] = { sum: 0, count: 0, min: Infinity, max: -Infinity };
                                        }
                                        groupedStats[category].sum += value;
                                        groupedStats[category].count++;
                                        if (value < groupedStats[category].min) groupedStats[category].min = value;
                                        if (value > groupedStats[category].max) groupedStats[category].max = value;
                                    }
                                });

                                let resultsHtml = `<p class="text-gray-300">Summary of <strong>${sumByNumericCol}</strong> by <strong>${sumByCategoricalCol}</strong>:</p>
                                                  <ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                for (const category in groupedStats) {
                                    const stats = groupedStats[category];
                                    const avg = (stats.sum / stats.count).toFixed(2);
                                    resultsHtml += `<li><strong>${category}</strong>: <br>
                                                        &nbsp;&nbsp;Entries: ${stats.count}, <br>
                                                        &nbsp;&nbsp;Average ${sumByNumericCol}: ${avg}, <br>
                                                        &nbsp;&nbsp;Min ${sumByNumericCol}: ${stats.min.toFixed(2)}, <br>
                                                        &nbsp;&nbsp;Max ${sumByNumericCol}: ${stats.max.toFixed(2)}
                                                    </li>`;
                                }
                                resultsHtml += `</ul>`;
                                aiResponseText = `Here's a detailed summary:`;
                                analysisContent = resultsHtml;
                            } else {
                                aiResponseText = `To summarize, I need a valid numeric column and a valid categorical column. Please check your column names and types.`;
                            }
                            break;
                        case 'business_overview':
                            let overviewText = `<p class="text-gray-300 leading-relaxed mb-3">Here's a high-level overview of your dataset's key business metrics:</p>`;
                            
                            const numericColumnsOverview = Object.keys(schema).filter(col => schema[col] === 'number');
                            if (numericColumnsOverview.length > 0) {
                                overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Key Numeric Metrics:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                                numericColumnsOverview.forEach(col => {
                                    const stats = getDescriptiveStats(col, rawData);
                                    if (stats) {
                                        overviewText += `<li><strong>${col}</strong>:<br>
                                                            &nbsp;&nbsp;Total Sum: ${stats.sum.toFixed(2)}<br>
                                                            &nbsp;&nbsp;Average: ${stats.mean.toFixed(2)}<br>
                                                            &nbsp;&nbsp;Min: ${stats.min.toFixed(2)}<br>
                                                            &nbsp;&nbsp;Max: ${stats.max.toFixed(2)}
                                                        </li>`;
                                    }
                                });
                                overviewText += `</ul>`;
                            }

                            const stringColumnsOverview = Object.keys(schema).filter(col => schema[col] === 'string');
                            if (stringColumnsOverview.length > 0) {
                                overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Categorical Insights:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                                stringColumnsOverview.forEach(col => {
                                    const values = rawData.map(row => row[col]);
                                    const uniqueCount = new Set(values).size;
                                    const valueCounts = {};
                                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                                    overviewText += `<li><strong>${col}</strong>: ${uniqueCount} unique values. Top 3: ${sortedCounts.slice(0,3).map(item => `${item[0]} (${item[1]} occurrences)`).join(', ')}.</li>`;
                                });
                                overviewText += `</ul>`;
                            }
                            analysisContent = overviewText;
                            aiResponseText = `Here's your overall business overview:`;
                            break;
                        case 'show_bar_chart':
                            const barNumericCol = findNumericColumn(params.numericColumn);
                            const barCategoricalCol = findCategoricalColumn(params.categoricalColumn);
                            if (barNumericCol && barCategoricalCol) {
                                const aggregated = groupByAndAggregate(rawData, barCategoricalCol, barNumericCol, params.aggregateType || 'sum');
                                createChart('bar', `${params.aggregateType === 'average' ? 'Average' : 'Sum'} of ${barNumericCol} by ${barCategoricalCol}`,
                                            aggregated.labels, aggregated.data,
                                            barCategoricalCol, `${params.aggregateType || 'sum'} of ${barNumericCol}`);
                            } else {
                                aiResponseText = `To create that bar chart, I need a valid numeric column and a valid categorical column. Please check your column names.`;
                            }
                            break;
                        case 'show_line_chart':
                            const lineXCol = findColumnByName(params.xColumn);
                            const lineYCol = findNumericColumn(params.yColumn);
                            if (lineXCol && lineYCol) {
                                const labels = rawData.map(row => row[lineXCol]);
                                const data = rawData.map(row => Number(row[lineYCol])).filter(n => !isNaN(n));
                                if (labels.length !== data.length) {
                                    const validPairs = rawData.filter(row => !isNaN(Number(row[lineYCol])));
                                    const newLabels = validPairs.map(row => row[lineXCol]);
                                    createChart('line', `${lineYCol} over ${lineXCol}`, newLabels, data, lineXCol, lineYCol);
                                } else {
                                    createChart('line', `${lineYCol} over ${lineXCol}`, labels, data, lineXCol, lineYCol);
                                }
                            } else {
                                aiResponseText = `To create that line chart, I need a valid X-axis column and a valid numeric Y-axis column.`;
                            }
                            break;
                        case 'show_scatter_plot':
                            const scatterXCol = findNumericColumn(params.xColumn);
                            const scatterYCol = findNumericColumn(params.yColumn);
                            if (scatterXCol && scatterYCol) {
                                const scatterData = rawData.map(row => ({
                                    x: Number(row[scatterXCol]),
                                    y: Number(row[scatterYCol])
                                })).filter(point => !isNaN(point.x) && !isNaN(point.y));

                                createChart('scatter', `${scatterYCol} vs ${scatterXCol}`, [], scatterData, scatterXCol, scatterYCol, {
                                    scales: {
                                        x: { type: 'linear', position: 'bottom' },
                                        y: { type: 'linear' }
                                    }
                                });
                            } else {
                                aiResponseText = `I need two valid numeric columns to create a scatter plot.`;
                            }
                            break;
                        case 'show_pie_chart':
                        case 'show_doughnut_chart':
                        case 'show_polar_area_chart':
                            let chartType = command.replace('show_', '').replace('_chart', ''); // e.g., 'pie', 'doughnut', 'polarArea'
                            let chartLabels, chartData, chartTitle;

                            if (params.numericColumn && params.categoricalColumn) { // Aggregated chart
                                const numericCol = findNumericColumn(params.numericColumn);
                                const categoricalCol = findCategoricalColumn(params.categoricalColumn);
                                if (numericCol && categoricalCol) {
                                    const aggregated = groupByAndAggregate(rawData, categoricalCol, numericCol, params.aggregateType || 'sum');
                                    chartLabels = aggregated.labels;
                                    chartData = aggregated.data;
                                    chartTitle = `${params.aggregateType === 'average' ? 'Average' : 'Sum'} of ${numericCol} by ${categoricalCol}`;
                                } else {
                                    aiResponseText = `For a ${chartType} chart with aggregation, I need a valid numeric column and a valid categorical column.`;
                                    break;
                                }
                            } else if (params.columnName) { // Simple frequency chart
                                const primaryCol = findColumnByName(params.columnName);
                                if (primaryCol) {
                                    const values = rawData.map(row => row[primaryCol]);
                                    const valueCounts = {};
                                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                    chartLabels = Object.keys(valueCounts);
                                    chartData = Object.values(valueCounts);
                                    chartTitle = `Frequency of ${primaryCol}`;
                                } else {
                                    aiResponseText = `I couldn't find the column "<strong>${params.columnName}</strong>" to create that chart.`;
                                    break;
                                }
                            } else {
                                aiResponseText = `I didn't understand the chart command format. Please refer to the command guide.`;
                                break;
                            }
                            createChart(chartType, chartTitle, chartLabels, chartData);
                            return; // Exit here if chart is created, to avoid appending text later
                        case 'perform_regression':
                            const regYCol = findNumericColumn(params.yColumn);
                            const regXCol = findNumericColumn(params.xColumn);

                            if (regXCol && regYCol) {
                                const regressionResults = performLinearRegression(regXCol, regYCol, rawData);
                                if (regressionResults !== null) {
                                    aiResponseText = `**Simple Linear Regression Results** (${regYCol} ~ ${regXCol}):<br>
                                                    - **Slope (Coefficient for ${regXCol})**: <strong>${regressionResults.slope}</strong><br>
                                                    - **Y-intercept**: <strong>${regressionResults.intercept}</strong><br>
                                                    - **R-squared**: <strong>${regressionResults.rSquared}</strong> (This indicates how much of the variation in ${regYCol} can be explained by ${regXCol}. A value closer to 1 is better).`;
                                } else {
                                    aiResponseText = `I couldn't perform linear regression between "<strong>${regYCol}</strong>" and "<strong>${regXCol}</strong>" due to insufficient or invalid numeric data.`;
                                }
                            } else {
                                aiResponseText = `To perform linear regression, I need two valid numeric columns (one for Y, one for X).`;
                            }
                            break;
                        case 'show_proactive_insights':
                            generateProactiveInsights();
                            renderProactiveInsights();
                            proactiveInsightsOverlay.classList.remove('hidden');
                            return; // Exit as overlay handles display
                        case 'show_command_guide':
                            commandGuideOverlay.classList.remove('hidden');
                            commandGuideContent.innerHTML = getCommandListHtml();
                            toggleCommandGuideText.textContent = 'Hide Command Guide';
                            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
                            return; // Exit as overlay handles display
                        case 'unrecognized_command':
                        default:
                            aiResponseText = `I'm sorry, I didn't understand that request. Please try rephrasing, or refer to the <a href="#" onclick="toggleCommandGuideBtn.click(); return false;" class="text-blue-400 hover:text-blue-200 underline">command guide</a>.`;
                            break;
                    }
                    
                    appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');

                } else {
                    aiResponseText = "I couldn't get a clear response from the AI. Please try again.";
                    appendMessage('AI', aiResponseText, 'ai');
                }

            } catch (error) {
                console.error("Error calling LLM:", error);
                aiResponseText = `I'm having trouble processing your request. There might be a network issue or a problem with the API key. Please try again later. Error: ${error.message}`;
                appendMessage('AI', aiResponseText, 'ai');
            } finally {
                // Ensure thinking message is removed even if an error occurs
                if (thinkingMessageDiv) {
                    thinkingMessageDiv.remove();
                }
            }
        }


        // Handle sending messages
        sendMessageBtn.addEventListener('click', () => {
            const query = chatInput.value.trim();
            if (query) {
                appendMessage('You', query, 'user');
                chatInput.value = ''; // Clear input

                if (!isHeaderShrunk) {
                    headerContainer.classList.add('header-shrunk');
                    isHeaderShrunk = true;
                }

                simulateAIResponse(query);
            }
        });

        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessageBtn.click();
            }
        });

        // Event listeners for filter buttons
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'active' class from all filter buttons
                filterButtons.forEach(btn => {
                    btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                });

                // Add 'active' class to the clicked button
                button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');

                const filterType = button.dataset.filter;
                const searchTerm = insightSearchInput.value.trim();
                renderProactiveInsights(filterType, searchTerm);
            });
        });

        // Event listener for search input
        insightSearchInput.addEventListener('input', () => {
            const activeFilterButton = document.querySelector('.filter-btn.bg-blue-600');
            const filterType = activeFilterButton ? activeFilterButton.dataset.filter : 'all'; // Get currently active filter
            const searchTerm = insightSearchInput.value.trim();
            renderProactiveInsights(filterType, searchTerm);
        });

        // Initial setup for command guide toggle button: it will initially show "Show Command Guide"
        toggleCommandGuideText.textContent = 'Show Command Guide';
        toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';

        // Initial setup for file management toggle
        fileManagementChevron.classList.add('rotate-180'); // Starts open
        toggleFileManagementBtn.addEventListener('click', () => {
            // Toggle the 'show' class on the collapsible content
            if (fileManagementSection.classList.contains('show')) {
                fileManagementSection.classList.remove('show');
                fileManagementChevron.classList.remove('rotate-180');
            } else {
                fileManagementSection.classList.add('show');
                fileManagementChevron.classList.add('rotate-180');
            }
        });


        // Initial schema display
        displaySchema(schema);
    </script>
</body>
</html>
