<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoDA: Cognitive Data Assistant Prototype</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter (for body) & Roboto Mono (for code) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js CDN for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Darker, professional gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden; /* Prevent scrollbar from background animation */
            position: relative;
        }

        /* Subtle background animation - Darker bubbles */
        .background-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }

        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.05); /* Very subtle white bubbles */
            border-radius: 50%;
            animation: bubble-flow 20s infinite ease-in-out alternate; /* Slower animation */
            filter: blur(8px); /* More blur */
        }

        .bubble:nth-child(1) { width: 80px; height: 80px; left: 15%; top: 10%; animation-duration: 22s; opacity: 0.05; }
        .bubble:nth-child(2) { width: 120px; height: 120px; left: 35%; top: 80%; animation-duration: 25s; opacity: 0.04; }
        .bubble:nth-child(3) { width: 90px; height: 90px; left: 70%; top: 15%; animation-duration: 19s; opacity: 0.06; }
        .bubble:nth-child(4) { width: 140px; height: 140px; left: 90%; top: 50%; animation-duration: 28s; opacity: 0.03; }
        .bubble:nth-child(5) { width: 70px; height: 70px; left: 5%; top: 60%; animation-duration: 21s; opacity: 0.07; }
        .bubble:nth-child(6) { width: 100px; height: 100px; left: 50%; top: 30%; animation-duration: 23s; opacity: 0.05; }

        @keyframes bubble-flow {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(70px, -70px) scale(1.1); }
            100% { transform: translate(0, 0) scale(1); }
        }

        /* Custom scrollbar for chat and results */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium grey thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Lighter grey on hover */
        }

        /* Animation for new messages */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-message {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Gradient for AI avatar */
        .ai-avatar-gradient {
            background: linear-gradient(45deg, #4299e1, #3182ce); /* Techy blue gradient */
        }

        /* Gradient for Send button */
        .send-button-gradient {
            background: linear-gradient(90deg, #4299e1, #3182ce); /* Techy blue gradient */
            transition: all 0.3s ease-in-out;
        }
        .send-button-gradient:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 15px rgba(66, 153, 225, 0.4);
        }
        .send-button-gradient:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(66, 153, 225, 0.2);
        }

        /* Code block styling - Now just for displaying JSON/raw data if needed, not explanations */
        .code-block {
            background-color: #2d3748; /* Dark code background */
            border-left: 4px solid #4299e1; /* Techy blue left border */
            padding: 1rem;
            border-radius: 0.75rem;
            font-family: 'Roboto Mono', monospace; /* Techy monospace font */
            color: #edf2f7; /* Light text for dark background */
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break words for very long lines */
            overflow-x: auto;
            max-height: 200px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); /* Inner shadow for depth */
        }

        /* Input field focus glow */
        input:focus {
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.6); /* Blue glow */
            border-color: #4299e1;
        }

        /* Chart Canvas Styling */
        .chart-container {
            position: relative;
            height: 300px; /* Fixed height for consistency */
            width: 100%;
            margin-top: 1.5rem;
            background-color: #1a202c; /* Dark background for charts */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: column;
        }
        .chart-container canvas {
            max-height: 100%;
            max-width: 100%;
        }

        /* Table specific styles for the command list */
        .command-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
            text-align: left;
        }
        .command-table th, .command-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #4a5568; /* Slightly lighter border for table rows */
        }
        .command-table th {
            background-color: #2d3748; /* Darker header background */
            font-weight: 600;
            color: #a0aec0; /* Lighter text for headers */
        }
        .command-table tbody tr:hover {
            background-color: #4a5568; /* Hover effect for rows */
        }
        .command-table tbody tr:last-child td {
            border-bottom: none;
        }
    </style>
</head>
<body class="relative bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center min-h-screen">
    <!-- Background Bubbles Animation -->
    <div class="background-bubbles">
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
    </div>

    <div class="relative z-10 flex flex-col md:flex-row bg-gray-900 text-gray-200 rounded-3xl shadow-2xl overflow-hidden w-full max-w-7xl h-[90vh] md:h-[80vh] transform transition-all duration-300 hover:shadow-4xl border border-gray-700">
        <!-- Left Pane: CSV Upload & Data Preview -->
        <div class="w-full md:w-1/3 p-8 flex flex-col border-r border-gray-700 bg-gray-800 rounded-l-3xl shadow-inner-dark overflow-y-auto custom-scrollbar">
            <h2 class="text-4xl font-extrabold text-blue-400 mb-2 text-center tracking-tight">CoDA <span class="text-blue-600">AI</span></h2>
            <p class="text-md text-gray-400 mb-2 text-center italic">Your Private, Conversational Data Analyst</p>
            <p class="text-sm text-gray-500 mb-6 text-center">Founded by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

            <div class="mb-8 border-2 border-dashed border-blue-600 bg-gray-700 rounded-2xl p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-600 transition duration-300 ease-in-out shadow-lg hover:shadow-xl">
                <label for="csvFileInput" class="cursor-pointer text-blue-300 hover:text-blue-100 font-bold text-lg flex flex-col items-center justify-center">
                    <i class="fas fa-cloud-upload-alt text-5xl mb-3 text-blue-500"></i>
                    <span class="block text-xl">Upload CSV File</span>
                    <span class="block text-sm text-gray-400 mt-1">Click or drag & drop</span>
                </label>
                <input type="file" id="csvFileInput" accept=".csv" class="hidden">
                <p id="fileNameDisplay" class="mt-4 text-gray-300 text-base font-medium"></p>
                <p id="uploadStatus" class="mt-2 text-sm font-semibold text-gray-300"></p>
            </div>

            <!-- New Download Button -->
            <button id="downloadCsvBtn" class="send-button-gradient text-white p-4 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-lg font-bold">
                <i class="fas fa-download"></i>
                <span>Download Modified CSV</span>
            </button>


            <h3 class="text-2xl font-bold text-gray-200 mb-4 border-b pb-2 border-gray-600 mt-8">Data Schema</h3>
            <div id="schemaDisplay" class="bg-gray-700 p-5 rounded-2xl flex-grow overflow-y-auto custom-scrollbar text-sm text-gray-300 shadow-lg border border-gray-600">
                <p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>
            </div>
        </div>

        <!-- Right Pane: Conversational Interface & Results -->
        <div class="w-full md:w-2/3 flex flex-col p-8 bg-gray-900 rounded-r-3xl">
            <h2 class="text-4xl font-extrabold text-blue-400 mb-6 text-center tracking-tight">Conversational Analysis</h2>

            <!-- Chat Area -->
            <div id="chatArea" class="flex-grow bg-gray-800 p-6 rounded-2xl overflow-y-auto custom-scrollbar shadow-lg border border-gray-700 mb-6">
                <!-- Chat messages will be appended here -->
                <div class="flex items-start mb-4 fade-in-message">
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">Hello! Welcome to CoDA. Upload your CSV data to begin our private, client-side analysis. I'm ready to collaborate!</p>
                    </div>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="flex items-center space-x-3">
                <input type="text" id="chatInput" placeholder="Ask CoDA a question about your data, e.g., 'Show me the average sales'..." class="flex-grow p-4 border border-gray-600 bg-gray-700 text-gray-200 rounded-full focus:outline-none focus:ring-4 focus:ring-blue-600 shadow-lg text-base transition duration-300 ease-in-out">
                <button id="sendMessageBtn" class="send-button-gradient text-white p-4 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
                    <i class="fas fa-paper-plane text-xl"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        let rawData = []; // Stores the parsed CSV data
        let schema = {}; // Stores the column names and inferred types
        let pendingCleaningSuggestion = null; // Stores details of a pending cleaning action
        let myChart = null; // Holds the Chart.js instance for dynamic updates

        const chatArea = document.getElementById('chatArea');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const csvFileInput = document.getElementById('csvFileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const uploadStatus = document.getElementById('uploadStatus');
        const schemaDisplay = document.getElementById('schemaDisplay');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn'); // New button element

        // Function to parse CSV data
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(header => header.trim().replace(/"/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(value => value.trim().replace(/"/g, ''));
                if (values.length === headers.length) { // Ensure row has correct number of columns
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
            }
            return data;
        }

        // Function to infer schema (basic type inference)
        function inferSchema(data) {
            if (data.length === 0) return {};
            const inferredSchema = {};
            const sampleRow = data[0];

            for (const key in sampleRow) {
                let type = 'string';
                // Very basic type inference: check if all values in column can be parsed as numbers
                const isNumeric = data.every(row => {
                    const value = row[key];
                    return value === '' || !isNaN(Number(value)); // Empty string or parseable as number
                });

                if (isNumeric) {
                    type = 'number';
                }
                inferredSchema[key] = type;
            }
            return inferredSchema;
        }

        // Function to display schema in the UI
        function displaySchema(schema) {
            schemaDisplay.innerHTML = '';
            if (Object.keys(schema).length === 0) {
                schemaDisplay.innerHTML = '<p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>';
                return;
            }
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside space-y-3'; // Added space-y for better spacing
            for (const key in schema) {
                const li = document.createElement('li');
                li.className = 'mb-1 text-gray-300';
                li.innerHTML = `<span class="font-bold text-blue-400">${key}</span>: <span class="text-blue-300 font-medium">${schema[key]}</span>`;
                ul.appendChild(li);
            }
            schemaDisplay.appendChild(ul);
        }

        // Helper function to calculate average of a numeric column
        function calculateColumnAverage(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            const sum = numericValues.reduce((acc, val) => acc + val, 0);
            return sum / numericValues.length;
        }

        // Helper function to calculate sum of a numeric column
        function calculateColumnSum(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            return numericValues.reduce((acc, val) => acc + val, 0);
        }

        // Helper function to find min/max of a numeric column
        function calculateColumnMinMax(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return { min: null, max: null };
            return { min: Math.min(...numericValues), max: Math.max(...numericValues) };
        }

        // Helper to calculate median
        function calculateMedian(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return null;
            const mid = Math.floor(numericValues.length / 2);
            return numericValues.length % 2 === 0 ? (numericValues[mid - 1] + numericValues[mid]) / 2 : numericValues[mid];
        }

        // Helper to calculate standard deviation
        function calculateStandardDeviation(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length < 2) return null;
            const mean = calculateColumnAverage(columnName, data);
            const sumOfSquares = numericValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
            return Math.sqrt(sumOfSquares / (numericValues.length - 1)); // Sample standard deviation
        }

        // Helper to calculate quartiles (Q1, Median, Q3, IQR)
        function calculateQuartiles(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { q1: null, median: null, q3: null, iqr: null };

            const getMedian = arr => {
                const mid = Math.floor(arr.length / 2);
                return arr.length % 2 === 0 ? (arr[mid - 1] + arr[mid]) / 2 : arr[mid];
            };

            const median = getMedian(numericValues);
            const q1 = getMedian(numericValues.slice(0, Math.floor(numericValues.length / 2)));
            const q3 = getMedian(numericValues.slice(Math.ceil(numericValues.length / 2)));
            const iqr = q3 - q1;

            return { q1: q1.toFixed(2), median: median.toFixed(2), q3: q3.toFixed(2), iqr: iqr.toFixed(2) };
        }

        // Helper to calculate Pearson correlation coefficient
        function calculateCorrelation(col1, col2, data) {
            const validData = data.filter(row => !isNaN(Number(row[col1])) && !isNaN(Number(row[col2])));
            if (validData.length < 2) return null; // Need at least two data points

            const xValues = validData.map(row => Number(row[col1]));
            const yValues = validData.map(row => Number(row[col2]));

            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + (x * yValues[i]), 0);
            const sumX2 = xValues.reduce((sum, x) => sum + (x * x), 0);
            const sumY2 = yValues.reduce((sum, y) => sum + (y * y), 0);

            const n = validData.length;

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            if (denominator === 0) return 0; // Avoid division by zero, implies no variance
            return numerator / denominator;
        }

        // Helper to find outliers using IQR method
        function findOutliers(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { outliers: [], lowerBound: null, upperBound: null };

            const { q1, q3, iqr } = calculateQuartiles(columnName, data); // Uses existing function
            if (q1 === null || q3 === null || iqr === null) return { outliers: [], lowerBound: null, upperBound: null };

            const lowerBound = parseFloat(q1) - 1.5 * parseFloat(iqr);
            const upperBound = parseFloat(q3) + 1.5 * parseFloat(iqr);

            const outliers = numericValues.filter(val => val < lowerBound || val > upperBound);

            return { outliers, lowerBound: lowerBound.toFixed(2), upperBound: upperBound.toFixed(2) };
        }

        // Helper to perform simple linear regression
        function performLinearRegression(xCol, yCol, data) {
            const validData = data.filter(row => !isNaN(Number(row[xCol])) && !isNaN(Number(row[yCol])));
            if (validData.length < 2) return null; // Need at least two points for regression

            const xValues = validData.map(row => Number(row[xCol]));
            const yValues = validData.map(row => Number(row[yCol]));

            const n = validData.length;
            const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;
            const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;

            let sumXY = 0;
            let sumX2 = 0;
            let sumY2 = 0; // For R-squared calculation

            for (let i = 0; i < n; i++) {
                sumXY += (xValues[i] - meanX) * (yValues[i] - meanY);
                sumX2 += (xValues[i] - meanX) * (xValues[i] - meanX);
                sumY2 += (yValues[i] - meanY) * (yValues[i] - meanY); // For R-squared
            }

            const slope = sumX2 === 0 ? 0 : sumXY / sumX2; // b1
            const intercept = meanY - slope * meanX; // b0

            // Calculate R-squared
            let ssResidual = 0;
            let ssTotal = 0;
            for (let i = 0; i < n; i++) {
                const yPredicted = slope * xValues[i] + intercept;
                ssResidual += Math.pow(yValues[i] - yPredicted, 2);
                ssTotal += Math.pow(yValues[i] - meanY, 2);
            }
            const rSquared = ssTotal === 0 ? 0 : (1 - (ssResidual / ssTotal));

            return { slope: slope.toFixed(4), intercept: intercept.toFixed(4), rSquared: rSquared.toFixed(4) };
        }

        // Helper for grouping and aggregating data for charts (e.g., for bar charts)
        function groupByAndAggregate(data, groupByColumn, aggregateColumn, aggregateType) {
            const groupedData = {};
            data.forEach(row => {
                const groupKey = row[groupByColumn];
                const value = Number(row[aggregateColumn]);

                if (!isNaN(value)) {
                    if (!groupedData[groupKey]) {
                        groupedData[groupKey] = { sum: 0, count: 0 };
                    }
                    groupedData[groupKey].sum += value;
                    groupedData[groupKey].count++;
                }
            });

            const labels = [];
            const values = [];

            for (const key in groupedData) {
                labels.push(key);
                if (aggregateType === 'average') {
                    values.push(groupedData[key].sum / groupedData[key].count);
                } else { // default to sum
                    values.push(groupedData[key].sum);
                }
            }
            return { labels, data: values };
        }

        // Advanced Feature: Check for missing values and suggest cleaning
        function checkAndSuggestDataCleaning(data, currentSchema) {
            let suggestions = [];
            for (const col in currentSchema) {
                if (currentSchema[col] === 'number') {
                    const missingCount = data.filter(row => row[col] === '' || row[col] === undefined || row[col] === null).length;
                    if (missingCount > 0) {
                        suggestions.push({
                            column: col,
                            type: 'missing_numeric',
                            count: missingCount,
                            action: 'fill_average'
                        });
                    }
                }
            }

            if (suggestions.length > 0) {
                const firstSuggestion = suggestions[0];
                pendingCleaningSuggestion = firstSuggestion;
                appendMessage('AI', `I noticed ${firstSuggestion.count} missing values in the numeric column "<strong>${firstSuggestion.column}</strong>". Would you like me to fill them with the column's average? (Type "yes" to confirm)`, 'ai');
            } else {
                pendingCleaningSuggestion = null;
            }
        }

        // --- Charting Functions ---

        // Helper to get consistent chart colors
        function getChartColors(count) {
            const colors = [
                'rgba(66, 153, 225, 0.8)', // Blue
                'rgba(144, 202, 249, 0.8)', // Light Blue
                'rgba(74, 222, 128, 0.8)', // Green
                'rgba(251, 191, 36, 0.8)', // Yellow
                'rgba(248, 113, 113, 0.8)', // Red
                'rgba(192, 132, 252, 0.8)', // Purple
                'rgba(129, 140, 248, 0.8)', // Indigo
                'rgba(244, 114, 182, 0.8)', // Pink
            ];
            // Cycle through colors if more data points than defined colors
            return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
        }

        // Function to create a chart (now with axis label options)
        function createChart(chartType, chartTitle, labels, data, xAxisLabelText = '', yAxisLabelText = '', options = {}) {
            // Destroy existing chart if it exists
            if (myChart) {
                myChart.destroy();
            }

            const chartCanvas = document.createElement('canvas');
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.appendChild(chartCanvas);

            // Append a temporary message to the chat with the chart container
            const chartMessageDiv = document.createElement('div');
            chartMessageDiv.className = 'flex items-start mb-4 fade-in-message';
            chartMessageDiv.innerHTML = `
                <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md">
                    <p class="leading-relaxed">Here's the **${chartType} chart** for **${chartTitle}**:</p>
                </div>
            `;
            chatArea.appendChild(chartMessageDiv); // Append the AI text bubble
            chatArea.appendChild(chartContainer); // Append the chart below the text bubble
            chatArea.scrollTop = chatArea.scrollHeight; // Scroll to bottom

            const ctx = chartCanvas.getContext('2d');
            myChart = new Chart(ctx, {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: chartTitle, // Use chartTitle for dataset label
                        data: data,
                        backgroundColor: getChartColors(data.length),
                        borderColor: getChartColors(data.length).map(color => color.replace('0.8', '1')), // Opaque borders
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e2e8f0' // Light text for legend on dark background
                            }
                        },
                        title: { // Chart title moved here for consistency
                            display: true,
                            text: chartTitle,
                            color: '#e2e8f0'
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)' // Very subtle grid lines
                            },
                            title: { // X-axis title
                                display: xAxisLabelText !== '',
                                text: xAxisLabelText,
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            },
                            title: { // Y-axis title
                                display: yAxisLabelText !== '',
                                text: yAxisLabelText,
                                color: '#e2e8f0'
                            }
                        }
                    },
                    ...options // Merge custom options
                }
            });
        }

        // Function to get the HTML for the command list table
        function getCommandListHtml() {
            return `I'm ready to help with your data analysis! Here's a quick guide to what I can do:<br><br>
                <table class="command-table">
                    <thead>
                        <tr>
                            <th>Sr. No.</th>
                            <th>Category</th>
                            <th>Command</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>General Overview</td>
                            <td>Show all data</td>
                            <td><code>show all data</code></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>General Overview</td>
                            <td>Show specific column data</td>
                            <td><code>show [column name]</code> (e.g., <code>show City</code>)</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>General Overview</td>
                            <td>Count rows</td>
                            <td><code>count rows</code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>General Overview</td>
                            <td>Describe dataset</td>
                            <td><code>describe my dataset</code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Statistical Analysis</td>
                            <td>Sum a numeric column</td>
                            <td><code>sum [numeric column]</code> (e.g., <code>sum sales</code>)</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Statistical Analysis</td>
                            <td>Average a numeric column</td>
                            <td><code>average [numeric column]</code> (e.g., <code>average age</code>)</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Statistical Analysis</td>
                            <td>Median of a numeric column</td>
                            <td><code>median [numeric column]</code> (e.g., <code>median income</code>)</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>Statistical Analysis</td>
                            <td>Standard deviation of a numeric column</td>
                            <td><code>standard deviation [numeric column]</code> (e.g., <code>standard deviation price</code>)</td>
                        </tr>
                        <tr>
                            <td>9</td>
                            <td>Statistical Analysis</td>
                            <td>Quartiles of a numeric column</td>
                            <td><code>quartiles [numeric column]</code> (e.g., <code>quartiles score</code>)</td>
                        </tr>
                        <tr>
                            <td>10</td>
                            <td>Statistical Analysis</td>
                            <td>Count unique values in a column</td>
                            <td><code>count unique [column name]</code> (e.g., <code>count unique city</code>)</td>
                        </tr>
                        <tr>
                            <td>11</td>
                            <td>Statistical Analysis</td>
                            <td>Show frequency/top values</td>
                            <td><code>show frequency of [column name]</code> or <code>top values in [column name]</code> (e.g., <code>show frequency of product type</code>)</td>
                        </tr>
                        <tr>
                            <td>12</td>
                            <td>Statistical Analysis</td>
                            <td>Min/Max of a numeric column</td>
                            <td><code>min [numeric column]</code> or <code>max [numeric column]</code> (e.g., <code>min temperature</code>)</td>
                        </tr>
                        <tr>
                            <td>13</td>
                            <td>Statistical Analysis</td>
                            <td>Average a numeric column by categorical group</td>
                            <td><code>average [numeric column] by [categorical column]</code> (e.g., <code>average sales by region</code>)</td>
                        </tr>
                        <tr>
                            <td>14</td>
                            <td>Statistical Analysis</td>
                            <td>Correlation between two numeric columns</td>
                            <td><code>show correlation between [numeric_col1] and [numeric_col2]</code> (e.g., <code>show correlation between Age and Income</code>)</td>
                        </tr>
                        <tr>
                            <td>15</td>
                            <td>Statistical Analysis</td>
                            <td>Find outliers in a numeric column</td>
                            <td><code>find outliers in [numeric column]</code> (e.g., <code>find outliers in Sales</code>)</td>
                        </tr>
                        <tr>
                            <td>16</td>
                            <td>Data Manipulation</td>
                            <td>Filter data</td>
                            <td><code>filter data where [column] [operator] [value]</code> (e.g., <code>sales > 1000</code> or <code>city = "London"</code>)</td>
                        </tr>
                        <tr>
                            <td>17</td>
                            <td>Data Manipulation</td>
                            <td>Add a new calculated column</td>
                            <td><code>add column [new_name] as [col1] [operator] [col2]</code> (Operators: 'plus', 'minus', 'times', 'divided by'. E.g., <code>add column profit as revenue minus cost</code>)</td>
                        </tr>
                        <tr>
                            <td>18</td>
                            <td>Data Manipulation</td>
                            <td>Categorize numeric data into bins</td>
                            <td><code>categorize [numeric_col] into [num_bins] bins as [new_col_name]</code> (e.g., <code>categorize Age into 5 bins as Age_Group</code>)</td>
                        </tr>
                        <tr>
                            <td>19</td>
                            <td>Data Manipulation</td>
                            <td>Remove duplicate rows</td>
                            <td><code>remove duplicate rows</code></td>
                        </tr>
                        <tr>
                            <td>20</td>
                            <td>Data Manipulation</td>
                            <td>Rename column</td>
                            <td><code>rename column [old_name] to [new_name]</code> (e.g., <code>rename column Product_ID to SKU</code>)</td>
                        </tr>
                        <tr>
                            <td>21</td>
                            <td>Business Intelligence</td>
                            <td>Summarize numeric by categorical</td>
                            <td><code>summarize [numeric_col] by [categorical_col]</code> (e.g., <code>summarize Sales by Region</code>)</td>
                        </tr>
                        <tr>
                            <td>22</td>
                            <td>Business Intelligence</td>
                            <td>Show overall business overview</td>
                            <td><code>show overall business overview</code></td>
                        </tr>
                        <tr>
                            <td colspan="4" class="text-center font-bold text-blue-300 bg-gray-700">New Feature: Data Export</td>
                        </tr>
                        <tr>
                            <td>23</td>
                            <td>Data Export</td>
                            <td>Download modified dataset</td>
                            <td>Click the "Download Modified CSV" button</td>
                        </tr>
                        <tr>
                            <td>24</td>
                            <td>Charting & Visualization</td>
                            <td>Show Bar Chart</td>
                            <td><code>show bar chart of [numeric_col] by [categorical_col] [as sum/average]</code> (e.g., <code>show bar chart of sales by region as average</code>)</td>
                        </tr>
                        <tr>
                            <td>25</td>
                            <td>Charting & Visualization</td>
                            <td>Show Line Chart</td>
                            <td><code>show line chart with X as [column] and Y as [numeric_column]</code> (e.g., <code>show line chart with X as Date and Y as Stock Price</code>)</td>
                        </tr>
                        <tr>
                            <td>26</td>
                            <td>Charting & Visualization</td>
                            <td>Show Scatter Plot</td>
                            <td><code>show scatter plot with X as [numeric_column1] and Y as [numeric_column2]</code> (e.g., <code>show scatter plot with X as Age and Y as Income</code>)</td>
                        </tr>
                        <tr>
                            <td>27</td>
                            <td>Charting & Visualization</td>
                            <td>Show Pie Chart</td>
                            <td><code>show pie chart of [column]</code> (e.g., <code>show pie chart of Gender</code>) or <code>show pie chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>28</td>
                            <td>Charting & Visualization</td>
                            <td>Show Doughnut Chart</td>
                            <td><code>show doughnut chart of [column]</code> (e.g., <code>show doughnut chart of Region</code>) or <code>show doughnut chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>29</td>
                            <td>Charting & Visualization</td>
                            <td>Show Polar Area Chart</td>
                            <td><code>show polar area chart of [column]</code> (e.g., <code>show polar area chart of Status</code>) or <code>show polar area chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                        </tr>
                        <tr>
                            <td>30</td>
                            <td>Modeling</td>
                            <td>Perform Simple Linear Regression</td>
                            <td><code>perform regression with Y as [numeric_col_y] and X as [numeric_col_x]</code> (e.g., <code>perform regression with Y as Sales and X as Advertising</code>)</td>
                        </tr>
                    </tbody>
                </table>
                <br>
                If I've made a cleaning suggestion, you can simply type <strong>'yes'</strong> to confirm.`;
        }


        // Handle CSV file input change
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                fileNameDisplay.textContent = `File: ${file.name}`;
                uploadStatus.textContent = 'Loading and parsing...';
                uploadStatus.className = 'mt-2 text-base font-semibold text-blue-400 animate-pulse';

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        rawData = parseCSV(e.target.result);
                        schema = inferSchema(rawData);
                        displaySchema(schema);
                        uploadStatus.textContent = `Successfully loaded ${rawData.length} rows.`;
                        uploadStatus.className = 'mt-2 text-base font-semibold text-green-500';

                        appendMessage('AI', `Fantastic! I've successfully loaded your CSV and detected the following schema: <br><div class="code-block">${JSON.stringify(schema, null, 2)}</div><br>`, 'ai');
                        // Append the command list immediately after successful upload
                        appendMessage('AI', getCommandListHtml(), 'ai');

                        // Proactively check for data cleaning needs
                        checkAndSuggestDataCleaning(rawData, schema);

                    } catch (error) {
                        uploadStatus.textContent = `Error parsing CSV: ${error.message}`;
                        uploadStatus.className = 'mt-2 text-base font-semibold text-red-500';
                        appendMessage('AI', 'Oops! There was an error loading your CSV. Please ensure it\'s a valid CSV format with correct delimiters.', 'ai');
                    }
                };
                reader.readAsText(file);
            } else {
                fileNameDisplay.textContent = '';
                uploadStatus.textContent = 'No file selected.';
                uploadStatus.className = 'mt-2 text-base font-semibold text-gray-400';
            }
        });

        // Function to append messages to the chat area
        function appendMessage(sender, text, type = 'user') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex mb-4 ${type === 'user' ? 'justify-end' : 'items-start'} fade-in-message`;

            if (type === 'user') {
                messageDiv.innerHTML = `
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                    <div class="flex-shrink-0 w-10 h-10 bg-gray-500 rounded-full flex items-center justify-center text-white font-bold text-lg ml-4 shadow-md">You</div>
                `;
            } else { // AI message
                messageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                `;
            }
            chatArea.appendChild(messageDiv);
            chatArea.scrollTop = chatArea.scrollHeight; // Scroll to bottom
        }

        // Helper to find a column by name (case-insensitive and partial match)
        function findColumnByName(rawName) {
            const lowerRawName = rawName.toLowerCase();
            for (const col in schema) {
                if (col.toLowerCase().includes(lowerRawName)) {
                    return col;
                }
            }
            return null;
        }

        // Helper to find a numeric column by name
        function findNumericColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'number') {
                return col;
            }
            return null;
        }

        // Helper to find a categorical column by name
        function findCategoricalColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'string') {
                return col;
            }
            return null;
        }

        // Helper for basic descriptive statistics for a numeric column
        function getDescriptiveStats(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return null;

            const sum = numericValues.reduce((a, b) => a + b, 0);
            const mean = sum / numericValues.length;

            const sorted = [...numericValues].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];

            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);

            const sumOfSquares = numericValues.reduce((s, val) => s + Math.pow(val - mean, 2), 0);
            const variance = sumOfSquares / (numericValues.length - 1);
            const stdDev = Math.sqrt(variance);

            return {
                count: numericValues.length,
                mean: mean,
                median: median,
                min: min,
                max: max,
                stdDev: stdDev,
                sum: sum
            };
        }

        // New Feature: Categorize numeric column into bins
        function categorizeNumericColumn(columnName, numBins, newColName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0 || numBins <= 0) return { success: false, message: 'Invalid data or number of bins.' };

            const minVal = Math.min(...numericValues);
            const maxVal = Math.max(...numericValues);
            const binSize = (maxVal - minVal) / numBins;

            if (binSize === 0) { // All values are the same
                rawData = rawData.map(row => ({
                    ...row,
                    [newColName]: `${minVal.toFixed(2)} - ${maxVal.toFixed(2)}`
                }));
                schema[newColName] = 'string';
                displaySchema(schema);
                return { success: true, message: `All values in "${columnName}" are the same. Created a single bin for "${newColName}".` };
            }

            rawData = rawData.map(row => {
                const value = Number(row[columnName]);
                if (isNaN(value)) {
                    return { ...row, [newColName]: 'N/A' };
                }
                let binIndex = Math.floor((value - minVal) / binSize);
                // Ensure the max value falls into the last bin
                if (binIndex === numBins) {
                    binIndex = numBins - 1;
                }

                const binStart = minVal + binIndex * binSize;
                const binEnd = minVal + (binIndex + 1) * binSize;
                return {
                    ...row,
                    [newColName]: `${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`
                };
            });
            schema[newColName] = 'string';
            displaySchema(schema);
            return { success: true, message: `Categorized "<strong>${columnName}</strong>" into <strong>${numBins} bins</strong> and created a new column "<strong>${newColName}</strong>".` };
        }

        // New Feature: Remove duplicate rows
        function removeDuplicateRows(data) {
            const initialLength = data.length;
            const seen = new Set();
            const uniqueData = [];

            data.forEach(row => {
                const rowString = JSON.stringify(row); // Simple serialization for comparison
                if (!seen.has(rowString)) {
                    seen.add(rowString);
                    uniqueData.push(row);
                }
            });
            rawData = uniqueData; // Update global rawData
            const removedCount = initialLength - rawData.length;
            return { success: true, removedCount };
        }

        // New Feature: Rename column
        function renameColumn(oldName, newName) {
            const actualOldName = findColumnByName(oldName);
            if (!actualOldName) {
                return { success: false, message: `Column "<strong>${oldName}</strong>" not found.` };
            }
            if (Object.keys(schema).includes(newName)) {
                return { success: false, message: `Column "<strong>${newName}</strong>" already exists.` };
            }

            rawData = rawData.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === actualOldName) {
                        newRow[newName] = row[key];
                    } else {
                        newRow[key] = row[key];
                    }
                }
                return newRow;
            });

            // Update schema
            const newSchema = {};
            for (const key in schema) {
                if (key === actualOldName) {
                    newSchema[newName] = schema[key];
                } else {
                    newSchema[key] = schema[key];
                }
            }
            schema = newSchema;
            displaySchema(schema);
            return { success: true, message: `Column "<strong>${actualOldName}</strong>" successfully renamed to "<strong>${newName}</strong>".` };
        }

        // Function to download the current rawData as a CSV file
        function downloadCSV() {
            if (rawData.length === 0 || Object.keys(schema).length === 0) {
                appendMessage('AI', 'There is no data loaded to download. Please upload a CSV first!', 'ai');
                return;
            }

            const headers = Object.keys(schema);
            const csvRows = [];

            // Add headers row
            csvRows.push(headers.map(header => `"${header}"`).join(','));

            // Add data rows
            rawData.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header];
                    // Escape double quotes by doubling them, and wrap in quotes if contains comma or double quote
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvRows.push(values.join(','));
            });

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'CoDA_Modified_Data.csv');
            link.style.visibility = 'hidden'; // Hide the link
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link); // Clean up
            URL.revokeObjectURL(url); // Free up memory

            appendMessage('AI', 'Your modified dataset has been downloaded as **CoDA_Modified_Data.csv**!', 'ai');
        }

        // Event listener for the download button
        downloadCsvBtn.addEventListener('click', downloadCSV);


        // Simulated AI response and local execution
        function simulateAIResponse(query) {
            query = query.toLowerCase();
            let aiResponseText = ''; // Initialize as empty, as the command list will be generated on upload now
            let analysisContent = '';

            if (rawData.length === 0) {
                appendMessage('AI', "Please upload a CSV file first before asking questions. I'm ready when you are!", 'ai');
                return;
            }

            // Handle cleaning confirmation
            if (pendingCleaningSuggestion && (query === 'yes' || query.includes('confirm') || query.includes('go ahead'))) {
                const colToClean = pendingCleaningSuggestion.column;
                if (pendingCleaningSuggestion.action === 'fill_average') {
                    const average = calculateColumnAverage(colToClean, rawData);
                    rawData = rawData.map(row => {
                        if (row[colToClean] === '' || isNaN(Number(row[colToClean])) || row[colToClean] === null || row[colToClean] === undefined) {
                            row[colToClean] = average.toFixed(2); // Fill with average, keeping two decimal places
                        }
                        return row;
                    });
                    aiResponseText = `Great! I've successfully filled the ${pendingCleaningSuggestion.count} missing values in the column "<strong>${colToClean}</strong>" with the calculated average of <strong>${average.toFixed(2)}</strong>. Your data has been updated locally and privately.`;
                    pendingCleaningSuggestion = null; // Clear the suggestion after execution
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }

            // --- New Advanced Analytical Features ---

            // Categorize numeric column into bins
            const categorizeMatch = query.match(/categorize\s+([\w\s]+)\s+into\s+(\d+)\s+bins\s+as\s+([\w\s]+)/);
            if (categorizeMatch) {
                const numericColRaw = categorizeMatch[1].trim();
                const numBins = parseInt(categorizeMatch[2]);
                const newColName = categorizeMatch[3].trim();

                const numericColumn = findNumericColumn(numericColRaw);

                if (numericColumn) {
                    const result = categorizeNumericColumn(numericColumn, numBins, newColName, rawData);
                    aiResponseText = result.message;
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${numericColRaw}</strong>" to categorize. Please check the column name and ensure it's numeric.`;
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }

            // Remove duplicate rows
            if (query.includes('remove duplicate rows')) {
                const result = removeDuplicateRows(rawData);
                if (result.success) {
                    aiResponseText = `Successfully removed <strong>${result.removedCount} duplicate row(s)</strong> from your dataset. Total rows now: <strong>${rawData.length}</strong>.`;
                } else {
                    aiResponseText = `An error occurred while trying to remove duplicate rows.`;
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }

            // Rename column
            const renameMatch = query.match(/rename column\s+([\w\s]+)\s+to\s+([\w\s]+)/);
            if (renameMatch) {
                const oldNameRaw = renameMatch[1].trim();
                const newName = renameMatch[2].trim();
                const result = renameColumn(oldNameRaw, newName);
                aiResponseText = result.message;
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }

            // Summarize numeric by categorical
            const summarizeByMatch = query.match(/summarize\s+([\w\s]+)\s+by\s+([\w\s]+)/);
            if (summarizeByMatch) {
                const numericColRaw = summarizeByMatch[1].trim();
                const categoricalColRaw = summarizeByMatch[2].trim();

                const numericColumn = findNumericColumn(numericColRaw);
                const categoricalColumn = findCategoricalColumn(categoricalColRaw);

                if (numericColumn && categoricalColumn) {
                    const groupedStats = {};
                    rawData.forEach(row => {
                        const category = row[categoricalColumn];
                        const value = Number(row[numericColumn]);

                        if (!isNaN(value)) {
                            if (!groupedStats[category]) {
                                groupedStats[category] = { sum: 0, count: 0, min: Infinity, max: -Infinity };
                            }
                            groupedStats[category].sum += value;
                            groupedStats[category].count++;
                            if (value < groupedStats[category].min) groupedStats[category].min = value;
                            if (value > groupedStats[category].max) groupedStats[category].max = value;
                        }
                    });

                    let resultsHtml = `<p class="text-gray-300">Summary of <strong>${numericColumn}</strong> by <strong>${categoricalColumn}</strong>:</p>
                                      <ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                    for (const category in groupedStats) {
                        const stats = groupedStats[category];
                        const avg = (stats.sum / stats.count).toFixed(2);
                        resultsHtml += `<li><strong>${category}</strong>: <br>
                                            &nbsp;&nbsp;Entries: ${stats.count}, <br>
                                            &nbsp;&nbsp;Average ${numericColumn}: ${avg}, <br>
                                            &nbsp;&nbsp;Min ${numericColumn}: ${stats.min.toFixed(2)}, <br>
                                            &nbsp;&nbsp;Max ${numericColumn}: ${stats.max.toFixed(2)}
                                        </li>`;
                    }
                    resultsHtml += `</ul>`;
                    aiResponseText = `Here's a detailed summary:`;
                    analysisContent = resultsHtml;
                } else {
                    aiResponseText = `To summarize, I need a valid numeric column and a valid categorical column. Example: 'summarize Sales by Region'.`;
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            }

            // Show overall business overview
            if (query.includes('show overall business overview') || query.includes('business overview')) {
                let overviewText = `<p class="text-gray-300 leading-relaxed mb-3">Here's a high-level overview of your dataset's key business metrics:</p>`;
                
                const numericColumns = Object.keys(schema).filter(col => schema[col] === 'number');
                if (numericColumns.length > 0) {
                    overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Key Numeric Metrics:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                    numericColumns.forEach(col => {
                        const stats = getDescriptiveStats(col, rawData);
                        if (stats) {
                            overviewText += `<li><strong>${col}</strong>:<br>
                                                &nbsp;&nbsp;Total Sum: ${stats.sum.toFixed(2)}<br>
                                                &nbsp;&nbsp;Average: ${stats.mean.toFixed(2)}<br>
                                                &nbsp;&nbsp;Min: ${stats.min.toFixed(2)}<br>
                                                &nbsp;&nbsp;Max: ${stats.max.toFixed(2)}
                                            </li>`;
                        }
                    });
                    overviewText += `</ul>`;
                }

                const stringColumns = Object.keys(schema).filter(col => schema[col] === 'string');
                if (stringColumns.length > 0) {
                    overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Categorical Insights:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                    stringColumns.forEach(col => {
                        const values = rawData.map(row => row[col]);
                        const uniqueCount = new Set(values).size;
                        const valueCounts = {};
                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                        const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                        overviewText += `<li><strong>${col}</strong>: ${uniqueCount} unique values. Top 3: ${sortedCounts.slice(0,3).map(item => `${item[0]} (${item[1]} occurrences)`).join(', ')}.</li>`;
                    });
                    overviewText += `</ul>`;
                }

                aiResponseText = `Here's your overall business overview:`;
                analysisContent = overviewText;
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            }


            // Calculate Median
            if (query.includes('median ')) {
                const match = query.match(/median\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    let foundColumn = findNumericColumn(colNameRaw);
                    if (foundColumn) {
                        const median = calculateMedian(foundColumn, rawData);
                        if (median !== null) {
                            aiResponseText = `The **median** for the column "<strong>${foundColumn}</strong>" is: <strong>${median.toFixed(2)}</strong>.`;
                        } else {
                            aiResponseText = `I couldn't calculate the median for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                        }
                    } else {
                        aiResponseText = `To find the median, please specify a valid numeric column. Example: 'median age'.`;
                    }
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }
            // Calculate Standard Deviation
            else if (query.includes('standard deviation ')) {
                const match = query.match(/standard deviation\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    let foundColumn = findNumericColumn(colNameRaw);
                    if (foundColumn) {
                        const stdDev = calculateStandardDeviation(foundColumn, rawData);
                        if (stdDev !== null) {
                            aiResponseText = `The **standard deviation** for the column "<strong>${foundColumn}</strong>" is: <strong>${stdDev.toFixed(2)}</strong>.`;
                        } else {
                            aiResponseText = `I couldn't calculate the standard deviation for "<strong>${foundColumn}</strong>" as it contains insufficient numeric data (at least 2 values are needed).`;
                        }
                    } else {
                        aiResponseText = `To find the standard deviation, please specify a valid numeric column. Example: 'standard deviation sales'.`;
                    }
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }
            // Calculate Quartiles
            else if (query.includes('quartiles ')) {
                const match = query.match(/quartiles\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    let foundColumn = findNumericColumn(colNameRaw);
                    if (foundColumn) {
                        const quartiles = calculateQuartiles(foundColumn, rawData);
                        if (quartiles.median !== null) {
                            aiResponseText = `For the column "<strong>${foundColumn}</strong>":<br>
                                            **Q1 (25th percentile)**: <strong>${quartiles.q1}</strong><br>
                                            **Median (50th percentile)**: <strong>${quartiles.median}</strong><br>
                                            **Q3 (75th percentile)**: <strong>${quartiles.q3}</strong><br>
                                            **IQR (Interquartile Range)**: <strong>${quartiles.iqr}</strong>.`;
                        } else {
                            aiResponseText = `I couldn't calculate quartiles for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                        }
                    } else {
                        aiResponseText = `To find quartiles, please specify a valid numeric column. Example: 'quartiles age'.`;
                    }
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }
            // Correlation Analysis
            else if (query.includes('show correlation between')) {
                const match = query.match(/show correlation between\s+([\w\s]+)\s+and\s+([\w\s]+)/);
                if (match && match.length === 3) {
                    const col1Raw = match[1].trim();
                    const col2Raw = match[2].trim();

                    let foundCol1 = findNumericColumn(col1Raw);
                    let foundCol2 = findNumericColumn(col2Raw);

                    if (foundCol1 && foundCol2) {
                        const correlation = calculateCorrelation(foundCol1, foundCol2, rawData);
                        if (correlation !== null) {
                            let interpretation = '';
                            if (correlation >= 0.7) interpretation = 'a **strong positive correlation**';
                            else if (correlation >= 0.3) interpretation = 'a **moderate positive correlation**';
                            else if (correlation > -0.3 && correlation < 0.3) interpretation = 'a **very weak or no linear correlation**';
                            else if (correlation > -0.7) interpretation = 'a **moderate negative correlation**';
                            else interpretation = 'a **strong negative correlation**';

                            aiResponseText = `The **Pearson correlation coefficient** between "<strong>${foundCol1}</strong>" and "<strong>${foundCol2}</strong>" is: <strong>${correlation.toFixed(4)}</strong>. This indicates ${interpretation}.`;
                        } else {
                            aiResponseText = `I couldn't calculate the correlation between "<strong>${foundCol1}</strong>" and "<strong>${foundCol2}</strong>" due to insufficient or invalid numeric data.`;
                        }
                    } else {
                        aiResponseText = `To calculate correlation, I need two valid numeric columns. Example: 'show correlation between Age and Income'.`;
                    }
                } else {
                    aiResponseText = `Please use the format: 'show correlation between [numeric_col1] and [numeric_col2]'.`;
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }
            // Outlier Detection
            else if (query.includes('find outliers in ')) {
                const match = query.match(/find outliers in\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    let foundColumn = findNumericColumn(colNameRaw);
                    if (foundColumn) {
                        const { outliers, lowerBound, upperBound } = findOutliers(foundColumn, rawData);
                        if (outliers.length > 0) {
                            aiResponseText = `I found **${outliers.length} potential outliers** in the column "<strong>${foundColumn}</strong>".<br>
                                            These values fall outside the IQR bounds of <strong>${lowerBound}</strong> and <strong>${upperBound}</strong>.<br>
                                            Outlier values (first 10): <strong>${outliers.slice(0, 10).join(', ')}</strong>.`;
                        } else {
                            aiResponseText = `No significant outliers were detected in the column "<strong>${foundColumn}</strong>" based on the IQR method.`;
                        }
                    } else {
                        aiResponseText = `To find outliers, please specify a valid numeric column. Example: 'find outliers in Sales'.`;
                    }
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }
            // Simple Linear Regression
            else if (query.includes('perform regression with y as') && query.includes('and x as')) {
                const match = query.match(/perform regression with y as\s+([\w\s]+)\s+and x as\s+([\w\s]+)/);
                if (match && match.length === 3) {
                    const yColRaw = match[1].trim();
                    const xColRaw = match[2].trim();

                    let foundXCol = findNumericColumn(xColRaw);
                    let foundYCol = findNumericColumn(yColRaw);

                    if (foundXCol && foundYCol) {
                        const regressionResults = performLinearRegression(foundXCol, foundYCol, rawData);
                        if (regressionResults !== null) {
                            aiResponseText = `**Simple Linear Regression Results** (${foundYCol} ~ ${foundXCol}):<br>
                                            - **Slope (Coefficient for ${foundXCol})**: <strong>${regressionResults.slope}</strong><br>
                                            - **Y-intercept**: <strong>${regressionResults.intercept}</strong><br>
                                            - **R-squared**: <strong>${regressionResults.rSquared}</strong> (This indicates how much of the variation in ${foundYCol} can be explained by ${foundXCol}. A value closer to 1 is better).`;
                        } else {
                            aiResponseText = `I couldn't perform linear regression between "<strong>${foundYCol}</strong>" and "<strong>${foundXCol}</strong>" due to insufficient or invalid numeric data.`;
                        }
                    } else {
                        aiResponseText = `To perform linear regression, I need two valid numeric columns. Please check your column names and types. Example: 'perform regression with Y as Sales and X as Advertising'.`;
                    }
                } else {
                    aiResponseText = `Please use the format: 'perform regression with Y as [numeric_col_y] and X as [numeric_col_x]'.`;
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }
            // Add Calculated Column
            else if (query.includes('add column') && query.includes('as')) {
                const match = query.match(/add column\s+([\w\s]+)\s+as\s+([\w\s]+)\s*(plus|minus|times|divided by)\s+([\w\s]+)/);
                if (match && match.length === 5) {
                    const newColName = match[1].trim().replace(/\s/g, '_'); // Replace spaces for valid key
                    const col1Raw = match[2].trim();
                    const operatorWord = match[3].trim();
                    const col2Raw = match[4].trim();

                    let foundCol1 = findNumericColumn(col1Raw);
                    let foundCol2 = findNumericColumn(col2Raw);

                    if (foundCol1 && foundCol2) {
                        let operator = '';
                        switch (operatorWord) {
                            case 'plus': operator = '+'; break;
                            case 'minus': operator = '-'; break;
                            case 'times': operator = '*'; break;
                            case 'divided by': operator = '/'; break;
                            default: operator = '';
                        }

                        if (operator) {
                            rawData = rawData.map(row => {
                                const val1 = Number(row[foundCol1]);
                                const val2 = Number(row[foundCol2]);
                                let result;

                                if (!isNaN(val1) && !isNaN(val1) && val1 !== null && val2 !== null) { // Check for nulls explicitly as well
                                    if (operator === '+') result = val1 + val2;
                                    else if (operator === '-') result = val1 - val2;
                                    else if (operator === '*') result = val1 * val2;
                                    else if (operator === '/') result = val2 !== 0 ? val1 / val2 : 0; // Handle division by zero
                                } else {
                                    result = ''; // Set to empty string if inputs are not valid numbers
                                }
                                return { ...row, [newColName]: result.toFixed(2) }; // Add new column, format to 2 decimals
                            });
                            schema[newColName] = 'number'; // Add new column to schema
                            displaySchema(schema); // Update schema display

                            aiResponseText = `I've successfully added a new column named "<strong>${newColName}</strong>" to your dataset. It calculates "${foundCol1} ${operatorWord} ${foundCol2}". Your schema has been updated!`;
                        } else {
                            aiResponseText = `I couldn't understand the operator "${operatorWord}". Please use 'plus', 'minus', 'times', or 'divided by'.`;
                        }
                    } else {
                        aiResponseText = `To add a calculated column, I need two valid numeric columns. Please check your column names and types. Example: 'add column Net_Profit as Revenue minus Cost'.`;
                    }
                } else {
                    aiResponseText = `Please use the format: 'add column [new_name] as [col1] [operator] [col2]', where operator is 'plus', 'minus', 'times', or 'divided by'.`;
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }


            // --- Charting Commands ---
            const pieDoughnutPolarMatch = query.match(/show (pie|doughnut|polar area) chart of\s+([\w\s]+)(?:\s+by\s+([\w\s]+))?(\s+as\s+(sum|average))?/);
            if (pieDoughnutPolarMatch) {
                const chartType = pieDoughnutPolarMatch[1];
                const primaryColRaw = pieDoughnutPolarMatch[2].trim();
                const secondaryColRaw = pieDoughnutPolarMatch[3] ? pieDoughnutPolarMatch[3].trim() : null;
                const aggregateType = pieDoughnutPolarMatch[5] ? pieDoughnutPolarMatch[5].toLowerCase() : 'sum';

                let primaryColumn = findColumnByName(primaryColRaw);
                let secondaryColumn = secondaryColRaw ? findColumnByName(secondaryColRaw) : null;

                if (primaryColumn) {
                    let labels, data, chartTitle;

                    if (secondaryColumn && schema[primaryColumn] === 'number') {
                        // Aggregate numeric by categorical
                        const aggregated = groupByAndAggregate(rawData, secondaryColumn, primaryColumn, aggregateType);
                        labels = aggregated.labels;
                        data = aggregated.data;
                        chartTitle = `${aggregateType === 'average' ? 'Average' : 'Sum'} of ${primaryColumn} by ${secondaryColumn}`;
                    } else if (!secondaryColumn) {
                        // Frequency count for a single column
                        const values = rawData.map(row => row[primaryColumn]);
                        const valueCounts = {};
                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                        labels = Object.keys(valueCounts);
                        data = Object.values(valueCounts);
                        chartTitle = `Frequency of ${primaryColumn}`;
                    } else {
                        aiResponseText = `For a ${chartType} chart, if specifying 'by' you need a numeric column for aggregation and a categorical column to group by. Or just provide a single column for frequency.`;
                        appendMessage('AI', aiResponseText, 'ai');
                        return;
                    }

                    createChart(chartType.replace(' ', ''), chartTitle, labels, data); // remove space from 'polar area'
                    aiResponseText = `Here's a **${chartType} chart** for "<strong>${chartTitle}</strong>".`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                } else {
                    aiResponseText = `I couldn't find the column "${primaryColRaw}" to create that chart. Please specify a valid column name.`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }


            // --- Existing Charting Commands ---
            // Bar Chart: show bar chart of [numeric_col] by [categorical_col] (average/sum)
            const barChartMatch = query.match(/show bar chart of\s+([\w\s]+)\s+by\s+([\w\s]+)(\s+as\s+(sum|average))?/);
            if (barChartMatch) {
                const numericColRaw = barChartMatch[1].trim();
                const categoricalColRaw = barChartMatch[2].trim();
                const aggregateType = barChartMatch[4] ? barChartMatch[4].toLowerCase() : 'sum'; // Default to sum

                let numericColumn = findNumericColumn(numericColRaw);
                let categoricalColumn = findCategoricalColumn(categoricalColRaw);

                if (numericColumn && categoricalColumn) {
                    const aggregated = groupByAndAggregate(rawData, categoricalColumn, numericColumn, aggregateType);
                    createChart('bar', `${aggregateType === 'average' ? 'Average' : 'Sum'} of ${numericColumn} by ${categoricalColumn}`,
                                aggregated.labels, aggregated.data,
                                categoricalColumn, `${aggregateType} of ${numericColumn}`);
                    aiResponseText = `Here's a **bar chart** showing the ${aggregateType} of "<strong>${numericColumn}</strong>" for each "<strong>${categoricalColumn}</strong>".`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                } else {
                    aiResponseText = `To create that bar chart, I need a valid numeric column and a valid categorical column. Please check your column names. Example: 'show bar chart of sales by region'`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }
            // Line Chart: show line chart with x as [column] and y as [numeric_column]
            const lineChartMatch = query.match(/show line chart with x as\s+([\w\s]+)\s+and y as\s+([\w\s]+)/);
            if (lineChartMatch) {
                const xColRaw = lineChartMatch[1].trim();
                const yColRaw = lineChartMatch[2].trim();

                let xColumn = findColumnByName(xColRaw);
                let yColumn = findNumericColumn(yColRaw);

                if (xColumn && yColumn) {
                    const labels = rawData.map(row => row[xColumn]);
                    const data = rawData.map(row => Number(row[yColumn])).filter(n => !isNaN(n)); // Filter non-numeric y values
                    if (labels.length !== data.length) { // Ensure same length after filtering
                        const originalLabels = rawData.map(row => row[xColumn]);
                        const validPairs = rawData.filter(row => !isNaN(Number(row[yColumn])));
                        const newLabels = validPairs.map(row => row[xColumn]);
                        createChart('line', `${yColumn} over ${xColumn}`, newLabels, data, xColumn, yColumn);
                    } else {
                        createChart('line', `${yColumn} over ${xColumn}`, labels, data, xColumn, yColumn);
                    }

                    aiResponseText = `Here's a **line chart** showing "<strong>${yColumn}</strong>" as it relates to "<strong>${xColumn}</strong>".`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                } else {
                    aiResponseText = `To create that line chart, I need a valid X-axis column and a valid numeric Y-axis column. Example: 'show line chart with x as date and y as temperature'`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }
            // Scatter Plot: show scatter plot with x as [numeric_column1] and y as [numeric_column2]
            const scatterPlotMatch = query.match(/show scatter plot with x as\s+([\w\s]+)\s+and y as\s+([\w\s]+)/);
            if (scatterPlotMatch) {
                const xColRaw = scatterPlotMatch[1].trim();
                const yColRaw = scatterPlotMatch[2].trim();

                let xColumn = findNumericColumn(xColRaw);
                let yColumn = findNumericColumn(yColRaw);

                if (xColumn && yColumn) {
                    const scatterData = rawData.map(row => ({
                        x: Number(row[xColumn]),
                        y: Number(row[yColumn])
                    })).filter(point => !isNaN(point.x) && !isNaN(point.y));

                    createChart('scatter', `${yColumn} vs ${xColumn}`, [], scatterData, xColumn, yColumn, {
                        scales: {
                            x: { type: 'linear', position: 'bottom' },
                            y: { type: 'linear' }
                        }
                    });
                    aiResponseText = `Here's a **scatter plot** visualizing the relationship between "<strong>${xColumn}</strong>" and "<strong>${yColumn}</strong>".`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                } else {
                    aiResponseText = `I need two valid numeric columns to create a scatter plot. Example: 'show scatter plot with x as age and y as income'`;
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }
            }


            // Handle cleaning confirmation
            if (pendingCleaningSuggestion && (query === 'yes' || query.includes('confirm') || query.includes('go ahead'))) {
                const colToClean = pendingCleaningSuggestion.column;
                if (pendingCleaningSuggestion.action === 'fill_average') {
                    const average = calculateColumnAverage(colToClean, rawData);
                    rawData = rawData.map(row => {
                        if (row[colToClean] === '' || isNaN(Number(row[colToClean])) || row[colToClean] === null || row[colToClean] === undefined) {
                            row[colToClean] = average.toFixed(2); // Fill with average, keeping two decimal places
                        }
                        return row;
                    });
                    aiResponseText = `Great! I've successfully filled the ${pendingCleaningSuggestion.count} missing values in the column "<strong>${colToClean}</strong>" with the calculated average of <strong>${average.toFixed(2)}</strong>. Your data has been updated locally and privately.`;
                    pendingCleaningSuggestion = null; // Clear the suggestion after execution
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            } else if (query.includes('count unique')) {
                let foundColumn = null;
                const match = query.match(/count unique\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    foundColumn = findColumnByName(colNameRaw);
                }

                if (foundColumn) {
                    const values = rawData.map(row => row[foundColumn]);
                    const uniqueCount = new Set(values).size;
                    aiResponseText = `The column "<strong>${foundColumn}</strong>" has **${uniqueCount} unique values**.`;
                } else {
                    aiResponseText = "I couldn't find that column to count unique values. Please specify a valid column name.";
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            } else if (query.includes('show frequency of') || query.includes('top values in')) {
                let foundColumn = null;
                const match = query.match(/(show frequency of|top values in)\s+([\w\s]+)/);
                if (match && match[2]) {
                    const colNameRaw = match[2].trim();
                    foundColumn = findColumnByName(colNameRaw);
                }

                if (foundColumn) {
                    const values = rawData.map(row => row[foundColumn]);
                    const valueCounts = {};
                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                    let frequencyList = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                    sortedCounts.slice(0, 5).forEach(([value, count]) => {
                        const percentage = ((count / values.length) * 100).toFixed(1);
                        frequencyList += `<li>"<strong>${value}</strong>": ${count} occurrences (${percentage}%)</li>`;
                    });
                    frequencyList += `</ul>`;

                    aiResponseText = `Here's the **frequency distribution** for "<strong>${foundColumn}</strong>", showing the top 5 most common values:`;
                    analysisContent = frequencyList;
                } else {
                    aiResponseText = "I couldn't find that column to show its frequency. Please specify a valid column name.";
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('min ') || query.includes('max ')) {
                let foundColumn = null;
                const matchMin = query.match(/min\s+([\w\s]+)/);
                const matchMax = query.match(/max\s+([\w\s]+)/);
                const colNameRaw = matchMin ? matchMin[1].trim() : (matchMax ? matchMax[1].trim() : null);

                if (colNameRaw) {
                    foundColumn = findNumericColumn(colNameRaw);
                }

                if (foundColumn) {
                    const { min, max } = calculateColumnMinMax(foundColumn, rawData);
                    if (min !== null && max !== null) {
                        aiResponseText = `For the numeric column "<strong>${foundColumn}</strong>":<br>The **minimum value** is: <strong>${min}</strong><br>The **maximum value** is: <strong>${max}</strong>.`;
                    } else {
                        aiResponseText = `There are no valid numeric entries in "<strong>${foundColumn}</strong>" to calculate min/max.`;
                    }
                } else {
                    aiResponseText = "I couldn't find a numeric column to calculate min/max for. Please specify a valid numeric column.";
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            } else if (query.includes('how many rows') || query.includes('row count') || query === 'count rows') {
                const numRows = rawData.length;
                aiResponseText = `Your dataset currently contains **${numRows} rows** (records).`;
                appendMessage('AI', aiResponseText, 'ai');
                return;
            } else if (query.includes('average ') && query.includes(' by ')) {
                const match = query.match(/average\s+([\w\s]+)\s+by\s+([\w\s]+)/);
                if (match && match.length === 3) {
                    const numericColRaw = match[1].trim();
                    const categoricalColRaw = match[2].trim();

                    let numericColumn = findNumericColumn(numericColRaw);
                    let categoricalColumn = findCategoricalColumn(categoricalColRaw);

                    if (numericColumn && categoricalColumn) {
                        const groupedAverages = {};
                        const counts = {};

                        rawData.forEach(row => {
                            const category = row[categoricalColumn];
                            const numericValue = Number(row[numericColumn]);

                            if (!isNaN(numericValue)) {
                                if (!groupedAverages[category]) {
                                    groupedAverages[category] = 0;
                                    counts[category] = 0;
                                }
                                groupedAverages[category] += numericValue;
                                counts[category]++;
                            }
                        });

                        let resultsHtml = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                        for (const category in groupedAverages) {
                            const avg = (groupedAverages[category] / counts[category]).toFixed(2);
                            resultsHtml += `<li><strong>${category}</strong>: Average ${numericColumn} is <strong>${avg}</strong> (${counts[category]} entries)</li>`;
                        }
                        resultsHtml += `</ul>`;

                        aiResponseText = `Here's the **average of "${numericColumn}" grouped by "${categoricalColumn}"**:`;
                        analysisContent = resultsHtml;
                    } else {
                        aiResponseText = `I need both a valid numeric column and a valid categorical column to perform that aggregation. Please check your column names and types.`;
                    }
                } else {
                    aiResponseText = `Please rephrase your 'average by' query as: 'average [numeric column] by [categorical column]'.`;
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('sum ')) {
                let foundColumn = null;
                const match = query.match(/sum\s+([\w\s]+)/);
                if (match && match[1]) {
                    const colNameRaw = match[1].trim();
                    foundColumn = findNumericColumn(colNameRaw);
                }
                if (foundColumn) {
                    const sum = calculateColumnSum(foundColumn, rawData);
                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The sum of "${foundColumn}" is: ${sum.toFixed(2)}</p>`;
                    aiResponseText = `Alright, I've calculated the **total sum** for the column "<strong>${foundColumn}</strong>". Here's the result:`;
                } else {
                    aiResponseText = "I couldn't find a **numeric column** to calculate the sum for. Please specify a valid numeric column, like 'sum sales'.";
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('average ') || query.includes('avg ')) {
                let foundColumn = null;
                const match = query.match(/(average|avg)\s+([\w\s]+)/);
                if (match && match[2]) {
                    const colNameRaw = match[2].trim();
                    foundColumn = findNumericColumn(colNameRaw);
                }
                if (foundColumn) {
                    const average = calculateColumnAverage(foundColumn, rawData);
                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The average of "${foundColumn}" is: ${average.toFixed(2)}</p>`;
                    aiResponseText = `Understood! Here's the **average value** for the "<strong>${foundColumn}</strong>" column:`;
                } else {
                    aiResponseText = "I couldn't find a **numeric column** to calculate the average for. Please specify a valid numeric column, like 'average age'.";
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('filter data where') || query.includes('show rows where') || query.includes('find entries where')) {
                const match = query.match(/(filter data where|show rows where|find entries where)\s+([\w\s]+)\s*(<=|>=|<|>|=|!=)\s*([\w\s."']+)/);
                if (match && match.length === 5) {
                    const colNameRaw = match[2].trim();
                    const operator = match[3].trim();
                    let valueRaw = match[4].trim();

                    let foundColumn = findColumnByName(colNameRaw);

                    if (foundColumn) {
                        let filteredData = [];
                        let parsedValue;

                        if (schema[foundColumn] === 'number') {
                            parsedValue = Number(valueRaw.replace(/['"]/g, ''));
                            if (isNaN(parsedValue)) {
                                aiResponseText = `It looks like the value "${valueRaw}" for numeric column "${foundColumn}" isn't a valid number. Please provide a numeric value for filtering.`;
                                appendMessage('AI', aiResponseText, 'ai');
                                return;
                            }
                            filteredData = rawData.filter(row => {
                                const cellValue = Number(row[foundColumn]);
                                if (isNaN(cellValue)) return false;
                                switch (operator) {
                                    case '>': return cellValue > parsedValue;
                                    case '<': return cellValue < parsedValue;
                                    case '>=': return cellValue >= parsedValue;
                                    case '<=': return cellValue <= parsedValue;
                                    case '=': return cellValue === parsedValue;
                                    case '!=': return cellValue !== parsedValue;
                                    default: return false;
                                }
                            });
                        } else {
                            parsedValue = valueRaw.replace(/['']/g, '').toLowerCase();
                            filteredData = rawData.filter(row => {
                                const cellValue = (row[foundColumn] || '').toLowerCase();
                                switch (operator) {
                                    case '=': return cellValue === parsedValue;
                                    case '!=': return cellValue !== parsedValue;
                                    default: return false;
                                }
                            });
                        }

                        analysisContent = `<p class="text-gray-300 mt-2">I found <strong>${filteredData.length} rows</strong> that match your condition where **${foundColumn} ${operator} ${valueRaw}**.</p>
                                          <p class="text-sm text-gray-400 mt-2">Here's a preview of the first 5 matching entries (remember, all processing is client-side!):</p>
                                          <div class="code-block mt-2">${filteredData.slice(0, 5).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>`;
                        aiResponseText = `Filtering complete! I've processed your data based on the condition "${foundColumn} ${operator} ${valueRaw}". Here's the summary:`;
                    } else {
                        aiResponseText = "I couldn't identify the column to filter on. Please specify a valid column from your schema.";
                    }
                } else {
                    aiResponseText = "I need a clearer filter condition. Please use the format: **'filter data where [column] [operator] [value]'**, e.g., 'filter data where sales > 1000' or 'filter data where city = \"London\"'.";
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            }
            else if (query.includes('show all data') || query.includes('display all data')) {
                analysisContent = `<p class="text-gray-300 mt-2">Here's a preview of the **first 10 rows** from your dataset:</p>
                                  <div class="code-block mt-2">${rawData.slice(0, 10).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>
                                  <p class="text-sm text-gray-400 mt-2">You have a total of ${rawData.length} rows. This data is processed entirely on your device!</p>`;
                aiResponseText = `Understood! Here's your data:`;
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('show schema') || query.includes('display schema')) {
                analysisContent = `<p class="text-gray-300 mt-2">Here's the **schema I inferred** from your uploaded data:</p>
                                  <div class="code-block mt-2">${JSON.stringify(schema, null, 2)}</div>`;
                aiResponseText = `Certainly! I've extracted the schema for you. All schema inference happens privately in your browser.`;
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('show') || query.includes('display')) {
                let foundColumn = null;
                const match = query.match(/(show|display)\s+([\w\s]+)/);
                if (match && match[2]) {
                    const colNameRaw = match[2].trim();
                    foundColumn = findColumnByName(colNameRaw);
                }

                if (foundColumn) {
                    const columnValues = rawData.map(row => row[foundColumn]);
                    analysisContent = `<p class="text-gray-300 mt-2">Here are the **first 10 values** from the "<strong>${foundColumn}</strong>" column:</p>
                                      <div class="code-block mt-2">${columnValues.slice(0, 10).join('\n')}</div>
                                      <p class="text-sm text-gray-400 mt-2">There are ${columnValues.length} total values in this column.</p>`;
                    aiResponseText = `Absolutely! Here's the data for column "${foundColumn}", retrieved instantly from your local dataset.`;
                }
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            } else if (query.includes('describe my dataset') || query.includes('summarize data') || query.includes('give me an overview') || query.includes('tell me about my data') || query.includes("what's in my data")) {
                let numRows = rawData.length;
                let numCols = Object.keys(schema).length;
                let descriptionNarrative = `<p class="text-gray-300 leading-relaxed mb-3">Alright, let's take a look at your dataset. It appears you have <strong>${numRows} rows</strong>, which means ${numRows} individual records, and <strong>${numCols} columns</strong>, representing ${numCols} different types of information.</p>
                                            <h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Here's a breakdown of what I found in each column:</h5>
                                            <ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;

                for (const col in schema) {
                    descriptionNarrative += `<li class="font-medium">${col}: (<span class="text-blue-400">${schema[col]}</span> type) `;
                    const values = rawData.map(row => row[col]);

                    if (schema[col] === 'number') {
                        const numericValues = values.map(Number).filter(n => !isNaN(n));
                        const { min: minVal, max: maxVal } = calculateColumnMinMax(col, rawData);
                        const avgVal = calculateColumnAverage(col, rawData);
                        const medianVal = calculateMedian(col, rawData);
                        const stdDevVal = calculateStandardDeviation(col, rawData);
                        const quartiles = calculateQuartiles(col, rawData);

                        if (numericValues.length > 0) {
                            descriptionNarrative += `This column contains numerical data, ranging from <strong>${minVal}</strong> to <strong>${maxVal}</strong>, with an average value of approximately <strong>${avgVal.toFixed(2)}</strong>.`;
                            if (medianVal !== null) descriptionNarrative += ` The median is <strong>${medianVal.toFixed(2)}</strong>.`;
                            if (stdDevVal !== null) descriptionNarrative += ` Standard deviation is <strong>${stdDevVal.toFixed(2)}</strong>.`;
                            if (quartiles.q1 !== null) descriptionNarrative += ` Q1 is <strong>${quartiles.q1}</strong>, Q3 is <strong>${quartiles.q3}</strong>, and the IQR is <strong>${quartiles.iqr}</strong>.`;
                            const correlationWithOtherNumerics = [];
                            for (const otherCol in schema) {
                                if (otherCol !== col && schema[otherCol] === 'number') {
                                    const corr = calculateCorrelation(col, otherCol, rawData);
                                    if (corr !== null && !isNaN(corr)) {
                                        correlationWithOtherNumerics.push(`${otherCol}: ${corr.toFixed(2)}`);
                                    }
                                }
                            }
                            if (correlationWithOtherNumerics.length > 0) {
                                descriptionNarrative += ` It shows correlations with other numeric columns: ${correlationWithOtherNumerics.join(', ')}.`;
                            }
                        } else {
                            descriptionNarrative += `This numeric column currently has no valid numerical entries.`;
                        }
                    } else { // string type
                        const uniqueValues = [...new Set(values)];
                        const valueCounts = {};
                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                        const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                        descriptionNarrative += `This column holds text information. I found <strong>${uniqueValues.length} unique values</strong>. The most frequent entries are: ${sortedCounts.slice(0, 5).map(item => `"${item[0]}" appearing ${item[1]} times`).join(', ')}.`;
                    }
                    descriptionNarrative += `</li>`;
                }
                descriptionNarrative += `</ul>`;

                analysisContent = descriptionNarrative; // Direct use of the narrative HTML
                aiResponseText = `Certainly! Here's a comprehensive overview and description of your dataset, crafted to give you quick insights. This analysis was performed entirely client-side, ensuring your data's privacy.`;
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                return;
            }

            // Fallback for unrecognized commands
            aiResponseText = `I'm sorry, I didn't understand that command. Please refer to the command list above for examples, or try rephrasing your request.`;
            appendMessage('AI', aiResponseText, 'ai');
        }

        // Handle sending messages
        sendMessageBtn.addEventListener('click', () => {
            const query = chatInput.value.trim();
            if (query) {
                appendMessage('You', query, 'user');
                chatInput.value = ''; // Clear input
                simulateAIResponse(query);
            }
        });

        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessageBtn.click();
            }
        });

        // Initial schema display
        displaySchema(schema);
    </script>
</body>
</html>
