<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoDA: Cognitive Data Assistant Prototype</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter (for body) & Roboto Mono (for code) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:400;500;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js CDN for graphing - UPDATED to a specific v4.x version to avoid 'extend' errors from deprecated methods -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        /* Base styles for the body to ensure full screen coverage and a gradient background */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Darker, professional gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
            padding: 0; /* Remove padding to allow app to go truly full screen */
            overflow: hidden; /* Prevent scrollbar from background animation */
            position: relative;
        }

        /* Subtle background animation - Darker bubbles for visual flair */
        .background-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0; /* Ensure bubbles are behind content */
        }

        /* Individual bubble styles and animations */
        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.05); /* Very subtle white bubbles */
            border-radius: 50%;
            animation: bubble-flow 20s infinite alternate ease-in-out; /* Smooth, alternating movement */
        }
        .bubble:nth-child(1) { width: 80px; height: 80px; left: 15%; top: 10%; animation-duration: 22s; opacity: 0.05; }
        .bubble:nth-child(2) { width: 120px; height: 120px; left: 35%; top: 80%; animation-duration: 25s; opacity: 0.04; }
        .bubble:nth-child(3) { width: 90px; height: 90px; left: 70%; top: 15%; animation-duration: 19s; opacity: 0.06; }
        .bubble:nth-child(4) { width: 140px; height: 140px; left: 90%; top: 50%; animation-duration: 28s; opacity: 0.03; }
        .bubble:nth-child(5) { width: 70px; height: 70px; left: 5%; top: 60%; animation-duration: 21s; opacity: 0.07; }
        .bubble:nth-child(6) { width: 100px; height: 100px; left: 50%; top: 30%; animation-duration: 23s; opacity: 0.05; }

        @keyframes bubble-flow {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(70px, -70px) scale(1.1); }
            100% { transform: translate(0, 0) scale(1); }
        }

        /* Custom scrollbar for chat and results for a cleaner look */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium grey thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Lighter grey on hover */
        }

        /* Animation for new messages entering the chat */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-message {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Gradient for AI avatar background */
        .ai-avatar-gradient {
            background: linear-gradient(45deg, #4299e1, #3182ce); /* Techy blue gradient */
        }

        /* Gradient for Send button with interactive hover/active effects */
        .send-button-gradient {
            background: linear-gradient(90deg, #4299e1, #3182ce); /* Techy blue gradient */
            transition: all 0.3s ease-in-out;
        }
        .send-button-gradient:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 15px rgba(66, 153, 225, 0.4);
        }
        .send-button-gradient:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(66, 153, 225, 0.2);
        }

        /* Styling for code blocks (e.g., JSON display) */
        .code-block {
            background-color: #2d3748; /* Dark code background */
            border-left: 4px solid #4299e1; /* Techy blue left border */
            padding: 1rem;
            border-radius: 0.75rem;
            font-family: 'Roboto Mono', monospace; /* Techy monospace font */
            color: #edf2f7; /* Light text for dark background */
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break words for very long lines */
            overflow-x: auto; /* Allow horizontal scrolling for very long lines */
            max-height: 200px; /* Limit height of code blocks */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); /* Inner shadow for depth */
        }

        /* Input field focus glow effect */
        input:focus {
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.6); /* Blue glow */
            border-color: #4299e1;
        }

        /* Chart Canvas Styling */
        .chart-container {
            position: relative;
            height: 300px; /* Fixed height for consistency */
            width: 100%;
            margin-top: 1.5rem;
            background-color: #1a202c; /* Dark background for charts */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center; /* Changed to 'center' for general centering */
        }
        .chart-container canvas {
            max-height: 100%;
            max-width: 100%;
        }

        /* Table specific styles for the command list */
        .command-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
            text-align: left;
        }
        .command-table th, .command-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #4a5568; /* Slightly lighter border for table rows */
        }
        .command-table th {
            background-color: #2d3748; /* Darker header background */
            font-weight: 600;
            color: #a0aec0; /* Lighter text for headers */
        }
        .command-table tbody tr:hover {
            background-color: #4a5568; /* Hover effect for rows */
        }
        .command-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Styles for shrunk header when chat starts */
        .header-shrunk {
            padding-top: 1rem !important; /* Smaller top padding */
            padding-bottom: 0.5rem !important; /* Smaller bottom padding */
        }
        .header-shrunk #mainTitle {
            font-size: 1.5rem !important; /* Smaller title */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #subTitle {
            font-size: 0.875rem !important; /* Smaller subtitle (sm) */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #createdBy {
            font-size: 0.75rem !important; /* Even smaller "Created by" (xs) */
            margin-bottom: 0.5rem !important;
        }
        .header-shrunk #toggleButtons {
            margin-bottom: 0rem !important; /* No bottom margin */
            flex-wrap: wrap; /* Allow wrapping if buttons get too long */
        }
        .header-shrunk #toggleButtons button {
            padding-top: 0.4rem !important;
            padding-bottom: 0.4rem !important;
            font-size: 0.8rem !important;
        }

        /* Loading indicator styles */
        #loadingIndicator {
            display: none; /* Hidden by default */
            background-color: #3182ce;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 9999px; /* Full pill shape */
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            animation: pulse 1.5s infinite;
            margin-top: 0.5rem;
            align-self: center; /* Center horizontally if in a flex column */
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        /* Proactive Insights Card Styling */
        .insight-card {
            background-color: #2d3748; /* Darker background for cards */
            border-radius: 1.5rem; /* More rounded corners */
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4); /* Deeper shadow */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 1px solid #4a5568; /* Subtle border */
        }
        .insight-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }

        .insight-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            color: #90cdf4; /* Light blue for headers */
        }
        .insight-header i {
            font-size: 1.8rem;
            margin-right: 0.8rem;
            color: #4299e1; /* Brighter blue icon */
        }
        .insight-header h4 {
            font-size: 1.3rem; /* Slightly larger heading */
            font-weight: 700; /* Bold heading */
        }

        .insight-message {
            color: #e2e8f0; /* Light text for message */
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .insight-action {
            display: inline-block;
            background-color: #4299e1; /* Blue background for action button */
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(66, 153, 225, 0.3);
        }
        .insight-action:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(66, 153, 225, 0.4);
        }
        .insight-action:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(66, 153, 225, 0.2);
        }

        /* Collapsible content styles for insights and new file management section */
        .collapsible-content {
            max-height: 0; /* Hidden by default */
            overflow: hidden;
            transition: max-height 0.3s ease-out; /* Smooth transition */
        }

        .collapsible-content.show {
            max-height: 500px; /* Adjust as needed for content, allows content to push down */
        }
        /* Rotate chevron icon for collapsed/expanded state */
        .chevron-icon {
            transition: transform 0.3s ease-out;
        }
        .chevron-icon.rotate-180 {
            transform: rotate(180deg);
        }

        /* Custom styles for the data panel and file management to make it blend better */
        #data-panel {
            background-color: #1f2937; /* Slightly lighter than main body gradient start */
            border-right: 1px solid #374151; /* Softer border */
            padding: 2rem; /* Reduced padding for a more compact look */
            box-shadow: none; /* Remove inner shadow for smoother blend */
        }

        /* File Management Section */
        .file-management-section {
            background-color: #2d3748; /* Slightly darker than data panel for contrast */
            padding: 1rem; /* Reduced padding */
            border-radius: 0.75rem; /* Softer corners */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); /* Softer shadow */
            border: 1px solid #4a5568; /* Subtle border */
        }

        .file-management-header {
            font-size: 1.5rem; /* Smaller header font */
            margin-bottom: 0.5rem; /* Reduced margin */
        }

        /* CSV Upload Section */
        .csv-upload-area {
            padding: 1rem; /* Reduced padding */
            border-radius: 0.75rem; /* Softer corners */
            border: 1px dashed #4299e1; /* More prominent, friendly dashed border */
            background-color: #2d3748; /* Darker background for distinction */
            transition: all 0.2s ease-in-out;
        }
        .csv-upload-area:hover {
            border-color: #3182ce; /* Darker blue on hover */
            background-color: #28303d; /* Even darker on hover */
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        .csv-upload-area .upload-icon {
            font-size: 2rem; /* Smaller icon */
            margin-bottom: 0.5rem; /* Reduced margin */
        }
        .csv-upload-area .upload-text {
            font-size: 0.9rem; /* Smaller text */
        }
        .csv-upload-area .upload-subtext {
            font-size: 0.75rem; /* Even smaller subtext */
        }

        /* Download Button specific styling */
        .download-button-blend {
            background: linear-gradient(90deg, #4c566a, #6272a4); /* More muted blue-grey gradient */
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            font-weight: 500; /* Slightly less bold */
            font-size: 0.9rem; /* Smaller font size */
            padding: 0.6rem 1rem; /* Reduced padding */
            border-radius: 0.75rem; /* Softer corners */
        }
        .download-button-blend:hover {
            background: linear-gradient(90deg, #6272a4, #4c566a);
            transform: translateY(-1px) scale(1.01);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        .download-button-blend:active {
            transform: translateY(0) scale(0.99);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Data Overview & Tools Section */
        .data-overview-section {
            padding: 1rem; /* Reduced padding */
            background-color: #2d3748; /* Same as file management for consistency */
            border-radius: 0.75rem; /* Softer corners */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); /* Softer shadow */
            border: 1px solid #4a5568; /* Subtle border */
        }
        .data-overview-section h3 {
            font-size: 1.5rem; /* Smaller header */
            margin-bottom: 0.5rem; /* Reduced margin */
        }
        .data-overview-section h4 {
            font-size: 1rem; /* Smaller sub-header */
            margin-bottom: 0.5rem; /* Reduced margin */
        }
        #schemaDisplay {
            min-height: 100px; /* Reduced min-height */
            padding: 0.75rem; /* Reduced padding */
            font-size: 0.8rem; /* Smaller font size */
            background-color: #1a202c; /* Matches main app background more closely */
            border: 1px solid #374151; /* Softer border */
        }

    </style>
</head>
<body class="relative bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center h-screen w-screen">
    <!-- Background Bubbles Animation -->
    <div class="background-bubbles">
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
    </div>

    <!-- Main container for the application -->
    <div id="main-container" class="relative z-10 flex flex-col md:flex-row bg-gray-900 text-gray-200 rounded-3xl shadow-2xl overflow-hidden w-full h-full transform transition-all duration-300 border border-gray-700">
        <!-- Left Pane: CSV Upload & Data Preview -->
        <div id="data-panel" class="p-8 flex-col border-r bg-gray-800 rounded-l-3xl shadow-inner-dark overflow-y-auto custom-scrollbar hidden md:w-0 md:hidden">
            <h2 class="text-4xl font-extrabold text-blue-400 mb-2 text-center tracking-tight">CoDA <span class="text-blue-600">AI</span></h2>
            <p class="text-md text-gray-400 mb-2 text-center italic">Your Private, Conversational Data Analyst</p>
            <p class="text-sm text-gray-500 mb-6 text-center">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

            <!-- File Management Section -->
            <div class="mb-4 file-management-section">
                <h3 id="fileManagementHeader" class="file-management-header font-bold text-gray-200 pb-2 border-b border-gray-600 flex justify-between items-center cursor-pointer hover:text-blue-300 transition-colors duration-200 ease-in-out">
                    <span><i class="fas fa-file-csv mr-2 text-blue-400"></i> File Management</span>
                    <i class="fas fa-chevron-down text-blue-400 chevron-icon rotate-180"></i>
                </h3>
                <div id="fileManagementContent" class="collapsible-content show">
                    <!-- CSV Upload Section -->
                    <div class="mt-4 csv-upload-area text-center cursor-pointer">
                        <label for="csvFileInput" class="cursor-pointer text-blue-300 hover:text-blue-100 font-bold flex flex-col items-center justify-center">
                            <i class="fas fa-cloud-upload-alt upload-icon mb-2 text-blue-500"></i>
                            <span class="block upload-text">Upload CSV File</span>
                            <span class="block upload-subtext text-gray-400 mt-1">Click or drag & drop</span>
                        </label>
                        <input type="file" id="csvFileInput" accept=".csv" class="hidden">
                        <p id="fileNameDisplay" class="mt-2 text-gray-300 text-sm font-medium"></p>
                        <p id="uploadStatus" class="mt-1 text-xs font-semibold text-gray-300"></p>
                    </div>
                    <!-- Download Button -->
                    <button id="downloadCsvBtn" class="download-button-blend text-white rounded-xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 w-full mt-4">
                        <i class="fas fa-download"></i>
                        <span>Download Modified CSV</span>
                    </button>
                </div>
            </div>

            <!-- Data Overview & Tools Section -->
            <div class="data-overview-section mt-6">
                <h3 class="data-overview-section h3 font-bold text-gray-200 mb-4 border-b pb-2 border-gray-600">
                    <i class="fas fa-database mr-2 text-blue-400"></i> Data Overview & Tools
                </h3>
                <!-- Proactive Insights Button -->
                <button id="showProactiveInsightsBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 w-full mb-6 text-base font-bold">
                    <i class="fas fa-lightbulb"></i>
                    <span>Show Proactive Insights</span>
                </button>
                <!-- Data Schema Display -->
                <h4 class="data-overview-section h4 font-bold text-gray-200 mb-3">Data Schema</h4>
                <div id="schemaDisplay" class="bg-gray-800 p-5 rounded-2xl flex-grow overflow-y-auto custom-scrollbar text-sm text-gray-300 shadow-inner border border-gray-600 min-h-[150px]">
                    <p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>
                </div>
            </div>
        </div>

        <!-- Right Pane: Conversational Interface & Results -->
        <div id="chat-panel" class="w-full flex flex-col bg-gray-900 rounded-3xl">
            <!-- Header Section (will shrink on user interaction) -->
            <div id="headerContainer" class="px-8 pt-6 pb-2 transition-all duration-500 ease-in-out">
                <h2 class="text-4xl font-extrabold text-blue-400 mb-1 text-center tracking-tight" id="mainTitle">CoDA <span class="text-blue-600">AI</span></h2>
                <p class="text-md text-gray-400 mb-1 text-center italic" id="subTitle">Your Private, Conversational Data Analyst</p>
                <p class="text-sm text-gray-500 mb-4 text-center" id="createdBy">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

                <!-- Toggle Buttons for Data Panel and Command Guide -->
                <div class="flex justify-start space-x-3 mb-2" id="toggleButtons">
                    <button id="toggleDataPanelBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out hidden md:flex items-center space-x-2">
                        <i class="fas fa-eye mr-2"></i> <span id="toggleButtonText">Show Data Panel</span>
                    </button>
                    <button id="toggleCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                        <i class="fas fa-book mr-2"></i> <span id="toggleCommandGuideText">Show Command Guide</span>
                    </button>
                </div>
            </div>

            <!-- Chat Area -->
            <div id="chatArea" class="flex-grow bg-gray-800 px-6 py-6 rounded-2xl overflow-y-auto custom-scrollbar shadow-lg border border-gray-700 mx-8">
                <!-- Initial AI message -->
                <div class="flex items-start mb-4 fade-in-message">
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">Hello! Welcome to CoDA. Upload your CSV data to begin our private, client-side analysis. I'm ready to collaborate!</p>
                    </div>
                </div>
            </div>
            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="flex items-center justify-center mt-4">
                <i class="fas fa-spinner fa-spin mr-2"></i> AI is thinking...
            </div>

            <!-- Chat Input Section -->
            <div class="flex items-center space-x-3 px-8 pb-6 pt-4">
                <input type="text" id="chatInput" placeholder="Ask CoDA a question about your data, e.g., 'Show me the average sales'..." class="flex-grow p-4 border border-gray-600 bg-gray-700 text-gray-200 rounded-full focus:outline-none focus:ring-4 focus:ring-blue-600 shadow-lg text-base transition duration-300 ease-in-out">
                <button id="sendMessageBtn" class="send-button-gradient text-white p-4 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
                    <i class="fas fa-paper-plane text-xl"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Command Guide Overlay (hidden by default) -->
    <div id="commandGuideOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-3xl font-extrabold text-blue-400">CoDA AI Command Guide</h3>
            <button id="closeCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Guide</span>
            </button>
        </div>
        <div id="commandGuideContent" class="flex-grow text-gray-200">
            <!-- Command guide content will be inserted here by JS -->
        </div>
    </div>

    <!-- Proactive Insights Overlay (hidden by default) -->
    <div id="proactiveInsightsOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-3xl font-extrabold text-blue-300 flex items-center">
                <i class="fas fa-brain text-blue-500 mr-3 text-4xl"></i>
                <span>CoDA's <span class="text-white">Proactive Insights</span></span>
            </h3>
            <button id="closeProactiveInsightsBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Insights</span>
            </button>
        </div>
        <!-- Search and Filter Controls for Insights -->
        <div class="mb-6 flex flex-wrap items-center gap-4">
            <input type="text" id="insightSearchInput" placeholder="Search insights..." class="flex-grow p-3 border border-gray-600 bg-gray-700 text-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-600 shadow-inner max-w-full md:max-w-xs">
            <div class="flex flex-wrap gap-2">
                <button class="filter-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="all">All</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="anomaly"><i class="fas fa-exclamation-triangle mr-2"></i>Anomaly</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="trend"><i class="fas fa-chart-line mr-2"></i>Trend</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="correlation"><i class="fas fa-link mr-2"></i>Correlation</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="distribution"><i class="fas fa-chart-pie mr-2"></i>Distribution</button>
            </div>
        </div>
        <div id="proactiveInsightsContent" class="flex-grow text-gray-200">
            <!-- Proactive insights content will be inserted here by JS -->
            <p class="text-gray-400 text-center py-4">Upload a CSV file to generate proactive insights.</p>
        </div>
    </div>

    <script>
        // Helper function to simulate typing into chat and submitting a command
        // This function is globally accessible because it's called from onclick attributes in dynamically generated HTML
        function typeIntoChatAndSubmit(command) {
            const chatInput = document.getElementById('chatInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const proactiveInsightsOverlay = document.getElementById('proactiveInsightsOverlay');

            if (chatInput && sendMessageBtn && proactiveInsightsOverlay) {
                chatInput.value = decodeURIComponent(command); // Decode the command here
                sendMessageBtn.click();
                proactiveInsightsOverlay.classList.add('hidden'); // Close the insights overlay after submitting
            } else {
                console.error("One or more essential chat elements not found when trying to type/submit command.");
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            let rawData = []; // Stores the parsed CSV data
            let schema = {}; // Stores the column names and inferred types
            let pendingCleaningSuggestion = null; // Stores details of a pending cleaning action (e.g., missing values)
            let lastProactiveInsights = []; // Stores the last generated proactive insights as an array of objects

            // Get references to DOM elements
            const chatArea = document.getElementById('chatArea');
            const chatInput = document.getElementById('chatInput');
            const sendMessageBtn = document.getElementById('sendMessageBtn');
            const csvFileInput = document.getElementById('csvFileInput');
            const fileNameDisplay = document.getElementById('fileNameDisplay');
            const uploadStatus = document.getElementById('uploadStatus');
            const schemaDisplay = document.getElementById('schemaDisplay');
            const downloadCsvBtn = document.getElementById('downloadCsvBtn');
            const toggleDataPanelBtn = document.getElementById('toggleDataPanelBtn');
            const dataPanel = document.getElementById('data-panel');
            const chatPanel = document.getElementById('chat-panel');
            const toggleButtonText = document.getElementById('toggleButtonText');

            const toggleCommandGuideBtn = document.getElementById('toggleCommandGuideBtn');
            const commandGuideOverlay = document.getElementById('commandGuideOverlay');
            const commandGuideContent = document.getElementById('commandGuideContent');
            const closeCommandGuideBtn = document.getElementById('closeCommandGuideBtn');
            const toggleCommandGuideText = document.getElementById('toggleCommandGuideText');
            const headerContainer = document.getElementById('headerContainer');
            const loadingIndicator = document.getElementById('loadingIndicator');

            // Elements for proactive insights overlay
            const showProactiveInsightsBtn = document.getElementById('showProactiveInsightsBtn');
            const proactiveInsightsOverlay = document.getElementById('proactiveInsightsOverlay');
            const proactiveInsightsContent = document.getElementById('proactiveInsightsContent');
            const closeProactiveInsightsBtn = document.getElementById('closeProactiveInsightsBtn');
            const insightSearchInput = document.getElementById('insightSearchInput');
            const filterButtons = document.querySelectorAll('.filter-btn');

            // Elements for File Management Collapsible
            const fileManagementHeader = document.getElementById('fileManagementHeader');
            const fileManagementContent = document.getElementById('fileManagementContent');
            const fileManagementChevron = fileManagementHeader.querySelector('.chevron-icon');


            let isHeaderShrunk = false; // Flag to track the state of the header (shrunk or not)

            /**
             * Parses CSV text into an array of JavaScript objects.
             * Handles basic comma-separated values and removes surrounding quotes.
             * @param {string} text - The raw CSV string.
             * @returns {Array<Object>} An array of objects, where each object represents a row.
             */
            function parseCSV(text) {
                const lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
                if (lines.length === 0) return [];

                // Use a more robust regex for headers to handle commas within quoted headers
                const headerLine = lines[0];
                const headers = [];
                // Regex to split by comma, but not if the comma is inside double quotes
                const headerMatches = headerLine.match(/(?:[^,"]+|"[^"]*")+/g);
                if (headerMatches) {
                    headerMatches.forEach(match => {
                        // Trim whitespace and remove surrounding double quotes for headers
                        headers.push(match.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
                    });
                } else {
                    console.warn("Could not parse headers. Assuming single column or malformed CSV.");
                    return [];
                }

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const currentLine = lines[i];
                    const values = [];
                    // Regex to split by comma, but not if the comma is inside double quotes
                    const valueMatches = currentLine.match(/(?:[^,"]+|"[^"]*")+/g);

                    if (valueMatches) {
                        valueMatches.forEach(match => {
                            // Trim whitespace and remove surrounding double quotes, handle doubled quotes
                            values.push(match.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
                        });
                    } else {
                        // If no matches, treat as single empty value or skip malformed line
                        console.warn(`Could not parse line ${i + 1}: ${currentLine}`);
                        continue;
                    }

                    if (values.length === headers.length) { // Ensure row has correct number of columns
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index];
                        });
                        data.push(row);
                    } else {
                        console.warn(`Row ${i + 1} has ${values.length} columns, but expected ${headers.length}. Skipping row: ${currentLine}`);
                    }
                }
                return data;
            }


            /**
             * Infers the schema (column names and basic types) from the parsed CSV data.
             * Determines if a column is 'number' or 'string'.
             * @param {Array<Object>} data - The parsed CSV data.
             * @returns {Object} An object mapping column names to their inferred types.
             */
            function inferSchema(data) {
                if (data.length === 0) return {};
                const inferredSchema = {};
                const sampleRow = data[0];

                for (const key in sampleRow) {
                    let type = 'string'; // Default to string
                    // Check if all non-empty values in the column can be parsed as numbers
                    const isNumeric = data.every(row => {
                        const value = row[key];
                        // Consider empty strings, null, or undefined as potentially numeric (missing data)
                        return value === '' || value === null || value === undefined || !isNaN(Number(value));
                    });

                    if (isNumeric) {
                        type = 'number';
                    }
                    inferredSchema[key] = type;
                }
                return inferredSchema;
            }

            /**
             * Displays the inferred schema in the UI.
             * @param {Object} schema - The schema object to display.
             */
            function displaySchema(schema) {
                schemaDisplay.innerHTML = ''; // Clear existing content
                if (Object.keys(schema).length === 0) {
                    schemaDisplay.innerHTML = '<p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>';
                    return;
                }
                const ul = document.createElement('ul');
                ul.className = 'list-disc list-inside space-y-3'; // Tailwind classes for list styling
                for (const key in schema) {
                    const li = document.createElement('li');
                    li.className = 'mb-1 text-gray-300';
                    li.innerHTML = `<span class="font-bold text-blue-400">${key}</span>: <span class="text-blue-300 font-medium">${schema[key]}</span>`;
                    ul.appendChild(li);
                }
                schemaDisplay.appendChild(ul);
            }

            /**
             * Calculates the average of a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {number} The calculated average, or 0 if no valid numeric values.
             */
            function calculateColumnAverage(columnName, data) {
                // Filter out non-numeric values and convert to numbers
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length === 0) return 0;
                const sum = numericValues.reduce((acc, val) => acc + val, 0);
                return sum / numericValues.length;
            }

            /**
             * Calculates the sum of a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {number} The calculated sum, or 0 if no valid numeric values.
             */
            function calculateColumnSum(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length === 0) return 0;
                return numericValues.reduce((acc, val) => acc + val, 0);
            }

            /**
             * Finds the minimum and maximum values in a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {{min: number|null, max: number|null}} Object with min and max, or null if no valid numbers.
             */
            function calculateColumnMinMax(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length === 0) return { min: null, max: null };
                return { min: Math.min(...numericValues), max: Math.max(...numericValues) };
            }

            /**
             * Calculates the median of a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {number|null} The median, or null if no valid numeric values.
             */
            function calculateMedian(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
                if (numericValues.length === 0) return null;
                const mid = Math.floor(numericValues.length / 2);
                return numericValues.length % 2 === 0 ? (numericValues[mid - 1] + numericValues[mid]) / 2 : numericValues[mid];
            }

            /**
             * Calculates the sample standard deviation of a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {number|null} The standard deviation, or null if less than 2 valid numeric values.
             */
            function calculateStandardDeviation(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length < 2) return null;
                const mean = calculateColumnAverage(columnName, data);
                const sumOfSquares = numericValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
                return Math.sqrt(sumOfSquares / (numericValues.length - 1)); // Sample standard deviation
            }

            /**
             * Calculates quartiles (Q1, Median, Q3) and Interquartile Range (IQR) of a numeric column.
             * @param {string} columnName - The name of the column.
             * @param {Array<Object>} data - The dataset.
             * @returns {{q1: string|null, median: string|null, q3: string|null, iqr: string|null}} Quartile values, or null if no valid numeric values.
             */
            function calculateQuartiles(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
                if (numericValues.length === 0) return { q1: null, median: null, q3: null, iqr: null };

                const getMedian = arr => {
                    if (arr.length === 0) return null; // Handle empty array
                    const mid = Math.floor(arr.length / 2);
                    return arr.length % 2 === 0 ? (arr[mid - 1] + arr[mid]) / 2 : arr[mid];
                };

                const median = getMedian(numericValues);
                const q1 = getMedian(numericValues.slice(0, Math.floor(numericValues.length / 2)));
                const q3 = getMedian(numericValues.slice(Math.ceil(numericValues.length / 2)));

                const iqr = (q3 !== null && q1 !== null) ? (q3 - q1) : null;

                return {
                    q1: q1 !== null ? q1.toFixed(2) : null,
                    median: median !== null ? median.toFixed(2) : null,
                    q3: q3 !== null ? q3.toFixed(2) : null,
                    iqr: iqr !== null ? iqr.toFixed(2) : null
                };
            }

            /**
             * Calculates the Pearson correlation coefficient between two numeric columns.
             * @param {string} col1 - Name of the first numeric column.
             * @param {string} col2 - Name of the second numeric column.
             * @param {Array<Object>} data - The dataset.
             * @returns {number|null} The correlation coefficient, or null if insufficient data.
             */
            function calculateCorrelation(col1, col2, data) {
                // Filter for rows where both columns have valid numeric data
                const validData = data.filter(row => !isNaN(Number(row[col1])) && !isNaN(Number(row[col2])));
                if (validData.length < 2) return null; // Need at least two data points for correlation

                const xValues = validData.map(row => Number(row[col1]));
                const yValues = validData.map(row => Number(row[col2]));

                const sumX = xValues.reduce((a, b) => a + b, 0);
                const sumY = yValues.reduce((a, b) => a + b, 0);
                const sumXY = xValues.reduce((sum, x, i) => sum + (x * yValues[i]), 0);
                const sumX2 = xValues.reduce((sum, x) => sum + (x * x), 0);
                const sumY2 = yValues.reduce((sum, y) => sum + (y * y), 0);

                const n = validData.length;

                const numerator = n * sumXY - sumX * sumY;
                const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

                if (denominator === 0) return 0; // Avoid division by zero; implies no variance in at least one variable
                return numerator / denominator;
            }

            /**
             * Finds outliers in a numeric column using the IQR method.
             * @param {string} columnName - The name of the numeric column.
             * @param {Array<Object>} data - The dataset.
             * @returns {{outliers: Array<number>, lowerBound: string|null, upperBound: string|null}} Object containing outliers and bounds.
             */
            function findOutliers(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
                if (numericValues.length === 0) return { outliers: [], lowerBound: null, upperBound: null };

                const { q1, q3, iqr } = calculateQuartiles(columnName, data); // Uses existing function
                if (q1 === null || q3 === null || iqr === null) return { outliers: [], lowerBound: null, upperBound: null };

                const lowerBound = parseFloat(q1) - 1.5 * parseFloat(iqr);
                const upperBound = parseFloat(q3) + 1.5 * parseFloat(iqr);

                const outliers = numericValues.filter(val => val < lowerBound || val > upperBound);

                return { outliers, lowerBound: lowerBound.toFixed(2), upperBound: upperBound.toFixed(2) };
            }

            /**
             * Performs simple linear regression between two numeric columns.
             * @param {string} xCol - The independent variable (X-axis) column name.
             * @param {string} yCol - The dependent variable (Y-axis) column name.
             * @param {Array<Object>} data - The dataset.
             * @returns {{slope: string, intercept: string, rSquared: string}|null} Regression results or null if insufficient data.
             */
            function performLinearRegression(xCol, yCol, data) {
                const validData = data.filter(row => !isNaN(Number(row[xCol])) && !isNaN(Number(row[yCol])));
                if (validData.length < 2) return null; // Need at least two points for regression

                const xValues = validData.map(row => Number(row[xCol]));
                const yValues = validData.map(row => Number(row[yCol]));

                const n = validData.length;
                const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;
                const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;

                let sumXY = 0;
                let sumX2 = 0; // Sum of squares of X values
                let sumY2 = 0; // Sum of squares of Y values (for R-squared)

                for (let i = 0; i < n; i++) {
                    sumXY += (xValues[i] - meanX) * (yValues[i] - meanY);
                    sumX2 += (xValues[i] - meanX) * (xValues[i] - meanX);
                    sumY2 += (yValues[i] - meanY) * (yValues[i] - meanY);
                }

                // Handle division by zero for slope if all X values are the same
                const slope = sumX2 === 0 ? 0 : sumXY / sumX2; // b1
                const intercept = meanY - slope * meanX; // b0

                // Calculate R-squared
                let ssResidual = 0; // Sum of squares of residuals
                let ssTotal = 0; // Total sum of squares

                for (let i = 0; i < n; i++) {
                    const yPredicted = slope * xValues[i] + intercept;
                    ssResidual += Math.pow(yValues[i] - yPredicted, 2);
                    ssTotal += Math.pow(yValues[i] - meanY, 2);
                }
                const rSquared = ssTotal === 0 ? 0 : (1 - (ssResidual / ssTotal)); // If ssTotal is 0, all Y values are same, R-squared is 0

                return { slope: slope.toFixed(4), intercept: intercept.toFixed(4), rSquared: rSquared.toFixed(4) };
            }

            /**
             * Groups data by a categorical column and aggregates a numeric column.
             * @param {Array<Object>} data - The dataset.
             * @param {string} groupByColumn - The categorical column to group by.
             * @param {string} aggregateColumn - The numeric column to aggregate.
             * @param {string} aggregateType - 'sum' or 'average'.
             * @returns {{labels: Array<string>, data: Array<number>}} Aggregated data for charting.
             */
            function groupByAndAggregate(data, groupByColumn, aggregateColumn, aggregateType) {
                const groupedData = {};
                data.forEach(row => {
                    const groupKey = row[groupByColumn];
                    const value = Number(row[aggregateColumn]);

                    if (!isNaN(value)) {
                        if (!groupedData[groupKey]) {
                            groupedData[groupKey] = { sum: 0, count: 0 };
                        }
                        groupedData[groupKey].sum += value;
                        groupedData[groupKey].count++; // Fixed: Changed 'key' to 'groupKey'
                    }
                });

                const labels = [];
                const values = [];

                for (const key in groupedData) {
                    labels.push(key);
                    if (aggregateType === 'average') {
                        values.push(groupedData[key].sum / groupedData[key].count);
                    } else { // default to sum
                        values.push(groupedData[key].sum);
                    }
                }
                return { labels, data: values };
            }

            /**
             * Checks for missing values in numeric columns and suggests cleaning.
             * If missing values are found, it sets `pendingCleaningSuggestion` and appends an AI message.
             * @param {Array<Object>} data - The dataset.
             * @param {Object} currentSchema - The current schema of the dataset.
             */
            function checkAndSuggestDataCleaning(data, currentSchema) {
                let suggestions = [];
                for (const col in currentSchema) {
                    if (currentSchema[col] === 'number') {
                        const missingCount = data.filter(row => row[col] === '' || row[col] === undefined || row[col] === null || isNaN(Number(row[col]))).length;
                        if (missingCount > 0) {
                            suggestions.push({
                                column: col,
                                type: 'missing_numeric',
                                count: missingCount,
                                action: 'fill_average' // Future: could add 'fill_median', 'remove_rows'
                            });
                        }
                    }
                }

                if (suggestions.length > 0) {
                    const firstSuggestion = suggestions[0]; // Just taking the first one for simplicity
                    pendingCleaningSuggestion = firstSuggestion;
                    appendMessage('AI', `I noticed **${firstSuggestion.count} missing or invalid numeric values** in the column "<strong>${firstSuggestion.column}</strong>". Would you like me to fill them with the column's average? (Type "yes" to confirm)`, 'ai');
                } else {
                    pendingCleaningSuggestion = null; // No pending suggestion
                }
            }

            // --- Charting Functions ---

            /**
             * Provides a consistent set of colors for charts, cycling if needed.
             * @param {number} count - The number of data points to generate colors for.
             * @returns {Array<string>} An array of RGBA color strings.
             */
            function getChartColors(count) {
                const colors = [
                    'rgba(66, 153, 225, 0.8)', // Blue
                    'rgba(144, 202, 249, 0.8)', // Light Blue
                    'rgba(74, 222, 128, 0.8)', // Green
                    'rgba(251, 191, 36, 0.8)', // Yellow
                    'rgba(248, 113, 113, 0.8)', // Red
                    'rgba(192, 132, 252, 0.8)', // Purple
                    'rgba(129, 140, 248, 0.8)', // Indigo
                    'rgba(244, 114, 182, 0.8)', // Pink
                ];
                // Cycle through colors if more data points than defined colors
                return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
            }

            /**
             * Creates and displays a Chart.js chart within the chat area.
             * Each chart is created in a new canvas element.
             * @param {string} chartType - Type of chart (e.g., 'bar', 'line', 'scatter', 'pie').
             * @param {string} chartTitle - Title for the chart.
             * @param {Array<string>} labels - Labels for the X-axis or data points.
             * @param {Array<number>|Array<Object>} data - Data for the chart.
             * @param {string} [xAxisLabelText=''] - Optional X-axis label.
             * @param {string} [yAxisLabelText=''] - Optional Y-axis label.
             * @param {Object} [options={}] - Custom Chart.js options to merge.
             */
            function createChart(chartType, chartTitle, labels, data, xAxisLabelText = '', yAxisLabelText = '', options = {}) {
                // Create the AI message that introduces the chart
                const chartMessageDiv = document.createElement('div');
                chartMessageDiv.className = 'flex items-start mb-4 fade-in-message';
                chartMessageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md">
                        <p class="leading-relaxed">Here's the **${chartType} chart** for **${chartTitle}**:</p>
                    </div>
                `;
                chatArea.appendChild(chartMessageDiv); // Append the AI text bubble

                // Create the chart container (div) and the canvas element within it
                const chartCanvas = document.createElement('canvas');
                const chartContainer = document.createElement('div');
                chartContainer.className = 'chart-container'; // This class handles styling and margin
                chartContainer.appendChild(chartCanvas);

                chatArea.appendChild(chartContainer); // Append the chart below the text bubble
                chatArea.scrollTop = chatArea.scrollHeight; // Scroll to the bottom to show the latest chart

                const ctx = chartCanvas.getContext('2d');
                new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            label: chartTitle, // Use chartTitle for dataset label
                            data: data,
                            backgroundColor: getChartColors(data.length),
                            borderColor: getChartColors(data.length).map(color => color.replace('0.8', '1')), // Opaque borders
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, // Allows flexible sizing within container
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e2e8f0' // Light text for legend on dark background
                                }
                            },
                            title: { // Chart title
                                display: true,
                                text: chartTitle,
                                color: '#e2e8f0'
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    color: '#a0aec0' // Light grey ticks
                                },
                                grid: {
                                    color: 'rgba(255,255,255,0.1)' // Very subtle grid lines
                                },
                                title: { // X-axis title
                                    display: xAxisLabelText !== '', // Only display if text is provided
                                    text: xAxisLabelText,
                                    color: '#e2e8f0'
                                }
                            },
                            y: {
                                ticks: {
                                    color: '#a0aec0' // Light grey ticks
                                },
                                grid: {
                                    color: 'rgba(255,255,255,0.1)'
                                },
                                title: { // Y-axis title
                                    display: yAxisLabelText !== '', // Only display if text is provided
                                    text: yAxisLabelText,
                                    color: '#e2e8f0'
                                }
                            }
                        },
                        ...options // Merge custom options provided (e.g., for scatter plot axes)
                    }
                });
            }

            /**
             * Returns the HTML content for the command guide table.
             * @returns {string} HTML string of the command list.
             */
            function getCommandListHtml() {
                return `<p class="leading-relaxed mb-4">I'm ready to help with your data analysis! Here's a quick guide to what I can do:</p>
                    <table class="command-table">
                        <thead>
                            <tr>
                                <th>Sr. No.</th>
                                <th>Category</th>
                                <th>Command</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>General Overview</td>
                                <td>Show all data</td>
                                <td><code>show all data</code></td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>General Overview</td>
                                <td>Show specific column data</td>
                                <td><code>show [column name]</code> (e.g., <code>show City</code>)</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>General Overview</td>
                                <td>Count rows</td>
                                <td><code>count rows</code></td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>General Overview</td>
                                <td>Describe dataset</td>
                                <td><code>describe my dataset</code></td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>General Overview</td>
                                <td>Show schema</td>
                                <td><code>show schema</code></td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>Statistical Analysis</td>
                                <td>Sum a numeric column</td>
                                <td><code>sum [numeric column]</code> (e.g., <code>sum sales</code>)</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>Statistical Analysis</td>
                                <td>Average a numeric column</td>
                                <td><code>average [numeric column]</code> (e.g., <code>average age</code>)</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>Statistical Analysis</td>
                                <td>Median of a numeric column</td>
                                <td><code>median [numeric column]</code> (e.g., <code>median income</code>)</td>
                            </tr>
                            <tr>
                                <td>9</td>
                                <td>Statistical Analysis</td>
                                <td>Standard deviation of a numeric column</td>
                                <td><code>standard deviation [numeric column]</code> (e.g., <code>standard deviation price</code>)</td>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Statistical Analysis</td>
                                <td>Quartiles of a numeric column</td>
                                <td><code>quartiles [numeric column]</code> (e.g., <code>quartiles score</code>)</td>
                            </tr>
                            <tr>
                                <td>11</td>
                                <td>Statistical Analysis</td>
                                <td>Count unique values in a column</td>
                                <td><code>count unique [column name]</code> (e.g., <code>count unique city</code>)</td>
                            </tr>
                            <tr>
                                <td>12</td>
                                <td>Statistical Analysis</td>
                                <td>Show frequency/top values</td>
                                <td><code>show frequency of [column name]</code> or <code>top values in [column name]</code> (e.g., <code>show frequency of product type</code>)</td>
                            </tr>
                            <tr>
                                <td>13</td>
                                <td>Statistical Analysis</td>
                                <td>Min/Max of a numeric column</td>
                                <td><code>min [numeric column]</code> or <code>max [numeric column]</code> (e.g., <code>min temperature</code>)</td>
                            </tr>
                            <tr>
                                <td>14</td>
                                <td>Statistical Analysis</td>
                                <td>Average a numeric column by categorical group</td>
                                <td><code>average [numeric column] by [categorical column]</code> (e.g., <code>average sales by region</code>)</td>
                            </tr>
                            <tr>
                                <td>15</td>
                                <td>Statistical Analysis</td>
                                <td>Correlation between two numeric columns</td>
                                <td><code>show correlation between [numeric_col1] and [numeric_col2]</code> (e.g., <code>show correlation between Age and Income</code>)</td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>Statistical Analysis</td>
                                <td>Find outliers in a numeric column</td>
                                <td><code>find outliers in [numeric column]</code> (e.g., <code>find outliers in Sales</code>)</td>
                            </tr>
                            <tr>
                                <td>17</td>
                                <td>Data Manipulation</td>
                                <td>Filter data</td>
                                <td><code>filter data where [column] [operator] [value]</code> (e.g., <code>sales > 1000</code> or <code>city = "London"</code>)</td>
                            </tr>
                            <tr>
                                <td>18</td>
                                <td>Data Manipulation</td>
                                <td>Add a new calculated column</td>
                                <td><code>add column [new_name] as [col1] [operator] [col2]</code> (Operators: 'plus', 'minus', 'times', 'divided by'. E.g., <code>add column profit as revenue minus cost</code>)</td>
                            </tr>
                            <tr>
                                <td>19</td>
                                <td>Data Manipulation</td>
                                <td>Categorize numeric data into bins</td>
                                <td><code>categorize [numeric_col] into [num_bins] bins as [new_col_name]</code> (e.g., <code>categorize Age into 5 bins as Age_Group</code>)</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Data Manipulation</td>
                                <td>Remove duplicate rows</td>
                                <td><code>remove duplicate rows</code></td>
                            </tr>
                            <tr>
                                <td>21</td>
                                <td>Data Manipulation</td>
                                <td>Rename column</td>
                                <td><code>rename column [old_name] to [new_name]</code> (e.g., <code>rename column Product_ID to SKU</code>)</td>
                            </tr>
                            <tr>
                                <td>22</td>
                                <td>Business Intelligence</td>
                                <td>Summarize numeric by categorical</td>
                                <td><code>summarize [numeric_col] by [categorical_col]</code> (e.g., <code>summarize Sales by Region</code>)</td>
                            </tr>
                            <tr>
                                <td>23</td>
                                <td>Business Intelligence</td>
                                <td>Show overall business overview</td>
                                <td><code>show overall business overview</code></td>
                            </tr>
                            <tr>
                                <td colspan="4" class="text-center font-bold text-blue-300 bg-gray-700">New Feature: Data Export</td>
                            </tr>
                            <tr>
                                <td>24</td>
                                <td>Data Export</td>
                                <td>Download modified dataset</td>
                                <td>Click the "Download Modified CSV" button</td>
                            </tr>
                            <tr>
                                <td>25</td>
                                <td>Charting & Visualization</td>
                                <td>Show Bar Chart</td>
                                <td><code>show bar chart of [numeric_col] by [categorical_col] [as sum/average]</code> (e.g., <code>show bar chart of sales by region as average</code>)</td>
                            </tr>
                            <tr>
                                <td>26</td>
                                <td>Charting & Visualization</td>
                                <td>Show Line Chart</td>
                                <td><code>show line chart with X as [column] and Y as [numeric_column]</code> (e.g., <code>show line chart with X as Date and Y as Stock Price</code>)</td>
                            </tr>
                            <tr>
                                <td>27</td>
                                <td>Charting & Visualization</td>
                                <td>Show Scatter Plot</td>
                                <td><code>show scatter plot with X as [numeric_column1] and [numeric_column2]</code> (e.g., <code>show scatter plot with X as Age and Y as Income</code>)</td>
                            </tr>
                            <tr>
                                <td>28</td>
                                <td>Charting & Visualization</td>
                                <td>Show Pie Chart</td>
                                <td><code>show pie chart of [column]</code> (e.g., <code>show pie chart of Gender</code>) or <code>show pie chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                            </tr>
                            <tr>
                                <td>29</td>
                                <td>Charting & Visualization</td>
                                <td>Show Doughnut Chart</td>
                                <td><code>show doughnut chart of [column]</code> (e.g., <code>show doughnut chart of Region</code>) or <code>show doughnut chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Charting & Visualization</td>
                                <td>Show Polar Area Chart</td>
                                <td><code>show polar area chart of [column]</code> (e.g., <code>show polar area chart of Status</code>) or <code>show polar area chart of [numeric_col] by [categorical_col] [as sum/average]</code></td>
                            </tr>
                            <tr>
                                <td>31</td>
                                <td>Modeling</td>
                                <td>Perform Simple Linear Regression</td>
                                <td><code>perform regression with Y as [numeric_col_y] and X as [numeric_col_x]</code> (e.g., <code>perform regression with Y as Sales and X as Advertising</code>)</td>
                            </tr>
                            <tr>
                                <td colspan="4" class="text-center font-bold text-blue-300 bg-gray-700">New Feature: Proactive Insights</td>
                            </tr>
                            <tr>
                                <td>32</td>
                                <td>Automated Insights</td>
                                <td>Show Proactive Insights</td>
                                <td><code>show proactive insights</code> or <code>what insights do you have?</code></td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="mt-4">If I've made a cleaning suggestion, you can simply type <strong>'yes'</strong> to confirm.</p>`;
            }


            // Handle CSV file input change event
            csvFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    fileNameDisplay.textContent = `File: ${file.name}`;
                    uploadStatus.textContent = 'Loading and parsing...';
                    uploadStatus.className = 'mt-1 text-xs font-semibold text-blue-400 animate-pulse';

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            rawData = parseCSV(e.target.result); // Parse the raw CSV text
                            schema = inferSchema(rawData); // Infer data types
                            displaySchema(schema); // Display the schema in the UI
                            uploadStatus.textContent = `Successfully loaded ${rawData.length} rows.`;
                            uploadStatus.className = 'mt-1 text-xs font-semibold text-green-500';

                            // Proactively check for data cleaning needs and suggest
                            checkAndSuggestDataCleaning(rawData, schema);

                            // Generate and *store* proactive insights, but don't display automatically
                            generateProactiveInsights();

                        } catch (error) {
                            uploadStatus.textContent = `Error parsing CSV: ${error.message}`;
                            uploadStatus.className = 'mt-1 text-xs font-semibold text-red-500';
                            appendMessage('AI', 'Oops! There was an error loading your CSV. Please ensure it\'s a valid CSV format with correct delimiters.', 'ai');
                            console.error("CSV parsing error:", error);
                        }
                    };
                    reader.readAsText(file); // Read the file as text
                } else {
                    fileNameDisplay.textContent = '';
                    uploadStatus.textContent = 'No file selected.';
                    uploadStatus.className = 'mt-1 text-xs font-semibold text-gray-400';
                }
            });

            /**
             * Appends a message to the chat area, styling it as user or AI.
             * @param {string} sender - 'You' or 'AI'.
             * @param {string} text - The message content (can contain HTML).
             * @param {string} type - 'user' or 'ai'.
             */
            function appendMessage(sender, text, type = 'user') {
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex mb-4 ${type === 'user' ? 'justify-end' : 'items-start'} fade-in-message`;

                if (type === 'user') {
                    messageDiv.innerHTML = `
                        <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                            <p class="leading-relaxed">${text}</p>
                        </div>
                    `;
                } else { // AI message
                    messageDiv.innerHTML = `
                        <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                        <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                            <p class="leading-relaxed">${text}</p>
                        </div>
                    `;
                }
                chatArea.appendChild(messageDiv);
                chatArea.scrollTop = chatArea.scrollHeight; // Scroll to the bottom to show the new message
            }

            /**
             * Helper to find a column by name, supporting case-insensitive and partial matching.
             * Prioritizes exact case-insensitive matches.
             * @param {string} rawName - The user-provided column name.
             * @returns {string|null} The actual column name from schema, or null if not found.
             */
            function findColumnByName(rawName) {
                if (!rawName) return null;
                const lowerRawName = rawName.toLowerCase();
                let exactMatch = null;
                let partialMatch = null;

                for (const col in schema) {
                    const lowerCol = col.toLowerCase();
                    if (lowerCol === lowerRawName) {
                        exactMatch = col; // Found exact case-insensitive match
                        break; // Prioritize exact match
                    }
                    if (lowerCol.includes(lowerRawName)) {
                        partialMatch = col; // Found a partial match
                    }
                }
                return exactMatch || partialMatch; // Return exact match if found, else partial
            }

            /**
             * Helper to find a numeric column by name using `findColumnByName`.
             * @param {string} rawName - The user-provided column name.
             * @returns {string|null} The actual numeric column name, or null if not found or not numeric.
             */
            function findNumericColumn(rawName) {
                const col = findColumnByName(rawName);
                if (col && schema[col] === 'number') {
                    return col;
                }
                return null;
            }

            /**
             * Helper to find a categorical (string) column by name using `findColumnByName`.
             * @param {string} rawName - The user-provided column name.
             * @returns {string|null} The actual categorical column name, or null if not found or not string.
             */
            function findCategoricalColumn(rawName) {
                const col = findColumnByName(rawName);
                if (col && schema[col] === 'string') {
                    return col;
                }
                return null;
            }

            /**
             * Generates basic descriptive statistics for a given numeric column.
             * @param {string} columnName - The name of the numeric column.
             * @param {Array<Object>} data - The dataset.
             * @returns {Object|null} An object with statistics, or null if no valid data.
             */
            function getDescriptiveStats(columnName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length === 0) return null;

                const sum = numericValues.reduce((a, b) => a + b, 0);
                const mean = sum / numericValues.length;

                const sorted = [...numericValues].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];

                const min = Math.min(...numericValues);
                const max = Math.max(...numericValues);

                const sumOfSquares = numericValues.reduce((s, val) => s + Math.pow(val - mean, 2), 0);
                // Ensure length - 1 is not zero for std dev, handle cases with less than 2 data points
                const variance = numericValues.length > 1 ? sumOfSquares / (numericValues.length - 1) : 0;
                const stdDev = Math.sqrt(variance);

                return {
                    count: numericValues.length,
                    mean: mean,
                    median: median,
                    min: min,
                    max: max,
                    stdDev: stdDev,
                    sum: sum
                };
            }

            /**
             * Categorizes a numeric column into a specified number of bins.
             * Updates the `rawData` and `schema` globally.
             * @param {string} columnName - The numeric column to categorize.
             * @param {number} numBins - The number of bins to create.
             * @param {string} newColName - The name for the new categorical column.
             * @param {Array<Object>} data - The dataset.
             * @returns {{success: boolean, message: string}} Result of the operation.
             */
            function categorizeNumericColumn(columnName, numBins, newColName, data) {
                const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
                if (numericValues.length === 0 || numBins <= 0) {
                    return { success: false, message: 'Invalid data or number of bins.' };
                }

                const minVal = Math.min(...numericValues);
                const maxVal = Math.max(...numericValues);
                const binSize = (maxVal - minVal) / numBins;

                // Handle case where all values are the same (binSize would be 0)
                if (binSize === 0) {
                    rawData = rawData.map(row => ({
                        ...row,
                        [newColName]: `${minVal.toFixed(2)} - ${maxVal.toFixed(2)}`
                    }));
                    schema[newColName] = 'string';
                    displaySchema(schema);
                    return { success: true, message: `All values in "${columnName}" are the same. Created a single bin for "${newColName}".` };
                }

                rawData = rawData.map(row => {
                    const value = Number(row[columnName]);
                    if (isNaN(value)) {
                        return { ...row, [newColName]: 'N/A' }; // Assign 'N/A' for non-numeric or missing values
                    }
                    let binIndex = Math.floor((value - minVal) / binSize);
                    // Ensure the maximum value correctly falls into the last bin
                    if (binIndex >= numBins) {
                        binIndex = numBins - 1;
                    }

                    const binStart = minVal + binIndex * binSize;
                    const binEnd = minVal + (binIndex + 1) * binSize;
                    return {
                        ...row,
                        [newColName]: `${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`
                    };
                });
                schema[newColName] = 'string'; // The new column is categorical
                displaySchema(schema);
                return { success: true, message: `Categorized "<strong>${columnName}</strong>" into <strong>${numBins} bins</strong> and created a new column "<strong>${newColName}</strong>".` };
            }

            /**
             * Removes duplicate rows from the dataset.
             * Updates the `rawData` globally.
             * @param {Array<Object>} data - The dataset.
             * @returns {{success: boolean, removedCount: number}} Result of the operation.
             */
            function removeDuplicateRows(data) {
                const initialLength = data.length;
                const seen = new Set();
                const uniqueData = [];

                data.forEach(row => {
                    // Simple serialization for comparison; might be slow for very large datasets
                    const rowString = JSON.stringify(row);
                    if (!seen.has(rowString)) {
                        seen.add(rowString);
                        uniqueData.push(row);
                    }
                });
                rawData = uniqueData; // Update global rawData
                const removedCount = initialLength - rawData.length;
                return { success: true, removedCount };
            }

            /**
             * Renames a column in the dataset and updates the schema.
             * Updates `rawData` and `schema` globally.
             * @param {string} oldName - The current name of the column.
             * @param {string} newName - The new name for the column.
             * @returns {{success: boolean, message: string}} Result of the operation.
             */
            function renameColumn(oldName, newName) {
                const actualOldName = findColumnByName(oldName); // Use findColumnByName for flexibility
                if (!actualOldName) {
                    return { success: false, message: `Column "<strong>${oldName}</strong>" not found.` };
                }
                // Check if the new name already exists (case-insensitive)
                const newNameExists = Object.keys(schema).some(col => col.toLowerCase() === newName.toLowerCase());
                if (newNameExists) {
                    return { success: false, message: `Column "<strong>${newName}</strong>" already exists (case-insensitive match). Please choose a different name.` };
                }

                rawData = rawData.map(row => {
                    const newRow = {};
                    for (const key in row) {
                        if (key === actualOldName) {
                            newRow[newName] = row[key];
                        } else {
                            newRow[key] = row[key];
                        }
                    }
                    return newRow;
                });

                // Update schema
                const newSchema = {};
                for (const key in schema) {
                    if (key === actualOldName) {
                        newSchema[newName] = schema[key];
                    } else {
                        newSchema[key] = schema[key];
                    }
                }
                schema = newSchema;
                displaySchema(schema);
                return { success: true, message: `Column "<strong>${actualOldName}</strong>" successfully renamed to "<strong>${newName}</strong>".` };
            }

            /**
             * Downloads the current `rawData` as a CSV file.
             */
            function downloadCSV() {
                if (rawData.length === 0 || Object.keys(schema).length === 0) {
                    appendMessage('AI', 'There is no data loaded to download. Please upload a CSV first!', 'ai');
                    return;
                }

                const headers = Object.keys(schema);
                const csvRows = [];

                // Add headers row, ensuring they are quoted and escaped if necessary
                csvRows.push(headers.map(header => `"${header.replace(/"/g, '""')}"`).join(','));

                // Add data rows, ensuring values are quoted and escaped if necessary
                rawData.forEach(row => {
                    const values = headers.map(header => {
                        const value = row[header];
                        // Handle null/undefined values
                        if (value === null || value === undefined) {
                            return '';
                        }
                        const stringValue = String(value);
                        // Escape double quotes by doubling them, and wrap in quotes if contains comma, double quote, or newline
                        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                            return `"${stringValue.replace(/"/g, '""')}"`;
                        }
                        return stringValue;
                    });
                    csvRows.push(values.join(','));
                });

                const csvString = csvRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'CoDA_Modified_Data.csv');
                link.style.visibility = 'hidden'; // Hide the link
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link); // Clean up the created link
                URL.revokeObjectURL(url); // Free up memory

                appendMessage('AI', 'Your modified dataset has been downloaded as **CoDA_Modified_Data.csv**!', 'ai');
            }

            // Event listener for the download button
            downloadCsvBtn.addEventListener('click', downloadCSV);

            // --- Data Panel Toggle Logic ---
            // Initial setup for data panel: ensure it starts hidden and button reflects this
            dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden'); // Start hidden and collapsed on medium screens and up
            chatPanel.classList.remove('md:w-2/3'); // Ensure chat panel takes full width initially on md+
            chatPanel.classList.add('md:w-full');
            toggleButtonText.textContent = 'Show Data Panel';
            toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2'; // Eye icon for "show"

            toggleDataPanelBtn.addEventListener('click', () => {
                const isCurrentlyHidden = dataPanel.classList.contains('hidden'); // Check current visibility

                if (isCurrentlyHidden) {
                    // Show data panel
                    dataPanel.classList.remove('hidden', 'md:w-0', 'md:hidden');
                    dataPanel.classList.add('flex', 'md:w-1/3'); // Show and take 1/3 width
                    chatPanel.classList.remove('md:w-full');
                    chatPanel.classList.add('md:w-2/3'); // Chat panel takes 2/3 width
                    toggleButtonText.textContent = 'Hide Data Panel';
                    toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye-slash mr-2'; // Eye-slash icon for "hide"
                } else {
                    // Hide data panel
                    dataPanel.classList.remove('flex', 'md:w-1/3');
                    dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden'); // Hide and collapse
                    chatPanel.classList.remove('md:w-2/3');
                    chatPanel.classList.add('md:w-full'); // Chat panel takes full width
                    toggleButtonText.textContent = 'Show Data Panel';
                    toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2'; // Eye icon for "show"
                }
            });

            // Event listener for the toggle command guide button
            toggleCommandGuideBtn.addEventListener('click', () => {
                commandGuideOverlay.classList.remove('hidden'); // Show the overlay
                commandGuideContent.innerHTML = getCommandListHtml(); // Populate the content
                // Update the text/icon of the toggle button itself to reflect it's "hiding" the guide
                toggleCommandGuideText.textContent = 'Hide Command Guide';
                toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
            });

            // Event listener for the close button INSIDE the command guide overlay
            closeCommandGuideBtn.addEventListener('click', () => {
                commandGuideOverlay.classList.add('hidden'); // Hide the overlay
                // Reset the toggle button's text/icon
                toggleCommandGuideText.textContent = 'Show Command Guide';
                toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';
            });

            // Event listener for the new "Show Proactive Insights" button
            showProactiveInsightsBtn.addEventListener('click', () => {
                generateProactiveInsights(); // Re-generate insights
                renderProactiveInsights(); // Then render them with current filters (default 'all', no search)
                proactiveInsightsOverlay.classList.remove('hidden'); // Show the overlay
            });

            // Event listener for the close button INSIDE the proactive insights overlay
            closeProactiveInsightsBtn.addEventListener('click', () => {
                proactiveInsightsOverlay.classList.add('hidden'); // Hide the overlay
            });

            /**
             * Shows the loading indicator, ensuring it's visible and scrolls the chat to bottom.
             */
            function showLoadingIndicator() {
                loadingIndicator.style.display = 'flex';
                chatArea.scrollTop = chatArea.scrollHeight; // Scroll to bottom to show it
            }

            /**
             * Hides the loading indicator.
             */
            function hideLoadingIndicator() {
                loadingIndicator.style.display = 'none';
            }

            /**
             * Helper function to parse dates. Handles common formats.
             * @param {string} dateString - The string representation of a date.
             * @returns {Date | null} Parsed Date object or null if invalid.
             */
            function parseDate(dateString) {
                if (!dateString) return null;
                try {
                    // Attempt to parse standard ISO, "YYYY-MM-DD", "MM/DD/YYYY", etc.
                    const d1 = new Date(dateString);

                    // If d1 is invalid, try specific common non-standard formats
                    if (isNaN(d1.getTime())) {
                        // Example: "DD/MM/YYYY"
                        let parts = dateString.match(/^(\d{1,2})[/\-](\d{1,2})[/\-](\d{4})$/);
                        if (parts) {
                            // Reorder to ISO-MM-DD for reliable Date constructor
                            const d = new Date(`${parts[3]}-${parts[2].padStart(2, '0')}-${parts[1].padStart(2, '0')}`);
                            return isNaN(d.getTime()) ? null : d;
                        }
                        // Example: "YYYY/MM/DD"
                        parts = dateString.match(/^(\d{4})[/\-](\d{1,2})[/\-](\d{1,2})$/);
                        if (parts) {
                            const d = new Date(`${parts[1]}-${parts[2].padStart(2, '0')}-${parts[3].padStart(2, '0')}`);
                            return isNaN(d.getTime()) ? null : d;
                        }
                    }
                    return isNaN(d1.getTime()) ? null : d1;
                } catch (e) {
                    console.warn(`Could not parse date string "${dateString}":`, e);
                    return null;
                }
            }

            /**
             * Checks if a column name is likely a meaningful numeric metric (e.g., Sales, Profit).
             * Used for generating more relevant proactive insights.
             * @param {string} colName - The column name.
             * @returns {boolean} True if it's a numeric metric, false otherwise.
             */
            function isMeaningfulNumeric(colName) {
                if (!colName || schema[colName] !== 'number') return false;
                const lowerColName = colName.toLowerCase();
                // Keywords that suggest a numeric column is a metric, not just an ID
                const meaningfulKeywords = ['sales', 'profit', 'revenue', 'cost', 'quantity', 'price', 'amount', 'value', 'rating', 'score', 'spend', 'income', 'age', 'duration'];
                // Exclude columns that are likely IDs even if numeric
                const excludeKeywords = ['id', 'zip', 'postcode'];
                return meaningfulKeywords.some(keyword => lowerColName.includes(keyword)) &&
                       !excludeKeywords.some(keyword => lowerColName.includes(keyword));
            }

            /**
             * Checks if a column name is likely a meaningful categorical dimension (e.g., Region, Ship Mode).
             * Used for generating more relevant proactive insights.
             * @param {string} colName - The column name.
             * @returns {boolean} True if it's a categorical dimension, false otherwise.
             */
            function isMeaningfulCategorical(colName) {
                if (!colName || schema[colName] !== 'string') return false;
                const lowerColName = colName.toLowerCase();
                const meaningfulKeywords = ['region', 'category', 'ship mode', 'customer segment', 'product type', 'gender', 'department', 'city', 'status', 'channel', 'source', 'country', 'state', 'payment'];
                return meaningfulKeywords.some(keyword => lowerColName.includes(keyword)) && !lowerColName.includes('id');
            }

            /**
             * Generates proactive insights based on the loaded data.
             * Stores them in `lastProactiveInsights`.
             */
            function generateProactiveInsights() {
                if (rawData.length === 0) {
                    lastProactiveInsights = [];
                    return;
                }

                let insights = [];

                // 1. Sales Drop Anomaly Detection with Root Cause Suggestion (Highly relevant)
                const dateCols = ['Date', 'Order Date', 'Transaction Date', 'Activity Date', 'Ship Date'];
                const salesCols = ['Sales', 'Revenue', 'Amount', 'Total'];
                const regionCols = ['Region', 'Area', 'Territory', 'Country', 'State', 'City'];
                const marketingSpendCols = ['Marketing Spend', 'Ad Spend', 'Campaign Cost', 'Promotion Cost'];

                // Find the first meaningful date, sales, region, and marketing spend columns
                const dateCol = dateCols.map(c => findColumnByName(c)).find(c => c !== null);
                const salesCol = salesCols.map(c => findNumericColumn(c)).find(c => c !== null);
                const regionCol = regionCols.map(c => findCategoricalColumn(c)).find(c => c !== null);
                const marketingSpendCol = marketingSpendCols.map(c => findNumericColumn(c)).find(c => c !== null);

                if (dateCol && salesCol && regionCol) {
                    const uniqueDates = [...new Set(rawData.map(row => row[dateCol]))]
                                         .map(parseDate)
                                         .filter(d => d !== null)
                                         .sort((a, b) => a.getTime() - b.getTime());

                    // Need at least 8 days for 1 current + 7 historical for comparison
                    if (uniqueDates.length >= 8) {
                        const latestDate = uniqueDates[uniqueDates.length - 1];
                        const eightDaysAgo = new Date(latestDate.getTime());
                        eightDaysAgo.setDate(latestDate.getDate() - 7);

                        const regions = [...new Set(rawData.map(row => row[regionCol]))].filter(r => r);

                        regions.forEach(region => {
                            // Filter data relevant to the current region and valid dates
                            const regionData = rawData.filter(row => {
                                const rowDate = parseDate(row[dateCol]);
                                return row[regionCol] === region && rowDate !== null;
                            });

                            // Calculate sales for the latest day in the loop
                            const currentDaySalesData = regionData.filter(row => {
                                const rowDate = parseDate(row[dateCol]);
                                return rowDate && rowDate.toDateString() === latestDate.toDateString(); // Compare full date strings
                            });
                            const currentDaySales = currentDaySalesData.reduce((sum, row) => sum + (Number(row[salesCol]) || 0), 0);

                            // Calculate sales for the last 7 days (excluding the latest date)
                            const last7DaysSalesData = regionData.filter(row => {
                                const rowDate = parseDate(row[dateCol]);
                                return rowDate && rowDate.getTime() >= eightDaysAgo.getTime() && rowDate.getTime() < latestDate.getTime();
                            });
                            const last7DaysTotalSales = last7DaysSalesData.reduce((sum, row) => sum + (Number(row[salesCol]) || 0), 0);
                            const last7DaysAvgSales = last7DaysSalesData.length > 0 ? last7DaysTotalSales / last7DaysSalesData.length : 0;

                            if (last7DaysAvgSales > 0) {
                                const salesDropPercentage = ((last7DaysAvgSales - currentDaySales) / last7DaysAvgSales) * 100;
                                const dropThreshold = 15; // Define a significant drop as 15%

                                if (salesDropPercentage > dropThreshold) {
                                    let message = `Sales in the **${region} region** are **down ${salesDropPercentage.toFixed(1)}%** on ${latestDate.toLocaleDateString()} compared to the last 7-day average. This deviation is significant.`;
                                    // Use a common date format for suggested command, e.g.,YYYY-MM-DD or MM/DD/YYYY
                                    const suggestedDate = latestDate.toISOString().split('T')[0]; // Format as YYYY-MM-DD

                                    // Check for consistent marketing spend if the column exists
                                    if (marketingSpendCol) {
                                        const currentDayMarketingSpend = currentDaySalesData.reduce((sum, row) => sum + (Number(row[marketingSpendCol]) || 0), 0);
                                        const last7DaysMarketingSpend = last7DaysSalesData.length > 0 ? last7DaysSalesData.reduce((sum, row) => sum + (Number(row[marketingSpendCol]) || 0), 0) / last7DaysSalesData.length : 0;
                                        const marketingSpendDeviation = last7DaysMarketingSpend > 0 ? Math.abs((currentDayMarketingSpend - last7DaysMarketingSpend) / last7DaysMarketingSpend) * 100 : Infinity;
                                        const marketingConsistencyThreshold = 10; // e.g., within 10% deviation

                                        if (marketingSpendDeviation <= marketingConsistencyThreshold) {
                                            message += ` This is despite a **consistent marketing spend** in the region.`;
                                            message += `<br><br><strong>Recommendation:</strong>
                                                <ol>
                                                    <li><strong>Investigate Sales Transactions:</strong> Examine specific sales transactions in ${region} for ${latestDate.toLocaleDateString()} to identify immediate patterns. Type: \`filter data where ${regionCol} = "${region}" and ${dateCol} = "${suggestedDate}"\`</li>
                                                    <li><strong>Review External Factors:</strong> This suggests external factors may be at play. Consider reviewing recent mobile app updates, website traffic analytics, or local events that might impact sales in the ${region} region.</li>
                                                    <li><strong>Engage Relevant Teams:</strong> If external analysis points to a technical issue, consider alerting your mobile development or product team.</li>
                                                </ol>
                                                <em>(Note: CoDA is a client-side tool and cannot directly interact with external systems like email or Jira.)</em>`;
                                        } else {
                                            message += ` It also appears **marketing spend has changed** significantly in this period.`;
                                            message += `<br><br><strong>Recommendation:</strong>
                                                <ol>
                                                    <li><strong>Investigate Marketing Spend:</strong> Analyze the specific marketing activities or budget changes in ${region} for ${latestDate.toLocaleDateString()}. Type: \`filter data where ${regionCol} = "${region}" and ${dateCol} = "${suggestedDate}"\` and then look for ${marketingSpendCol}.</li>
                                                    <li><strong>Deep Dive Sales Data:</strong> Examine specific sales transactions in ${region} for ${latestDate.toLocaleDateString()}. Type: \`filter data where ${regionCol} = "${region}" and ${dateCol} = "${suggestedDate}"\`</li>
                                                    <li><strong>Correlate & Act:</strong> Understand if the change in marketing spend directly correlates with the sales drop, then decide on necessary actions.</li>
                                                </ol>
                                                <em>(Note: CoDA is a client-side tool and cannot directly interact with external systems like email or Jira.)</em>`;
                                        }
                                    } else {
                                        // No marketing spend column, provide general recommendation
                                        message += `<br><br><strong>Recommendation:</strong>
                                            <ol>
                                                <li><strong>Investigate Sales Transactions:</strong> Examine specific sales transactions in ${region} for ${latestDate.toLocaleDateString()} to identify immediate patterns. Type: \`filter data where ${regionCol} = "${region}" and ${dateCol} = "${suggestedDate}"\`</li>
                                                <li><strong>Consider External Factors:</strong> Review factors outside this dataset that might influence sales in the ${region} region.</li>
                                            </ol>`;
                                    }

                                    insights.push({
                                        type: 'anomaly',
                                        icon: 'fas fa-chart-line-down',
                                        title: `Significant Sales Drop Detected in ${region} Region!`,
                                        message: message,
                                        action: `filter data where ${regionCol} = "${region}" and ${dateCol} = "${suggestedDate}"` // Action to filter data by region and date
                                    });
                                }
                            }
                        });
                    }
                }


                // 2. Outlier Detection for meaningful numeric columns
                const numericCols = Object.keys(schema).filter(col => schema[col] === 'number');
                numericCols.forEach(col => {
                    if (!isMeaningfulNumeric(col)) return; // Only analyze meaningful numeric columns

                    const { outliers, lowerBound, upperBound } = findOutliers(col, rawData);
                    if (outliers.length > 0) {
                        insights.push({
                            type: 'anomaly',
                            icon: 'fas fa-exclamation-triangle',
                            title: `Outliers Detected in ${col} Column`,
                            message: `I've detected **${outliers.length} potential outliers** in the numeric column "<strong>${col}</strong>". These values fall outside the IQR bounds (${lowerBound} - ${upperBound}). This could indicate data entry errors or unusual events that warrant further investigation.`,
                            action: `find outliers in ${col}`
                        });
                    }
                });

                // 3. Top/Bottom Performer Identification for meaningful numeric values by meaningful categorical groups
                const meaningfulNumericCols = Object.keys(schema).filter(col => isMeaningfulNumeric(col));
                const meaningfulCategoricalCols = Object.keys(schema).filter(col => isMeaningfulCategorical(col));

                meaningfulNumericCols.forEach(numCol => {
                    meaningfulCategoricalCols.forEach(catCol => {
                        // Skip if the categorical column is the same as the primary date/region column handled above
                        if (catCol === dateCol || catCol === regionCol) return;

                        const groupedData = {};

                        rawData.forEach(row => {
                            const category = row[catCol];
                            const numericValue = Number(row[numCol]);

                            if (category !== undefined && category !== null && category !== '' && !isNaN(numericValue)) {
                                if (!groupedData[category]) {
                                    groupedData[category] = { sum: 0, count: 0 };
                                }
                                groupedData[category].sum += numericValue;
                                groupedData[category].count++;
                            }
                        });

                        // Convert to array of [category, {sum, count}] for sorting
                        const sortedBySum = Object.entries(groupedData).sort(([, a], [, b]) => b.sum - a.sum);
                        const sortedByAvg = Object.entries(groupedData)
                                                     .map(([category, data]) => [category, data.sum / data.count])
                                                     .filter(([, avg]) => !isNaN(avg)) // Filter out NaNs if any categories had no numeric data
                                                     .sort(([, a], [, b]) => b - a);

                        if (sortedBySum.length > 1) { // Need at least two categories to talk about top/bottom
                            const topSumCat = sortedBySum[0];
                            const bottomSumCat = sortedBySum[sortedBySum.length - 1];
                            insights.push({
                                type: 'trend',
                                icon: 'fas fa-chart-line',
                                title: `Top/Bottom ${numCol} by ${catCol} (Total)`,
                                message: `For **total ${numCol}**, "<strong>${topSumCat[0]}</strong>" in **${catCol}** has the highest sum (${topSumCat[1].sum.toFixed(2)}), while "<strong>${bottomSumCat[0]}</strong>" has the lowest (${bottomSumCat[1].sum.toFixed(2)}). This highlights key areas of high and low aggregate performance.`,
                                action: `show bar chart of ${numCol} by ${catCol} as sum`
                            });
                        }

                        if (sortedByAvg.length > 1) { // Need at least two categories to talk about top/bottom
                            const topAvgCat = sortedByAvg[0];
                            const bottomAvgCat = sortedByAvg[sortedByAvg.length - 1];
                            insights.push({
                                type: 'trend',
                                icon: 'fas fa-chart-bar',
                                title: `Top/Bottom ${numCol} by ${catCol} (Average)`,
                                message: `For **average ${numCol}**, "<strong>${topAvgCat[0]}</strong>" in **${catCol}</strong>" shows the highest average (${topAvgCat[1].toFixed(2)}), whereas "<strong>${bottomAvgCat[0]}</strong>" has the lowest (${bottomAvgCat[1].toFixed(2)}). This reveals efficiency or intensity per category.`,
                                action: `show bar chart of ${numCol} by ${catCol} as average`
                            });
                        }
                    });
                });

                // 4. Correlation Insights between meaningful numeric columns
                for (let i = 0; i < meaningfulNumericCols.length; i++) {
                    for (let j = i + 1; j < meaningfulNumericCols.length; j++) {
                        const col1 = meaningfulNumericCols[i];
                        const col2 = meaningfulNumericCols[j];
                        const correlation = calculateCorrelation(col1, col2, rawData);
                        if (correlation !== null && !isNaN(correlation)) {
                            const absCorrelation = Math.abs(correlation);
                            let correlationStrength = '';
                            let interpretation = '';
                            if (absCorrelation >= 0.8) {
                                correlationStrength = 'a **very strong**';
                                interpretation = 'These columns move very closely together, indicating a strong direct or inverse relationship.';
                            } else if (absCorrelation >= 0.6) {
                                correlationStrength = 'a **strong**';
                                interpretation = 'A significant relationship exists, where changes in one column are consistently associated with changes in the other.';
                            } else if (absCorrelation >= 0.4) {
                                correlationStrength = 'a **moderate**';
                                interpretation = 'There is a noticeable relationship, but other factors might also be at play.';
                            } else if (absCorrelation >= 0.2) {
                                correlationStrength = 'a **weak**';
                                interpretation = 'A slight tendency for the columns to move together exists, but it is not a dominant relationship.';
                            }

                            if (correlationStrength) {
                                const direction = correlation > 0 ? 'positive' : 'negative';
                                insights.push({
                                    type: 'correlation',
                                    icon: 'fas fa-link',
                                    title: `Correlation between ${col1} and ${col2}`,
                                    message: `There's ${correlationStrength} ${direction} correlation (${correlation.toFixed(2)}) between "<strong>${col1}</strong>" and "<strong>${col2}</strong>". ${interpretation}`,
                                    action: `show scatter plot with X as ${col1} and Y as ${col2}`
                                });
                            }
                        }
                    }
                }

                // 5. Categorical Distribution - Top N most/least frequent values for meaningful categorical columns
                meaningfulCategoricalCols.forEach(catCol => {
                    // Skip if the categorical column is one of the primary date/region columns already handled
                    if (catCol === dateCol || catCol === regionCol) return;

                    const values = rawData.map(row => row[catCol]).filter(v => v !== undefined && v !== null && v !== '');
                    if (values.length === 0) return; // Skip if no valid values

                    const valueCounts = {};
                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                    if (sortedCounts.length > 0) {
                        let topValues = sortedCounts.slice(0, Math.min(3, sortedCounts.length)).map(item => `"${item[0]}" (${((item[1]/values.length)*100).toFixed(1)}%)`).join(', ');
                        insights.push({
                            type: 'distribution',
                            icon: 'fas fa-chart-pie',
                            title: `Distribution of ${catCol}`,
                            message: `In "<strong>${catCol}</strong>", the top values are: ${topValues}. There are ${sortedCounts.length} unique values in total. Understanding these distributions is crucial for market segmentation or resource allocation.`,
                            action: `show frequency of ${catCol}`
                        });
                    }
                });

                lastProactiveInsights = insights; // Store the array of insight objects
            }

            /**
             * Helper function to safely encode a string for use in a URL component,
             * then HTML-escape it for safe embedding in an HTML attribute.
             * This prevents issues with special characters in JS string literals within HTML.
             * @param {string} str - The string to encode and escape.
             * @returns {string} The encoded and HTML-escaped string.
             */
            function encodeAndEscapeForHtmlAttribute(str) {
                // First, encode for URL component, this handles most special characters for JS string literal safety
                let encodedStr = encodeURIComponent(String(str));

                // Then, HTML escape to ensure it's safe within an HTML attribute value
                // Minimal set to avoid breaking HTML structure
                return encodedStr
                    .replace(/"/g, '&quot;')  // Escape double quotes
                    .replace(/'/g, '&#39;')   // Escape single quotes
                    .replace(/</g, '&lt;')    // Escape less than
                    .replace(/>/g, '&gt;')    // Escape greater than
                    .replace(/&/g, '&amp;');  // Escape ampersand
            }


            /**
             * Renders proactive insights into the `proactiveInsightsContent` area,
             * applying filtering and searching.
             * @param {string} filterType - 'all', 'anomaly', 'trend', 'correlation', 'distribution'.
             * @param {string} searchTerm - Text to search within insights.
             */
            function renderProactiveInsights(filterType = 'all', searchTerm = '') {
                proactiveInsightsContent.innerHTML = ''; // Clear previous content

                if (lastProactiveInsights.length === 0) {
                    proactiveInsightsContent.innerHTML = '<p class="text-gray-400 text-center py-4">No proactive insights available yet. Upload a CSV file to generate proactive insights.</p>';
                    return;
                }

                // Filter insights based on type and search term
                let filteredInsights = lastProactiveInsights.filter(insight => {
                    const matchesFilter = filterType === 'all' || insight.type === filterType;
                    const matchesSearch = searchTerm === '' ||
                                          insight.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                          insight.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                          insight.action.toLowerCase().includes(searchTerm.toLowerCase());
                    return matchesFilter && matchesSearch;
                });

                if (filteredInsights.length === 0) {
                    proactiveInsightsContent.innerHTML = `<p class="text-gray-400 text-center py-4">No insights match your current filters and search criteria.</p>`;
                    return;
                }

                // Render each filtered insight
                filteredInsights.forEach((insight, index) => {
                    const insightCard = document.createElement('div');
                    insightCard.className = 'insight-card';
                    // The action button's onclick uses the global `typeIntoChatAndSubmit`
                    insightCard.innerHTML = `
                        <div class="insight-header cursor-pointer" data-insight-index="${index}">
                            <i class="${insight.icon}"></i>
                            <h4>${insight.title}</h4>
                            <i class="fas fa-chevron-down ml-auto transition-transform"></i>
                        </div>
                        <div class="collapsible-content">
                            <p class="insight-message">${insight.message}</p>
                            ${insight.action ? `<span class="text-sm text-blue-100 italic">Suggested Command: </span><a href="#" class="insight-action" onclick="typeIntoChatAndSubmit('${encodeAndEscapeForHtmlAttribute(insight.action)}'); return false;">'${insight.action}'</a>` : ''}
                        </div>
                    `;
                    proactiveInsightsContent.appendChild(insightCard);
                });

                // Add event listeners for collapsing/expanding insight cards
                document.querySelectorAll('.insight-header').forEach(header => {
                    header.addEventListener('click', (event) => {
                        const content = header.nextElementSibling; // Get the .collapsible-content
                        const icon = header.querySelector('.fa-chevron-down');

                        if (content.classList.contains('show')) {
                            content.classList.remove('show');
                            icon.classList.remove('rotate-180');
                        } else {
                            // Hide all other open insights before opening the new one
                            document.querySelectorAll('.collapsible-content.show').forEach(openContent => {
                                openContent.classList.remove('show');
                                openContent.previousElementSibling.querySelector('.fa-chevron-down').classList.remove('rotate-180');
                            });
                            content.classList.add('show');
                            icon.classList.add('rotate-180');
                        }
                    });
                });
            }

            /**
             * Simulates an AI response by calling the NLU model and executing the identified intent.
             * @param {string} query - The user's input query.
             */
            async function simulateAIResponse(query) {
                let aiResponseText = '';
                let analysisContent = '';

                if (rawData.length === 0) {
                    appendMessage('AI', "Please upload a CSV file first before asking questions. I'm ready when you are!", 'ai');
                    return;
                }

                // Handle cleaning confirmation (pre-LLM check for quick response)
                if (pendingCleaningSuggestion && (query.toLowerCase() === 'yes' || query.toLowerCase().includes('confirm') || query.toLowerCase().includes('go ahead'))) {
                    const colToClean = pendingCleaningSuggestion.column;
                    if (pendingCleaningSuggestion.action === 'fill_average') {
                        const average = calculateColumnAverage(colToClean, rawData);
                        rawData = rawData.map(row => {
                            // Only fill if the current cell value is empty, null, undefined, or NaN after Number() conversion
                            if (row[colToClean] === '' || row[colToClean] === null || row[colToClean] === undefined || isNaN(Number(row[colToClean]))) {
                                row[colToClean] = average.toFixed(2); // Fill with average, keeping two decimal places
                            }
                            return row;
                        });
                        aiResponseText = `Great! I've successfully filled the ${pendingCleaningSuggestion.count} missing or invalid numeric values in the column "<strong>${colToClean}</strong>" with the calculated average of <strong>${average.toFixed(2)}</strong>. Your data has been updated locally and privately.`;
                        pendingCleaningSuggestion = null; // Clear the suggestion after execution
                    }
                    appendMessage('AI', aiResponseText, 'ai');
                    return;
                }

                // Show loading indicator before NLU call
                showLoadingIndicator();

                try {
                    // Escape any backticks that might appear in the stringified schema
                    // to prevent premature template literal closure in the prompt string.
                    const escapedSchemaJson = JSON.stringify(schema, null, 2).replace(/`/g, '\\`');

                    // Construct the prompt for the LLM (NLU model)
                    const prompt = `You are an AI data analysis assistant named CoDA. Your primary goal is to interpret user queries about a dataset and output *only* a structured JSON response. Your response MUST BE PURE JSON, with no surrounding markdown (e.g., no \\\`\`\`json or \\\`\`\`) and no conversational text. The JSON *must* strictly adhere to the provided schema, with all keys and string values enclosed in double quotes.

                    **Prioritize accurately identifying the user's core intent and extracting all relevant parameters.** When identifying column names, be highly flexible:
                    - Use case-insensitive matching.
                    - Allow for partial matches (e.g., "prod ID" for "Product ID", "cust" for "Customer").
                    - Consider common variations and synonyms (e.g., "avg" for "average", "std dev" for "standard deviation", "qty" for "quantity", "amt" for "amount", "num" for "number", "perc" for "percentage", "cat" for "category", "dist" for "distribution", "sum" for "total").
                    - If a column name is not found or is ambiguous, you MUST still attempt to identify the most likely intent and *output the user's provided column name*. The client-side application will then handle validation (e.g., checking if it's numeric when a numeric column is expected).

                    The current dataset has the following schema (column names and their inferred types):
                    ${escapedSchemaJson}

                    Here are the supported intents and their expected parameters (all intent and parameter string values must be in double quotes):

                    1.  **General Overview**:
                        * "get_all_data": No parameters.
                            * Examples: "show all data", "display everything", "what's in the dataset?", "give me all the records", "show the raw data", "display entire table", "full dataset", "all rows"
                        * "get_column_data": "column_name" (string).
                            * Examples: "show sales column", "display customer ID", "what's in product name?", "show the column called 'region'", "tell me about the age column", "get values from 'price'", "show me the 'date' column", "data for 'status'"
                        * "get_row_count": No parameters.
                            * Examples: "how many rows", "count entries", "number of records", "how many items are there?", "total number of rows", "dataset size", "row count"
                        * "describe_dataset": No parameters.
                            * Examples: "describe my dataset", "overview of data", "summarize the dataset", "tell me about the data", "provide a data summary", "give data insights", "dataset info", "data description"
                        * "show_schema": No parameters.
                            * Examples: "show schema", "what is the structure", "display schema", "tell me the column types", "what are the columns", "show data structure", "column info"

                    2.  **Statistical Analysis**:
                        * "get_sum": "column_name" (string, numeric type).
                            * Examples: "sum of profit", "total sales", "calculate sum of 'quantity'", "what is the total revenue?", "give me the sum for 'price'", "add up 'expenses'", "sum expenses", "total amount"
                        * "get_average": "column_name" (string, numeric type).
                            * Examples: "average age", "mean of revenue", "what's the avg sales?", "calculate the mean of 'price'", "find average of 'score'", "avg 'duration'", "average temp", "mean income"
                        * "get_median": "column_name" (string, numeric type).
                            * Examples: "median income", "what is the median of 'score'?", "find the middle value of 'salary'", "median 'height'", "midpoint of 'value'"
                        * "get_std_dev": "column_name" (string, numeric type).
                            * Examples: "standard deviation of price", "std dev of 'salary'", "what's the variability of 'cost'?", "calculate variance for 'duration'", "how spread out is 'weight'?", "dev of 'points'"
                        * "get_quartiles": "column_name" (string, numeric type).
                            * Examples: "quartiles of score", "show quartiles for 'age'", "what are the Q1, Q3 for 'income'?", "percentiles for 'weight'", "interquartile range of 'value'", "quartile breakdown of 'price'"
                        * "get_unique_count": "column_name" (string).
                            * Examples: "count unique cities", "how many unique products", "number of distinct categories", "unique values in 'country'", "how many different types of 'service'?", "distinct items in 'status'", "unique 'id' count"
                        * "get_frequency": "column_name" (string).
                            * Examples: "show frequency of gender", "top values in region", "most common 'product type'", "frequency of 'status'", "breakdown of 'department'", "count occurrences of 'item'", "how many of each 'type'"
                        * "get_min": "column_name" (string, numeric type).
                            * Examples: "minimum temperature", "lowest value in 'stock'", "what's the min 'order amount'?", "smallest 'value'", "least 'quantity'", "min 'score'"
                        * "get_max": "column_name" (string, numeric type).
                            * Examples: "maximum sales", "highest value in 'points'", "what's the max 'duration'?", "largest 'quantity'", "biggest 'price'", "max 'value'"
                        * "get_average_by_category": "numeric_column" (string), "categorical_column" (string).
                            * Examples: "average sales by region", "mean salary per department", "avg 'quantity' by 'product type'", "average 'score' grouped by 'class'", "what's the average 'revenue' for each 'source'?", "average rating per movie", "avg profit by category"
                        * "get_correlation": "column_name" (string, numeric type), "column_name_2" (string, numeric type).
                            * Examples: "show correlation between age and income", "correlation of 'temp' and 'humidity'", "relationship between 'spend' and 'conversion'", "how do 'x' and 'y' correlate?", "link between 'education' and 'salary'", "correlation price and size"
                        * "find_outliers": "column_name" (string, numeric type).
                            * Examples: "find outliers in sales", "detect anomalies in 'price'", "are there any unusual values in 'expenses'?", "show me the extreme points in 'data_column'", "identify abnormal 'scores'", "outliers in 'revenue'"

                    3.  **Data Manipulation**:
                        * "filter_data": "column_name" (string), "operator" (string, e.g., '>', '<', '=', '>=', '<=', '!='), "value" (string or number).
                            * Examples: "filter where sales > 1000", "show rows where city is London", "keep data where 'status' is 'completed'", "filter by 'age' < 30", "exclude records where 'id' is 'XYZ'", "only show items with 'price' = 50", "rows where 'date' is '2023-01-01'", "filter products with status 'pending'", "data where 'revenue' is greater than 500"
                        * "add_calculated_column": "new_column_name" (string), "column_name" (string, numeric type), "operator" (string, 'plus', 'minus', 'times', 'divided by'), "column_name_2" (string, numeric type).
                            * Examples: "add column profit as revenue minus cost", "create 'total price' from 'quantity' times 'unit_cost'", "new col 'net' is 'gross' minus 'tax'", "calculate 'margin' as 'sales' minus 'cost'", "column 'area' as 'length' times 'width'", "make a new column 'total_cost' from 'units' times 'price'"
                        * "categorize_column": "column_name" (string, numeric type), "num_bins" (number), "new_column_name" (string).
                            * Examples: "categorize age into 5 bins as Age_Group", "bin 'income' into 4 groups named 'Income_Bracket'", "group 'score' into 3 levels", "create 'price_ranges' from 'price' using 10 bins", "segment 'customers' by 'spend' into 3 categories", "categorize 'score' into 3 bins"
                        * "remove_duplicates": No parameters.
                            * Examples: "remove duplicate rows", "delete identical entries", "clean duplicates", "get rid of repeated entries", "deduplicate data", "remove all duplicates"
                        * "rename_column": "old_column_name" (string), "new_column_name" (string).
                            * Examples: "rename product_id to sku", "change column 'customer_name' to 'client'", "rename 'order_date' to 'purchase_date'", "call 'old_col' 'new_col'", "change 'zip' to 'postal_code'", "rename col 'id' to 'product_id'"

                    4.  **Business Intelligence**:
                        * "summarize_by_category": "numeric_column" (string), "categorical_column" (string).
                            * Examples: "summarize sales by region", "breakdown revenue by 'department'", "aggregate 'units' by 'product category'", "provide summary of 'orders' per 'country'", "summary of 'transactions' by 'payment_method'", "summarize 'spend' by 'channel'"
                        * "get_business_overview": No parameters.
                            * Examples: "show overall business overview", "give me a business summary", "what's the big picture?", "dashboard overview", "provide high-level summary", "business metrics"

                    5.  **Charting & Visualization**:
                        * "create_bar_chart": "numeric_column" (string), "categorical_column" (string), "aggregate_type" (string, 'sum' or 'average', default 'sum').
                            * Examples: "show bar chart of sales by region as average", "bar chart for 'profit' per 'country' (sum)", "plot average 'rating' by 'product'", "draw bar chart of 'quantities' by 'category'", "bar graph of 'employees' by 'job_title'", "bar chart of 'revenue' per 'month'"
                        * "create_line_chart": "x_column" (string), "y_column" (string, numeric type).
                            * Examples: "show line chart with X as Date and Y as Stock Price", "line graph of 'time' vs 'temperature'", "plot 'visitors' over 'month'", "trend of 'sales' against 'date'", "show 'performance' over 'fiscal_period'", "line chart for 'users' over 'time'"
                        * "create_scatter_plot": "x_column" (string, numeric type), "y_column" (string, numeric type).
                            * Examples: "show scatter plot with X as Age and Y as Income", "scatter plot of 'height' and 'weight'", "plot 'advertising_spend' against 'revenue'", "relationship graph between 'feature1' and 'feature2'", "visualize 'clicks' vs 'conversions'", "scatter of 'gdp' vs 'life expectancy'"
                        * "create_pie_chart": "column_name" (string) OR ("numeric_column" (string), "categorical_column" (string), "aggregate_type" (string, 'sum' or 'average')).
                            * Examples: "pie chart of Gender", "pie chart of sales by region as sum", "show pie chart of 'marital_status'", "pie chart of 'expenses' by 'category' (average)", "breakdown by 'city' with a pie chart", "distribution of 'status' as pie"
                        * "create_doughnut_chart": "column_name" (string) OR ("numeric_column" (string), "categorical_column" (string), "aggregate_type" (string, 'sum' or 'average')).
                            * Examples: "doughnut chart of Region", "doughnut chart of revenue by product type as average", "donut chart for 'status'", "doughnut chart of 'cost' by 'department'", "distribution of 'customer_type' as donut chart", "ring chart of 'priority' sums"
                        * "create_polar_area_chart": "column_name" (string) OR ("numeric_column" (string), "categorical_column" (string), "aggregate_type" (string, 'sum' or 'average')).
                            * Examples: "polar area chart of Status", "polar area chart of quantity by category", "show polar chart of 'severity'", "polar area chart of 'bugs' by 'priority' (sum)", "display 'market_share' by 'product_line' using polar chart", "radial chart of 'score' by 'segment' sums"

                    6.  **Modeling**:
                        * "perform_linear_regression": "y_column" (string, numeric type), "x_column" (string, numeric type).
                            * Examples: "perform regression with Y as Sales and X as Advertising", "run linear regression on 'score' vs 'study_hours'", "predict 'outcome' based on 'input_feature'", "model 'price' based on 'size'", "find relationship between 'effort' and 'result'", "regression of 'revenue' on 'spend'"

                    7.  **Automated Insights (Proactive)**:
                        * "get_proactive_insights": No parameters.
                            * Examples: "show proactive insights", "what insights do you have?", "tell me what you found", "any interesting patterns?", "give me automated insights", "proactive analysis"

                    If the user asks for a command guide (e.g., "show command guide", "help me", "what can you do?"), respond with intent "show_command_guide".
                    If the user confirms a pending cleaning suggestion (e.g., "yes", "confirm", "go ahead"), respond with intent "confirm_cleaning_suggestion".
                    If, after applying all your understanding and flexibility (including fuzzy matching and synonym recognition), the user's intent or essential parameters for *any* of the defined intents are genuinely unclear, or the query falls outside your defined capabilities, respond with intent "unrecognized_command" and an empty parameters object.
                    
                    User query: "${query}"
                    `;

                    const chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = {
                        // Added model field explicitly
                        model: "gemini-2.0-flash",
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "intent": { "type": "STRING" },
                                    "parameters": {
                                        "type": "OBJECT",
                                        // Re-added additionalProperties to be less strict for parsing; better for LLM flexibility
                                        "additionalProperties": true, 
                                        properties: {
                                            "column_name": { "type": "STRING" },
                                            "column_name_2": { "type": "STRING" },
                                            "operator": { "type": "STRING" },
                                            "value": { "type": ["STRING", "NUMBER"] },
                                            "aggregate_type": { "type": "STRING" },
                                            "chart_type": { "type": "STRING" },
                                            "num_bins": { "type": "NUMBER" },
                                            "new_column_name": { "type": "STRING" },
                                            "old_column_name": { "type": "STRING" },
                                            "numeric_column": { "type": "STRING" },
                                            "categorical_column": { "type": "STRING" },
                                            "x_column": { "type": "STRING" },
                                            "y_column": { "type": "STRING" }
                                        },
                                    }
                                },
                                "required": ["intent", "parameters"]
                            }
                        }
                    };

                    const apiKey = "AIzaSyC8Hy4FxyPRsHjj9HYnXOw_uUsvSf_5nWw"; // Leave this empty; Canvas will inject the key at runtime
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    hideLoadingIndicator(); // Hide loading indicator once response is received

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        let rawLLMText = result.candidates[0].content.parts[0].text;
                        console.log("Raw LLM Response Text (before cleaning):", rawLLMText);

                        // Robustly extract JSON using regex, in case markdown fences are added by LLM
                        const jsonMatch = rawLLMText.match(/```json\s*([\s\S]*?)\s*```/);
                        if (jsonMatch && jsonMatch[1]) {
                            rawLLMText = jsonMatch[1];
                        } else {
                            // If no markdown fences, assume it's pure JSON and just trim
                            rawLLMText = rawLLMText.trim();
                        }

                        // Check if the cleaned text is empty or too short to be valid JSON
                        if (!rawLLMText || rawLLMText.length < 2) { // Minimal JSON is "{}"
                            throw new Error("LLM returned empty or too short JSON string after cleaning.");
                        }

                        console.log("Cleaned LLM Response Text (attempting to parse):", rawLLMText);

                        let nluOutputJson;
                        try {
                            nluOutputJson = JSON.parse(rawLLMText);
                        } catch (parseError) {
                            console.error("JSON Parse Error:", parseError);
                            console.error("Malformed JSON received from LLM:", rawLLMText);
                            aiResponseText = `I received an invalid response from the AI. The response was not in a parsable JSON format. Please try again or rephrase. (Error details: ${parseError.message})`;
                            appendMessage('AI', aiResponseText, 'ai');
                            return; // Exit function as we can't proceed with malformed JSON
                        }

                        const intent = nluOutputJson.intent;
                        const params = nluOutputJson.parameters || {}; // Ensure params is an object

                        console.log("LLM Intent:", intent);
                        console.log("LLM Parameters:", params);

                        // Route the recognized intent to the appropriate local function
                        switch (intent) {
                            case 'confirm_cleaning_suggestion':
                                // This intent is handled at the very beginning of simulateAIResponse.
                                // If we reach here, it means the LLM re-issued it, which is fine as a fallback.
                                aiResponseText = `I've confirmed your request for data cleaning. If there was a pending suggestion, it should have been processed.`;
                                break;
                            case 'get_all_data':
                                analysisContent = `<p class="text-gray-300 mt-2">Here's a preview of the **first 10 rows** from your dataset:</p>
                                                    <div class="code-block mt-2">${rawData.slice(0, 10).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>
                                                    <p class="text-sm text-gray-400 mt-2">You have a total of ${rawData.length} rows. This data is processed entirely on your device!</p>`;
                                aiResponseText = `Understood! Here's your data:`;
                                break;
                            case 'get_column_data': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to show data. Example: 'show sales column'.`;
                                    break;
                                }
                                const foundColumn = findColumnByName(params.column_name);
                                if (foundColumn) {
                                    const columnValues = rawData.map(row => row[foundColumn]);
                                    analysisContent = `<p class="text-gray-300 mt-2">Here are the **first 10 values** from the "<strong>${foundColumn}</strong>" column:</p>
                                                        <div class="code-block mt-2">${columnValues.slice(0, 10).join('\n')}</div>
                                                        <p class="text-sm text-gray-400 mt-2">There are ${columnValues.length} total values in this column.</p>`;
                                    aiResponseText = `Absolutely! Here's the data for column "${foundColumn}", retrieved instantly from your local dataset.`;
                                } else {
                                    aiResponseText = `I couldn't find a column matching "<strong>${params.column_name}</strong>". Please check your column name.`;
                                }
                                break;
                            }
                            case 'get_row_count': {
                                const numRows = rawData.length;
                                aiResponseText = `Your dataset currently contains **${numRows} rows** (records).`;
                                break;
                            }
                            case 'describe_dataset': {
                                let numRows = rawData.length;
                                let numCols = Object.keys(schema).length;
                                let descriptionNarrative = `<p class="text-gray-300 leading-relaxed mb-3">Alright, let's take a look at your dataset. It appears you have <strong>${numRows} rows</strong>, which means ${numRows} individual records, and <strong>${numCols} columns</strong>, representing ${numCols} different types of information.</p>
                                                            <h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Here's a breakdown of what I found in each column:</h5>
                                                            <ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;

                                for (const col in schema) {
                                    descriptionNarrative += `<li class="font-medium">${col}: (<span class="text-blue-400">${schema[col]}</span> type) `;
                                    const values = rawData.map(row => row[col]);

                                    if (schema[col] === 'number') {
                                        const stats = getDescriptiveStats(col, rawData);
                                        const quartiles = calculateQuartiles(col, rawData);
                                        if (stats && stats.count > 0) {
                                            descriptionNarrative += `This column contains numerical data, ranging from <strong>${stats.min.toFixed(2)}</strong> to <strong>${stats.max.toFixed(2)}</strong>, with an average value of approximately <strong>${stats.mean.toFixed(2)}</strong>.`;
                                            if (stats.median !== null) descriptionNarrative += ` The median is <strong>${stats.median.toFixed(2)}</strong>.`;
                                            if (stats.stdDev !== null) descriptionNarrative += ` Standard deviation is <strong>${stats.stdDev.toFixed(2)}</strong>.`;
                                            if (quartiles.q1 !== null) descriptionNarrative += ` Q1 is <strong>${quartiles.q1}</strong>, Q3 is <strong>${quartiles.q3}</strong>, and the IQR is <strong>${quartiles.iqr}</strong>.`;
                                            // Add simple correlation insights here as well for description
                                            const correlationWithOtherNumerics = [];
                                            for (const otherCol in schema) {
                                                if (otherCol !== col && schema[otherCol] === 'number' && isMeaningfulNumeric(otherCol)) {
                                                    const corr = calculateCorrelation(col, otherCol, rawData);
                                                    if (corr !== null && !isNaN(corr) && Math.abs(corr) >= 0.2) { // Show if moderately correlated
                                                        correlationWithOtherNumerics.push(`${otherCol}: ${corr.toFixed(2)}`);
                                                    }
                                                }
                                            }
                                            if (correlationWithOtherNumerics.length > 0) {
                                                descriptionNarrative += `<br>&nbsp;&nbsp;It shows correlations with: ${correlationWithOtherNumerics.join(', ')}.`;
                                            }
                                        } else {
                                            descriptionNarrative += `This numeric column currently has no valid numerical entries.`;
                                        }
                                    } else { // string type
                                        const uniqueValues = [...new Set(values)];
                                        const valueCounts = {};
                                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                        const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                                        descriptionNarrative += `This column holds text information. I found <strong>${uniqueValues.length} unique values</strong>. The most frequent entries are: ${sortedCounts.slice(0, 5).map(item => `"${item[0]}" appearing ${item[1]} times`).join(', ')}.`;
                                    }
                                    descriptionNarrative += `</li>`;
                                }
                                descriptionNarrative += `</ul>`;
                                analysisContent = descriptionNarrative;
                                aiResponseText = `Certainly! Here's a comprehensive overview and description of your dataset, crafted to give you quick insights. This analysis was performed entirely client-side, ensuring your data's privacy.`;
                                break;
                            }
                            case 'show_schema':
                                analysisContent = `<p class="text-gray-300 mt-2">Here's the **schema I inferred** from your uploaded data:</p>
                                                    <div class="code-block mt-2">${JSON.stringify(schema, null, 2)}</div>`;
                                aiResponseText = `Certainly! I've extracted the schema for you. All schema inference happens privately in your browser.`;
                                break;
                            case 'get_sum': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to calculate the sum. Example: 'sum of profit'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const sum = calculateColumnSum(foundColumn, rawData);
                                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The sum of "${foundColumn}" is: ${sum.toFixed(2)}</p>`;
                                    aiResponseText = `Alright, I've calculated the **total sum** for the column "<strong>${foundColumn}</strong>". Here's the result:`;
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the sum for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_average': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to calculate the average. Example: 'average age'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const average = calculateColumnAverage(foundColumn, rawData);
                                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The average of "${foundColumn}" is: ${average.toFixed(2)}</p>`;
                                    aiResponseText = `Understood! Here's the **average value** for the "<strong>${foundColumn}</strong>" column:`;
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the average for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_median': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to calculate the median. Example: 'median income'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const median = calculateMedian(foundColumn, rawData);
                                    if (median !== null) {
                                        aiResponseText = `The **median** for the column "<strong>${foundColumn}</strong>" is: <strong>${median.toFixed(2)}</strong>.`;
                                    } else {
                                        aiResponseText = `I couldn't calculate the median for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the median for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_std_dev': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to calculate the standard deviation. Example: 'standard deviation of price'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const stdDev = calculateStandardDeviation(foundColumn, rawData);
                                    if (stdDev !== null) {
                                        aiResponseText = `The **standard deviation** for the column "<strong>${foundColumn}</strong>" is: <strong>${stdDev.toFixed(2)}</strong>.`;
                                    } else {
                                        aiResponseText = `I couldn't calculate the standard deviation for "<strong>${foundColumn}</strong>" as it contains insufficient numeric data (at least 2 values are needed).`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the standard deviation for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_quartiles': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to calculate quartiles. Example: 'quartiles of score'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const quartiles = calculateQuartiles(foundColumn, rawData);
                                    if (quartiles.median !== null) {
                                        aiResponseText = `For the column "<strong>${foundColumn}</strong>":<br>
                                            **Q1 (25th percentile)**: <strong>${quartiles.q1}</strong><br>
                                            **Median (50th percentile)**: <strong>${quartiles.median}</strong><br>
                                            **Q3 (75th percentile)**: <strong>${quartiles.q3}</strong><br>
                                            **IQR (Interquartile Range)**: <strong>${quartiles.iqr}</strong>.`;
                                    } else {
                                        aiResponseText = `I couldn't calculate quartiles for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate quartiles for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_unique_count': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to count unique values. Example: 'count unique cities'.`;
                                    break;
                                }
                                const foundColumn = findColumnByName(params.column_name);
                                if (foundColumn) {
                                    const values = rawData.map(row => row[foundColumn]);
                                    const uniqueCount = new Set(values).size;
                                    aiResponseText = `The column "<strong>${foundColumn}</strong>" has **${uniqueCount} unique values**.`;
                                } else {
                                    aiResponseText = `I couldn't find a column matching "<strong>${params.column_name}</strong>" to count unique values. Please specify a valid column name.`;
                                }
                                break;
                            }
                            case 'get_frequency': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to show frequency. Example: 'show frequency of gender'.`;
                                    break;
                                }
                                const foundColumn = findColumnByName(params.column_name);
                                if (foundColumn) {
                                    const values = rawData.map(row => row[foundColumn]);
                                    const valueCounts = {};
                                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                                    let frequencyList = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                    sortedCounts.slice(0, 5).forEach(([value, count]) => {
                                        const percentage = ((count / values.length) * 100).toFixed(1);
                                        frequencyList += `<li>"<strong>${value}</strong>": ${count} occurrences (${percentage}%)</li>`;
                                    });
                                    frequencyList += `</ul>`;
                                    aiResponseText = `Here's the **frequency distribution** for "<strong>${foundColumn}</strong>", showing the top 5 most common values:`;
                                    analysisContent = frequencyList;
                                } else {
                                    aiResponseText = `I couldn't find a column matching "<strong>${params.column_name}</strong>" to show its frequency. Please specify a valid column name.`;
                                }
                                break;
                            }
                            case 'get_min': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to find the minimum value. Example: 'minimum temperature'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const { min } = calculateColumnMinMax(foundColumn, rawData);
                                    if (min !== null) {
                                        aiResponseText = `For the numeric column "<strong>${foundColumn}</strong>":<br>The **minimum value** is: <strong>${min}</strong>.`;
                                    } else {
                                        aiResponseText = `There are no valid numeric entries in "<strong>${foundColumn}</strong>" to calculate the minimum.`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the minimum for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_max': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to find the maximum value. Example: 'maximum sales'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const { max } = calculateColumnMinMax(foundColumn, rawData);
                                    if (max !== null) {
                                        aiResponseText = `For the numeric column "<strong>${foundColumn}</strong>":<br>The **maximum value** is: <strong>${max}</strong>.`;
                                    } else {
                                        aiResponseText = `There are no valid numeric entries in "<strong>${foundColumn}</strong>" to calculate the maximum.`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to calculate the maximum for. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'get_average_by_category': {
                                if (!params.numeric_column || !params.categorical_column) {
                                    aiResponseText = `To calculate average by category, I need both a numeric column and a categorical column. Example: 'average sales by region'.`;
                                    break;
                                }
                                // Use the correct parameter names from the LLM's NLU output
                                const numericColumn = findNumericColumn(params.numeric_column);
                                const categoricalColumn = findCategoricalColumn(params.categorical_column);

                                if (numericColumn && categoricalColumn) {
                                    const groupedAverages = {};
                                    const counts = {};

                                    rawData.forEach(row => {
                                        const category = row[categoricalColumn];
                                        const numericValue = Number(row[numericColumn]);

                                        if (category !== undefined && category !== null && category !== '' && !isNaN(numericValue)) {
                                            if (!groupedAverages[category]) {
                                                groupedAverages[category] = 0;
                                                counts[category] = 0;
                                            }
                                            groupedAverages[category] += numericValue;
                                            counts[category]++;
                                        }
                                    });

                                    let resultsHtml = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                    for (const category in groupedAverages) {
                                        const avg = counts[category] > 0 ? (groupedAverages[category] / counts[category]).toFixed(2) : 'N/A';
                                        resultsHtml += `<li><strong>${category}</strong>: Average ${numericColumn} is <strong>${avg}</strong> (${counts[category]} entries)</li>`;
                                    }
                                    resultsHtml += `</ul>`;
                                    aiResponseText = `Here's the **average of "${numericColumn}" grouped by "${categoricalColumn}"**:`;
                                    analysisContent = resultsHtml;
                                } else {
                                    aiResponseText = `I need both a valid numeric column and a valid categorical column to perform that aggregation. Please check your column names and types.`;
                                }
                                break;
                            }
                            case 'get_correlation': {
                                if (!params.column_name || !params.column_name_2) {
                                    aiResponseText = `To calculate correlation, I need two column names. Example: 'correlation between age and income'.`;
                                    break;
                                }
                                const col1 = findNumericColumn(params.column_name);
                                const col2 = findNumericColumn(params.column_name_2);

                                if (col1 && col2) {
                                    const correlation = calculateCorrelation(col1, col2, rawData);
                                    if (correlation !== null) {
                                        let interpretation = '';
                                        if (correlation >= 0.7) interpretation = 'a **strong positive correlation**';
                                        else if (correlation >= 0.3) interpretation = 'a **moderate positive correlation**';
                                        else if (correlation > -0.3 && correlation < 0.3) interpretation = 'a **very weak or no linear correlation**';
                                        else if (correlation > -0.7) interpretation = 'a **moderate negative correlation**';
                                        else interpretation = 'a **strong negative correlation**';
                                        aiResponseText = `The **Pearson correlation coefficient** between "<strong>${col1}</strong>" and "<strong>${col2}</strong>" is: <strong>${correlation.toFixed(4)}</strong>. This indicates ${interpretation}.`;
                                    } else {
                                        aiResponseText = `I couldn't calculate the correlation between "<strong>${col1}</strong>" and "<strong>${col2}</strong>" due to insufficient or invalid numeric data.`;
                                    }
                                } else {
                                    aiResponseText = `I need two valid numeric columns. Please check your column names and types.`;
                                }
                                break;
                            }
                            case 'find_outliers': {
                                if (!params.column_name) {
                                    aiResponseText = `I need a column name to find outliers. Example: 'find outliers in sales'.`;
                                    break;
                                }
                                const foundColumn = findNumericColumn(params.column_name);
                                if (foundColumn) {
                                    const { outliers, lowerBound, upperBound } = findOutliers(foundColumn, rawData);
                                    if (outliers.length > 0) {
                                        aiResponseText = `I found **${outliers.length} potential outliers** in the column "<strong>${foundColumn}</strong>".<br>
                                            These values fall outside the IQR bounds of <strong>${lowerBound}</strong> and <strong>${upperBound}</strong>.<br>
                                            Outlier values (first 10): <strong>${outliers.slice(0, 10).join(', ')}</strong>.`;
                                    } else {
                                        aiResponseText = `No significant outliers were detected in the column "<strong>${foundColumn}</strong>" based on the IQR method.`;
                                    }
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to find outliers. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'filter_data': {
                                if (!params.column_name || !params.operator || params.value === undefined) {
                                    aiResponseText = `To filter data, I need a column name, an operator (e.g., '>', '='), and a value. Example: 'filter where sales > 1000'.`;
                                    break;
                                }
                                const foundColumn = findColumnByName(params.column_name);
                                if (foundColumn) {
                                    let filteredData = [];
                                    let parsedValue;

                                    if (schema[foundColumn] === 'number') {
                                        parsedValue = Number(params.value); // Convert to number
                                        if (isNaN(parsedValue)) {
                                            aiResponseText = `The value "${params.value}" for numeric column "${foundColumn}" isn't a valid number. Please provide a numeric value for filtering.`;
                                            break;
                                        }
                                        filteredData = rawData.filter(row => {
                                            const cellValue = Number(row[foundColumn]);
                                            if (isNaN(cellValue)) return false; // Skip rows with invalid numeric values
                                            switch (params.operator) {
                                                case '>': return cellValue > parsedValue;
                                                case '<': return cellValue < parsedValue;
                                                case '>=': return cellValue >= parsedValue;
                                                case '<=': return cellValue <= parsedValue;
                                                case '=': return cellValue === parsedValue;
                                                case '!=': return cellValue !== parsedValue;
                                                default: return false;
                                            }
                                        });
                                    } else { // string or other types
                                        // Attempt to parse date if column looks like a date column
                                        const isDateColumn = ['date', 'order date', 'transaction date', 'activity date', 'ship date'].some(keyword => foundColumn.toLowerCase().includes(keyword));
                                        if (isDateColumn) {
                                            const targetDate = parseDate(String(params.value));
                                            if (!targetDate) {
                                                aiResponseText = `The date value "${params.value}" for filtering column "${foundColumn}" is not in a recognizable format. Please use a common date format like YYYY-MM-DD or MM/DD/YYYY.`;
                                                break;
                                            }
                                            filteredData = rawData.filter(row => {
                                                const rowDate = parseDate(row[foundColumn]);
                                                if (!rowDate) return false;
                                                // Compare dates only by day, month, and year (ignoring time)
                                                const rowDateStr = rowDate.toDateString();
                                                const targetDateStr = targetDate.toDateString();

                                                switch (params.operator) {
                                                    case '=': return rowDateStr === targetDateStr;
                                                    case '!=': return rowDateStr !== targetDateStr;
                                                    // For date ranges, more complex logic (e.g., using getTime()) would be needed.
                                                    // This basic filter only supports exact/inexact matches for dates.
                                                    default: return false; // Other operators not supported for basic date string comparison
                                                }
                                            });
                                        } else {
                                            // Regular string comparison for non-date string columns
                                            parsedValue = String(params.value).toLowerCase();
                                            filteredData = rawData.filter(row => {
                                                const cellValue = (row[foundColumn] || '').toLowerCase();
                                                switch (params.operator) {
                                                    case '=': return cellValue === parsedValue;
                                                    case '!=': return cellValue !== parsedValue;
                                                    default: return false;
                                                }
                                            });
                                        }
                                    }
                                    analysisContent = `<p class="text-gray-300 mt-2">I found <strong>${filteredData.length} rows</strong> that match your condition where **${foundColumn} ${params.operator} ${params.value}**.</p>
                                                        <p class="text-sm text-gray-400 mt-2">Here's a preview of the first 5 matching entries (remember, all processing is client-side!):</p>
                                                        <div class="code-block mt-2">${filteredData.slice(0, 5).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>`;
                                    aiResponseText = `Filtering complete! I've processed your data based on the condition "${foundColumn} ${params.operator} ${params.value}". Here's the summary:`;
                                } else {
                                    aiResponseText = `I couldn't filter data. Please ensure you provide a valid column, operator (e.g., '>', '='), and value.`;
                                }
                                break;
                            }
                            case 'add_calculated_column': {
                                if (!params.new_column_name || !params.column_name || !params.column_name_2 || !params.operator) {
                                    aiResponseText = `To add a calculated column, I need a new column name, two numeric columns to operate on, and an operator ('plus', 'minus', 'times', 'divided by'). Example: 'add column profit as revenue minus cost'.`;
                                    break;
                                }
                                const newColName = params.new_column_name.replace(/\s/g, '_'); // Replace spaces for new column name
                                const col1 = findNumericColumn(params.column_name);
                                const col2 = findNumericColumn(params.column_name_2);
                                const operatorWord = params.operator;

                                if (col1 && col2) {
                                    let operatorSymbol = '';
                                    switch (operatorWord.toLowerCase()) {
                                        case 'plus': operatorSymbol = '+'; break;
                                        case 'minus': operatorSymbol = '-'; break;
                                        case 'times': operatorSymbol = '*'; break;
                                        case 'divided by': operatorSymbol = '/'; break;
                                        default: operatorSymbol = '';
                                    }

                                    if (operatorSymbol) {
                                        // Ensure the new column name does not clash with existing ones (case-insensitive)
                                        if (Object.keys(schema).some(c => c.toLowerCase() === newColName.toLowerCase())) {
                                            aiResponseText = `A column named "<strong>${newColName}</strong>" already exists (case-insensitive). Please choose a different name for your new column.`;
                                            break;
                                        }

                                        rawData = rawData.map(row => {
                                            const val1 = Number(row[col1]);
                                            const val2 = Number(row[col2]);
                                            let result;

                                            // Only perform calculation if both values are valid numbers
                                            if (!isNaN(val1) && !isNaN(val2)) {
                                                if (operatorSymbol === '+') result = val1 + val2;
                                                else if (operatorSymbol === '-') result = val1 - val2;
                                                else if (operatorSymbol === '*') result = val1 * val2;
                                                else if (operatorSymbol === '/') result = val2 !== 0 ? val1 / val2 : 0; // Avoid division by zero
                                            } else {
                                                result = null; // Set to null or undefined if input is invalid
                                            }
                                            return { ...row, [newColName]: result !== null ? result.toFixed(2) : '' }; // Store as fixed decimal string or empty
                                        });
                                        schema[newColName] = 'number'; // New column is numeric
                                        displaySchema(schema); // Update schema display
                                        aiResponseText = `I've successfully added a new column named "<strong>${newColName}</strong>" to your dataset. It calculates "${col1} ${operatorWord} ${col2}". Your schema has been updated!`;
                                    } else {
                                        aiResponseText = `I couldn't understand the operator "${operatorWord}". Please use 'plus', 'minus', 'times', or 'divided by'.`;
                                    }
                                } else {
                                    aiResponseText = `To add a calculated column, I need two valid numeric columns. Please check your column names and types.`;
                                }
                                break;
                            }
                            case 'categorize_column': {
                                if (!params.column_name || !params.num_bins || !params.new_column_name) {
                                    aiResponseText = `To categorize a column, I need the numeric column to categorize, the number of bins, and a new column name for the categories. Example: 'categorize age into 5 bins as age_group'.`;
                                    break;
                                }
                                const numericColumn = findNumericColumn(params.column_name);
                                const numBins = params.num_bins;
                                const newColName = params.new_column_name;

                                // Basic validation for numBins
                                if (typeof numBins !== 'number' || numBins <= 0 || !Number.isInteger(numBins)) {
                                    aiResponseText = `The number of bins must be a positive integer. Please provide a valid number.`;
                                    break;
                                }

                                if (numericColumn) {
                                    const result = categorizeNumericColumn(numericColumn, numBins, newColName, rawData);
                                    aiResponseText = result.message;
                                } else {
                                    aiResponseText = `I couldn't find a numeric column matching "<strong>${params.column_name}</strong>" to categorize. Please specify a valid numeric column.`;
                                }
                                break;
                            }
                            case 'remove_duplicates': {
                                const result = removeDuplicateRows(rawData);
                                if (result.success) {
                                    aiResponseText = `Successfully removed <strong>${result.removedCount} duplicate row(s)</strong> from your dataset. Total rows now: <strong>${rawData.length}</strong>.`;
                                } else {
                                    aiResponseText = `An error occurred while trying to remove duplicate rows.`;
                                }
                                break;
                            }
                            case 'rename_column': {
                                if (!params.old_column_name || !params.new_column_name) {
                                    aiResponseText = `To rename a column, I need both the old and new column names. Example: 'rename product_id to sku'.`;
                                    break;
                                }
                                const oldName = params.old_column_name;
                                const newName = params.new_column_name;
                                const result = renameColumn(oldName, newName);
                                aiResponseText = result.message;
                                break;
                            }
                            case 'summarize_by_category': {
                                if (!params.numeric_column || !params.categorical_column) {
                                    aiResponseText = `To summarize by category, I need both a numeric column and a categorical column. Example: 'summarize sales by region'.`;
                                    break;
                                }
                                const numericColumn = findNumericColumn(params.numeric_column);
                                const categoricalColumn = findCategoricalColumn(params.categorical_column);

                                if (numericColumn && categoricalColumn) {
                                    const groupedStats = {};
                                    rawData.forEach(row => {
                                        const category = row[categoricalColumn];
                                        const value = Number(row[numericColumn]);

                                        if (category !== undefined && category !== null && category !== '' && !isNaN(value)) {
                                            if (!groupedStats[category]) {
                                                groupedStats[category] = { sum: 0, count: 0, min: Infinity, max: -Infinity };
                                            }
                                            groupedStats[category].sum += value;
                                            groupedStats[category].count++;
                                            if (value < groupedStats[category].min) groupedStats[category].min = value;
                                            if (value > groupedStats[category].max) groupedStats[category].max = value;
                                        }
                                    });

                                    let resultsHtml = `<p class="text-gray-300">Summary of <strong>${numericColumn}</strong> by <strong>${categoricalColumn}</strong>:</p>
                                                        <ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                                    for (const category in groupedStats) {
                                        const stats = groupedStats[category];
                                        const avg = stats.count > 0 ? (stats.sum / stats.count).toFixed(2) : 'N/A';
                                        resultsHtml += `<li><strong>${category}</strong>: <br>
                                                            &nbsp;&nbsp;Entries: ${stats.count}, <br>
                                                            &nbsp;&nbsp;Average ${numericColumn}: ${avg}, <br>
                                                            &nbsp;&nbsp;Min ${numericColumn}: ${stats.count > 0 ? stats.min.toFixed(2) : 'N/A'}, <br>
                                                            &nbsp;&nbsp;Max ${numericColumn}: ${stats.count > 0 ? stats.max.toFixed(2) : 'N/A'}
                                                        </li>`;
                                    }
                                    resultsHtml += `</ul>`;
                                    aiResponseText = `Here's a detailed summary:`;
                                    analysisContent = resultsHtml;
                                } else {
                                    aiResponseText = `To summarize, I need a valid numeric column and a valid categorical column. Please check your column names and types.`;
                                }
                                break;
                            }
                            case 'get_business_overview': {
                                let overviewText = `<p class="text-gray-300 leading-relaxed mb-3">Here's a high-level overview of your dataset's key business metrics:</p>`;

                                const numericColumns = Object.keys(schema).filter(col => schema[col] === 'number');
                                if (numericColumns.length > 0) {
                                    overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Key Numeric Metrics:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                                    numericColumns.forEach(col => {
                                        const stats = getDescriptiveStats(col, rawData);
                                        if (stats && stats.count > 0) {
                                            overviewText += `<li><strong>${col}</strong>:<br>
                                                                &nbsp;&nbsp;Total Sum: ${stats.sum.toFixed(2)}<br>
                                                                &nbsp;&nbsp;Average: ${stats.mean.toFixed(2)}<br>
                                                                &nbsp;&nbsp;Min: ${stats.min.toFixed(2)}<br>
                                                                &nbsp;&nbsp;Max: ${stats.max.toFixed(2)}
                                                            </li>`;
                                        } else {
                                            overviewText += `<li><strong>${col}</strong>: No valid numeric data.</li>`;
                                        }
                                    });
                                    overviewText += `</ul>`;
                                } else {
                                    overviewText += `<p class="text-gray-400">No numeric columns found for quantitative overview.</p>`;
                                }

                                const stringColumns = Object.keys(schema).filter(col => schema[col] === 'string');
                                if (stringColumns.length > 0) {
                                    overviewText += `<h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Categorical Insights:</h5><ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;
                                    stringColumns.forEach(col => {
                                        const values = rawData.map(row => row[col]);
                                        const uniqueCount = new Set(values).size;
                                        const valueCounts = {};
                                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                        const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                                        overviewText += `<li><strong>${col}</strong>: ${uniqueCount} unique values. Top 3: ${sortedCounts.slice(0,3).map(item => `${item[0]} (${item[1]} occurrences)`).join(', ')}.</li>`;
                                    });
                                    overviewText += `</ul>`;
                                } else {
                                    overviewText += `<p class="text-gray-400">No string/categorical columns found for qualitative overview.</p>`;
                                }
                                analysisContent = overviewText;
                                aiResponseText = `Here's your overall business overview:`;
                                break;
                            }
                            case 'create_bar_chart': {
                                if (!params.numeric_column || !params.categorical_column) {
                                    aiResponseText = `To create a bar chart, I need a numeric column to aggregate and a categorical column to group by. Example: 'bar chart of sales by region as average'.`;
                                    break;
                                }
                                const numericColumn = findNumericColumn(params.numeric_column);
                                const categoricalColumn = findCategoricalColumn(params.categorical_column);
                                const aggregateType = params.aggregate_type || 'sum'; // Default to sum

                                if (numericColumn && categoricalColumn) {
                                    const aggregated = groupByAndAggregate(rawData, categoricalColumn, numericColumn, aggregateType);
                                    if (aggregated.labels.length > 0) {
                                        createChart('bar', `${aggregateType === 'average' ? 'Average' : 'Sum'} of ${numericColumn} by ${categoricalColumn}`,
                                                     aggregated.labels, aggregated.data,
                                                     categoricalColumn, `${aggregateType} of ${numericColumn}`);
                                        return; // Exit as chart is handled
                                    } else {
                                        aiResponseText = `No valid data to create a bar chart for "${numericColumn}" by "${categoricalColumn}".`;
                                    }
                                } else {
                                    aiResponseText = `To create that bar chart, I need a valid numeric column and a valid categorical column. Please check your column names.`;
                                }
                                break;
                            }
                            case 'create_line_chart': {
                                if (!params.x_column || !params.y_column) {
                                    aiResponseText = `To create a line chart, I need an X-axis column and a Y-axis numeric column. Example: 'line chart with x as date and y as stock price'.`;
                                    break;
                                }
                                const xColumn = findColumnByName(params.x_column);
                                const yColumn = findNumericColumn(params.y_column);

                                if (xColumn && yColumn) {
                                    // Filter out rows where yColumn is not a valid number
                                    const validDataPoints = rawData.filter(row => !isNaN(Number(row[yColumn])));
                                    if (validDataPoints.length === 0) {
                                        aiResponseText = `No valid numeric data in "${yColumn}" to create a line chart.`;
                                        break;
                                    }
                                    const labels = validDataPoints.map(row => row[xColumn]);
                                    const data = validDataPoints.map(row => Number(row[yColumn]));

                                    createChart('line', `${yColumn} over ${xColumn}`, labels, data, xColumn, yColumn);
                                    return; // Exit as chart is handled
                                } else {
                                    aiResponseText = `To create that line chart, I need a valid X-axis column and a valid numeric Y-axis column.`;
                                }
                                break;
                            }
                            case 'create_scatter_plot': {
                                if (!params.x_column || !params.y_column) {
                                    aiResponseText = `To create a scatter plot, I need two numeric columns (one for X and one for Y). Example: 'scatter plot with x as age and y as income'.`;
                                    break;
                                }
                                const xColumn = findNumericColumn(params.x_column);
                                const yColumn = findNumericColumn(params.y_column);

                                if (xColumn && yColumn) {
                                    const scatterData = rawData.map(row => ({
                                        x: Number(row[xColumn]),
                                        y: Number(row[yColumn])
                                    })).filter(point => !isNaN(point.x) && !isNaN(point.y)); // Filter out invalid points

                                    if (scatterData.length === 0) {
                                        aiResponseText = `No valid numeric data in "${xColumn}" and "${yColumn}" to create a scatter plot.`;
                                        break;
                                    }

                                    createChart('scatter', `${yColumn} vs ${xColumn}`, [], scatterData, xColumn, yColumn, {
                                        scales: {
                                            x: { type: 'linear', position: 'bottom', ticks: { color: '#a0aec0' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                                            y: { type: 'linear', ticks: { color: '#a0aec0' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                                        },
                                        elements: { point: { radius: 3, backgroundColor: 'rgba(66, 153, 225, 0.8)' } } // Customize points
                                    });
                                    return; // Exit as chart is handled
                                } else {
                                    aiResponseText = `I need two valid numeric columns to create a scatter plot.`;
                                }
                                break;
                            }
                            case 'create_pie_chart':
                            case 'create_doughnut_chart':
                            case 'create_polar_area_chart': {
                                const chartType = intent.replace('create_', '').replace('_chart', '').replace(/_/g, ' ');
                                let labels, data, chartTitle;

                                // Prioritize aggregation if both numeric and categorical columns are provided
                                if (params.numeric_column && params.categorical_column) {
                                    const numericColumn = findNumericColumn(params.numeric_column);
                                    const categoricalColumn = findCategoricalColumn(params.categorical_column);
                                    const aggregateType = params.aggregate_type || 'sum';

                                    if (numericColumn && categoricalColumn) {
                                        const aggregated = groupByAndAggregate(rawData, categoricalColumn, numericColumn, aggregateType);
                                        if (aggregated.labels.length > 0) {
                                            labels = aggregated.labels;
                                            data = aggregated.data;
                                            chartTitle = `${aggregateType === 'average' ? 'Average' : 'Sum'} of ${numericColumn} by ${categoricalColumn}`;
                                        } else {
                                            aiResponseText = `No valid data to create a ${chartType} chart for "${numericColumn}" by "${categoricalColumn}".`;
                                            break;
                                        }
                                    } else {
                                        aiResponseText = `For a ${chartType} chart with aggregation, I need a valid numeric column and a valid categorical column.`;
                                        break;
                                    }
                                } else if (params.column_name) { // Fallback to frequency if only one column name is given
                                    const primaryColumn = findColumnByName(params.column_name);
                                    if (primaryColumn) {
                                        const values = rawData.map(row => row[primaryColumn]).filter(v => v !== undefined && v !== null && v !== ''); // Filter out empty
                                        if (values.length === 0) {
                                            aiResponseText = `No valid data in "${primaryColumn}" to create a ${chartType} chart.`;
                                            break;
                                        }
                                        const valueCounts = {};
                                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                                        labels = Object.keys(valueCounts);
                                        data = Object.values(valueCounts);
                                        chartTitle = `Frequency of ${primaryColumn}`;
                                    } else {
                                        aiResponseText = `I couldn't find the column matching "<strong>${params.column_name}</strong>" to create that chart.`;
                                        break;
                                    }
                                } else {
                                    aiResponseText = `To create a ${chartType} chart, please provide a column for frequency analysis, or a numeric column and a categorical column for aggregation.`;
                                    break;
                                }
                                createChart(chartType.replace(' ', ''), chartTitle, labels, data);
                                return; // Exit as chart is handled
                            }
                            case 'perform_linear_regression': {
                                if (!params.y_column || !params.x_column) {
                                    aiResponseText = `To perform linear regression, I need a Y-axis numeric column and an X-axis numeric column. Example: 'perform regression with Y as Sales and X as Advertising'.`;
                                    break;
                                }
                                const yCol = findNumericColumn(params.y_column);
                                const xCol = findNumericColumn(params.x_column);

                                if (xCol && yCol) {
                                    const regressionResults = performLinearRegression(xCol, yCol, rawData);
                                    if (regressionResults !== null) {
                                        aiResponseText = `**Simple Linear Regression Results** (${yCol} ~ ${xCol}):<br>
                                            - **Slope (Coefficient for ${xCol})**: <strong>${regressionResults.slope}</strong><br>
                                            - **Y-intercept**: <strong>${regressionResults.intercept}</strong><br>
                                            - **R-squared**: <strong>${regressionResults.rSquared}</strong> (This indicates how much of the variation in ${yCol} can be explained by ${xCol}. A value closer to 1 is better).`;
                                    } else {
                                        aiResponseText = `I couldn't perform linear regression between "<strong>${yCol}</strong>" and "<strong>${xCol}</strong>" due to insufficient or invalid numeric data. Please ensure both columns contain at least two valid numeric entries.`;
                                    }
                                } else {
                                    aiResponseText = `I need two valid numeric columns (one for Y, one for X).`;
                                }
                                break;
                            }
                            case 'show_command_guide':
                                commandGuideOverlay.classList.remove('hidden');
                                commandGuideContent.innerHTML = getCommandListHtml();
                                toggleCommandGuideText.textContent = 'Hide Command Guide';
                                toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
                                return; // Don't append another AI message, the overlay handles it
                            case 'get_proactive_insights':
                                generateProactiveInsights(); // Re-generate insights (they are stored in lastProactiveInsights)
                                renderProactiveInsights(); // Render them with current filters (default to all, no search)
                                proactiveInsightsOverlay.classList.remove('hidden'); // Show the overlay
                                return; // Don't append an AI message to chat, the overlay handles it
                            case 'unrecognized_command':
                            default:
                                aiResponseText = `I'm sorry, I didn't understand that command. Please refer to the command list by typing 'show command guide' for examples, or try rephrasing your request.`;
                                break;
                        }
                    } else {
                        aiResponseText = `I encountered an issue processing your request through NLU. The response format was unexpected or empty. Please try again or rephrase.`;
                    }
                } catch (error) {
                    hideLoadingIndicator(); // Hide loading indicator on error
                    console.error("Error during NLU processing or command execution:", error);
                    // Provide a more user-friendly message for internal errors
                    aiResponseText = `An unexpected internal error occurred: "${error.message}". This might be a temporary issue with the AI's response. Please try again.`;
                }
                // This general appendMessage is now only called for non-chart intents, or if there was an error.
                if (aiResponseText || analysisContent) { // Only append if there's content to add
                    appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
                }
            }

            // Handle sending messages when the Send button is clicked
            sendMessageBtn.addEventListener('click', () => {
                const query = chatInput.value.trim();
                if (query) {
                    appendMessage('You', query, 'user');
                    chatInput.value = ''; // Clear input field

                    // Shrink header if not already shrunk when first message is sent
                    if (!isHeaderShrunk) {
                        headerContainer.classList.add('header-shrunk');
                        isHeaderShrunk = true;
                    }

                    simulateAIResponse(query); // Process the user's query
                }
            });

            // Handle sending messages when Enter key is pressed in the input field
            chatInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    sendMessageBtn.click(); // Trigger the send button click
                }
            });

            // Event listeners for filter buttons in proactive insights overlay
            filterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove 'active' styling from all filter buttons
                    filterButtons.forEach(btn => {
                        btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                        btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                    });

                    // Add 'active' styling to the clicked button
                    button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                    button.classList.add('bg-blue-600', 'hover:bg-blue-700');

                    const filterType = button.dataset.filter; // Get the filter type from data-filter attribute
                    const searchTerm = insightSearchInput.value.trim();
                    renderProactiveInsights(filterType, searchTerm); // Re-render insights with new filter
                });
            });

            // Event listener for search input in proactive insights overlay
            insightSearchInput.addEventListener('input', () => {
                // Determine the currently active filter button
                const activeFilterButton = document.querySelector('.filter-btn.bg-blue-600');
                const filterType = activeFilterButton ? activeFilterButton.dataset.filter : 'all'; // Default to 'all' if no filter active
                const searchTerm = insightSearchInput.value.trim();
                renderProactiveInsights(filterType, searchTerm); // Re-render insights with new search term
            });

            // Initial setup for command guide toggle button: ensure it shows "Show Command Guide"
            toggleCommandGuideText.textContent = 'Show Command Guide';
            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';

            // Initial schema display (will show placeholder if no data is loaded yet)
            displaySchema(schema);

            // --- File Management Collapsible Logic ---
            fileManagementHeader.addEventListener('click', () => {
                const isCollapsed = fileManagementContent.classList.contains('show');
                if (isCollapsed) {
                    fileManagementContent.classList.remove('show');
                    fileManagementChevron.classList.remove('rotate-180');
                } else {
                    fileManagementContent.classList.add('show');
                    fileManagementChevron.classList.add('rotate-180');
                }
            });

            // Ensure initial state is expanded as per the HTML
            fileManagementContent.classList.add('show');
            fileManagementChevron.classList.add('rotate-180');

        });
    </script>
</body>
</html>
