<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoDA: Cognitive Data Assistant Prototype</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter (for body) & Roboto Mono (for code) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:400;500;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js CDN for graphing - UPDATED to a specific v4.x version to avoid 'extend' errors from deprecated methods -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%); /* Darker, professional gradient */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
            padding: 0; /* Remove padding to allow app to go truly full screen */
            overflow: hidden; /* Prevent scrollbar from background animation */
            position: relative;
        }

        /* Subtle background animation - Darker bubbles */
        .background-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }

        .bubble:nth-child(1) { width: 80px; height: 80px; left: 15%; top: 10%; animation-duration: 22s; opacity: 0.05; }
        .bubble:nth-child(2) { width: 120px; height: 120px; left: 35%; top: 80%; animation-duration: 25s; opacity: 0.04; }
        .bubble:nth-child(3) { width: 90px; height: 90px; left: 70%; top: 15%; animation-duration: 19s; opacity: 0.06; }
        .bubble:nth-child(4) { width: 140px; height: 140px; left: 90%; top: 50%; animation-duration: 28s; opacity: 0.03; }
        .bubble:nth-child(5) { width: 70px; height: 70px; left: 5%; top: 60%; animation-duration: 21s; opacity: 0.07; }
        .bubble:nth-child(6) { width: 100px; height: 100px; left: 50%; top: 30%; animation-duration: 23s; opacity: 0.05; }

        @keyframes bubble-flow {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(70px, -70px) scale(1.1); }
            100% { transform: translate(0, 0) scale(1); }
        }

        /* Custom scrollbar for chat and results */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4a5568; /* Medium grey thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Lighter grey on hover */
        }

        /* Animation for new messages */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-message {
            animation: fadeIn 0.3s ease-out forwards;
        }

        /* Gradient for AI avatar */
        .ai-avatar-gradient {
            background: linear-gradient(45deg, #4299e1, #3182ce); /* Techy blue gradient */
        }

        /* Gradient for Send button */
        .send-button-gradient {
            background: linear-gradient(90deg, #4299e1, #3182ce); /* Techy blue gradient */
            transition: all 0.3s ease-in-out;
        }
        .send-button-gradient:hover {
            background: linear-gradient(90deg, #3182ce, #4299e1); /* Reverse gradient on hover */
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 15px rgba(66, 153, 225, 0.4);
        }
        .send-button-gradient:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 5px rgba(66, 153, 225, 0.2);
        }

        /* Code block styling - Now just for displaying JSON/raw data if needed, not explanations */
        .code-block {
            background-color: #2d3748; /* Dark code background */
            border-left: 4px solid #4299e1; /* Techy blue left border */
            padding: 1rem;
            border-radius: 0.75rem;
            font-family: 'Roboto Mono', monospace; /* Techy monospace font */
            color: #edf2f7; /* Light text for dark background */
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break words for very long lines */
            overflow-x: auto;
            max-height: 200px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); /* Inner shadow for depth */
        }

        /* Input field focus glow */
        input:focus {
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.6); /* Blue glow */
            border-color: #4299e1;
        }

        /* Chart Canvas Styling */
        .chart-container {
            position: relative;
            height: 300px; /* Fixed height for consistency */
            width: 100%;
            margin-top: 1.5rem;
            background-color: #1a202c; /* Dark background for charts */
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: column;
        }
        .chart-container canvas {
            max-height: 100%;
            max-width: 100%;
        }

        /* Table specific styles for the command list and data preview */
        .data-table, .command-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
            text-align: left;
        }
        .data-table th, .data-table td,
        .command-table th, .command-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #4a5568; /* Slightly lighter border for table rows */
        }
        .data-table th, .command-table th {
            background-color: #2d3748; /* Darker header background */
            font-weight: 600;
            color: #a0aec0; /* Lighter text for headers */
            cursor: pointer; /* Indicate sortable headers */
            position: relative; /* For sort icons */
            padding-right: 25px; /* Space for sort icon */
        }
        .data-table tbody tr:hover, .command-table tbody tr:hover {
            background-color: #4a5568; /* Hover effect for rows */
        }
        .data-table tbody tr:last-child td, .command-table tbody tr:last-child td {
            border-bottom: none;
        }
        /* Sort icon styling */
        .data-table th .sort-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.7em;
            color: #718096;
        }
        .data-table th.sorted-asc .sort-icon {
            color: #4299e1;
        }
        .data-table th.sorted-desc .sort-icon {
            color: #4299e1;
        }

        /* Command Guide Specific Styles */
        .command-guide-intro {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #cbd5e0; /* text-gray-200 */
            margin-bottom: 1rem;
        }

        /* Updated Category Header Styling */
        .command-table .category-header {
            background-color: #3e4c5e; /* A muted, slightly lighter dark gray */
            color: #e2e8f0; /* Light text for blending */
            font-weight: 600; /* Slightly less bold */
            padding: 0.6rem 0.75rem; /* Adjusted padding for a tighter, modern feel */
            border-radius: 0.375rem; /* Slightly less rounded corners */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Softer shadow */
            margin-top: 0.75rem; /* Slightly reduced spacing */
            margin-bottom: 0.25rem; /* Reduced spacing below */
        }
        .command-table .category-header td {
            border-bottom: none; /* No border below category header */
            padding: 0.6rem 0.75rem; /* Apply padding to td within category header */
        }
        .command-table tbody tr td:first-child {
            font-weight: 500; /* Medium weight for Sr. No. */
            color: #a0aec0; /* Lighter grey for number */
        }
        .command-table code {
            background-color: #4a5568; /* Darker background for code snippets */
            color: #90cdf4; /* Light blue text for code */
            padding: 0.2rem 0.4rem;
            border-radius: 0.3rem;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.875rem; /* text-sm */
        }
        /* Search input specific styles for command guide */
        #commandSearchInput {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            transition: all 0.2s ease-in-out;
        }
        #commandSearchInput::placeholder {
            color: #a0aec0;
        }
        #commandSearchInput:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.4);
            outline: none;
        }


        /* Styles for shrunk header */
        .header-shrunk {
            padding-top: 1rem !important; /* Smaller top padding */
            padding-bottom: 0.5rem !important; /* Smaller bottom padding */
        }
        .header-shrunk #mainTitle {
            font-size: 1.5rem !important; /* Smaller title */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #subTitle {
            font-size: 0.875rem !important; /* Smaller subtitle (sm) */
            margin-bottom: 0.25rem !important;
        }
        .header-shrunk #createdBy {
            font-size: 0.75rem !important; /* Even smaller "Created by" (xs) */
            margin-bottom: 0.5rem !important;
        }
        .header-shrunk #toggleButtons {
            margin-bottom: 0rem !important; /* No bottom margin */
            /* justify-content: flex-start !important; This is already handled by the permanent change */
            flex-wrap: wrap; /* Allow wrapping if buttons get too long */
        }
        .header-shrunk #toggleButtons button {
            padding-top: 0.4rem !important;
            padding-bottom: 0.4rem !important;
            font-size: 0.8rem !important;
        }

        /* Proactive Insights Card Styling */
        .insight-card {
            background-color: #2d3748; /* Darker background for cards */
            border-radius: 1.5rem; /* More rounded corners */
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4); /* Deeper shadow */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 1px solid #4a5568; /* Subtle border */
        }
        .insight-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }

        .insight-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            color: #90cdf4; /* Light blue for headers */
        }
        .insight-header i {
            font-size: 1.8rem;
            margin-right: 0.8rem;
            color: #4299e1; /* Brighter blue icon */
        }
        .insight-header h4 {
            font-size: 1.3rem; /* Slightly larger heading */
            font-weight: 700; /* Bold heading */
        }

        .insight-message {
            color: #e2e8f0; /* Light text for message */
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .insight-action {
            display: inline-block;
            background-color: #4299e1; /* Blue background for action button */
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(66, 153, 225, 0.3);
        }
        .insight-action:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(66, 153, 225, 0.4);
        }

        /* Collapsible content styles */
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.show {
            max-height: 500px; /* Adjust as needed for content */
        }
    </style>
</head>
<body class="relative bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center h-screen w-screen">
    <!-- Background Bubbles Animation -->
    <div class="background-bubbles">
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
        <div class="bubble"></div>
    </div>

    <div id="main-container" class="relative z-10 flex flex-col md:flex-row bg-gray-900 text-gray-200 rounded-3xl shadow-2xl overflow-hidden w-full h-full transform transition-all duration-300 border border-gray-700">
        <!-- Left Pane: CSV Upload & Data Preview -->
        <!-- This pane is now conditionally hidden/shown by JavaScript, default hidden on md+ -->
        <div id="data-panel" class="p-8 flex-col border-r border-gray-700 bg-gray-800 rounded-l-3xl shadow-inner-dark overflow-y-auto custom-scrollbar hidden md:w-0 md:hidden">
            <h2 class="text-4xl font-extrabold text-blue-400 mb-2 text-center tracking-tight">CoDA <span class="text-blue-600">AI</span></h2>
            <p class="text-md text-gray-400 mb-2 text-center italic">Your Strategic Data Copilot</p>
            <p class="text-sm text-gray-500 mb-6 text-center">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

            <div class="mb-4 border-2 border-dashed border-blue-600 bg-gray-700 rounded-2xl p-4 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-600 transition duration-300 ease-in-out shadow-lg hover:shadow-xl">
                <label for="csvFileInput" class="cursor-pointer text-blue-300 hover:text-blue-100 font-bold text-base flex flex-col items-center justify-center">
                    <i class="fas fa-cloud-upload-alt text-4xl mb-2 text-blue-500"></i>
                    <span class="block text-lg">Upload CSV File</span>
                    <span class="block text-xs text-gray-400 mt-1">Click or drag & drop</span>
                </label>
                <input type="file" id="csvFileInput" accept=".csv" class="hidden">
                <p id="fileNameDisplay" class="mt-3 text-gray-300 text-sm font-medium"></p>
                <p id="uploadStatus" class="mt-1 text-xs font-semibold text-gray-300"></p>
            </div>

            <!-- New Download Button -->
            <button id="downloadCsvBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-base font-bold">
                <i class="fas fa-download"></i>
                <span>Download Modified CSV</span>
            </button>

            <!-- New Proactive Insights Button -->
            <button id="showProactiveInsightsBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-base font-bold">
                <i class="fas fa-lightbulb"></i>
                <span>Show Proactive Insights</span>
            </button>


            <h3 class="text-2xl font-bold text-gray-200 mb-4 border-b pb-2 border-gray-600 mt-8">Data Schema</h3>
            <div id="schemaDisplay" class="bg-gray-700 p-5 rounded-2xl flex-grow overflow-y-auto custom-scrollbar text-sm text-gray-300 shadow-lg border border-gray-600 min-h-[250px]">
                <p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>
            </div>
        </div>

        <!-- Right Pane: Conversational Interface & Results - Now takes full width on larger screens by default -->
        <div id="chat-panel" class="w-full flex flex-col bg-gray-900 rounded-3xl">
            <div id="headerContainer" class="px-8 pt-6 pb-2 transition-all duration-500 ease-in-out"> <!-- Condensed padding for header content -->
                <h2 class="text-4xl font-extrabold text-blue-400 mb-1 text-center tracking-tight" id="mainTitle">CoDA <span class="text-blue-600">AI</span></h2>
                <p class="text-md text-gray-400 mb-1 text-center italic" id="subTitle">Your Strategic Data Copilot</p>
                <p class="text-sm text-gray-500 mb-4 text-center" id="createdBy">Created by: <span class="font-semibold text-blue-300">Utkarsh Kumar</span></p>

                <!-- Toggle Buttons for Data Panel and Command Guide - Positioned together and left-aligned -->
                <div class="flex justify-start space-x-3 mb-2" id="toggleButtons">
                    <button id="toggleDataPanelBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out hidden md:flex items-center space-x-2">
                        <i class="fas fa-eye mr-2"></i> <span id="toggleButtonText">Show Data Panel</span>
                    </button>
                    <button id="toggleCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                        <i class="fas fa-book mr-2"></i> <span id="toggleCommandGuideText">Show Command Guide</span>
                    </button>
                </div>
            </div>

            <!-- Chat Area - Now takes up all available space -->
            <div id="chatArea" class="flex-grow bg-gray-800 px-6 py-6 rounded-2xl overflow-y-auto custom-scrollbar shadow-lg border border-gray-700 mx-8">
                <!-- Initial AI message -->
                <div class="flex items-start mb-4 fade-in-message">
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">Hello! Welcome to CoDA. Upload your CSV data to begin our private, client-side analysis. I'm ready to collaborate!</p>
                    </div>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="relative flex items-center space-x-3 px-8 pb-6 pt-4"> <!-- Adjusted padding for input area -->
                <input type="text" id="chatInput" placeholder="Ask CoDA a question about your data, e.g., 'Show me the average sales'..." class="flex-grow p-4 border border-gray-600 bg-gray-700 text-gray-200 rounded-full focus:outline-none focus:ring-4 focus:ring-blue-600 shadow-lg text-base transition duration-300 ease-in-out">
                <div id="suggestionsContainer" class="suggestions-container"></div> <!-- Suggestions container -->
                <button id="sendMessageBtn" class="send-button-gradient text-white p-4 rounded-full shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300">
                    <i class="fas fa-paper-plane text-xl"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Command Guide Overlay (hidden by default) -->
    <div id="commandGuideOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-3xl font-extrabold text-blue-400">CoDA AI Command Guide</h3>
            <button id="closeCommandGuideBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Guide</span>
            </button>
        </div>
        <!-- Search Input for Command Guide -->
        <input type="text" id="commandSearchInput" placeholder="Search commands..." class="mb-4">
        <div id="commandGuideContent" class="flex-grow text-gray-200">
            <!-- Command guide content will be inserted here -->
        </div>
    </div>

    <!-- Proactive Insights Overlay (hidden by default) -->
    <div id="proactiveInsightsOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 p-8 flex flex-col rounded-3xl z-50 hidden overflow-y-auto custom-scrollbar">
        <div class="flex justify-between items-center mb-6">
            <!-- Updated Proactive Insights Heading for better blending -->
            <h3 class="text-3xl font-extrabold text-blue-300 flex items-center">
                <i class="fas fa-brain text-blue-500 mr-3 text-4xl"></i>
                <span>CoDA's <span class="text-white">Proactive Insights</span></span>
            </h3>
            <button id="closeProactiveInsightsBtn" class="bg-gray-700 text-gray-200 px-4 py-2 rounded-full shadow-lg hover:bg-gray-600 transition duration-200 ease-in-out flex items-center space-x-2">
                <i class="fas fa-times mr-2"></i> <span>Close Insights</span>
            </button>
        </div>
        <!-- Search and Filter Controls -->
        <div class="mb-6 flex flex-wrap items-center gap-4">
            <input type="text" id="insightSearchInput" placeholder="Search insights..." class="flex-grow p-3 border border-gray-600 bg-gray-700 text-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-600 shadow-inner max-w-full md:max-w-xs">
            <div class="flex flex-wrap gap-2">
                <button class="filter-btn bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="all">All</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="anomaly"><i class="fas fa-exclamation-triangle mr-2"></i>Anomaly</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="trend"><i class="fas fa-chart-line mr-2"></i>Trend</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="correlation"><i class="fas fa-link mr-2"></i>Correlation</button>
                <button class="filter-btn bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded-xl text-sm font-semibold shadow-md transition-colors" data-filter="distribution"><i class="fas fa-chart-pie mr-2"></i>Distribution</button>
            </div>
        </div>
        <div id="proactiveInsightsContent" class="flex-grow text-gray-200">
            <!-- Proactive insights content will be inserted here -->
            <p class="text-gray-400 text-center py-4">No proactive insights available yet. Upload a CSV file to generate proactive insights.</p>
        </div>
    </div>


    <script>
        let rawData = []; // Stores the parsed CSV data
        let schema = {}; // Stores the column names and inferred types
        let pendingCleaningSuggestion = null; // Stores details of a pending cleaning action
        // myChart will no longer be a global holding a single chart, as each chart will be independent
        // let myChart = null;
        let lastProactiveInsights = []; // Store last generated insights as an array of objects
        let currentSortColumn = null; // Stores the currently sorted column
        let currentSortDirection = 'asc'; // 'asc' or 'desc'

        // Autocomplete elements
        const suggestionsContainer = document.getElementById('suggestionsContainer');

        // References to DOM elements (moved up for scope)
        const chatArea = document.getElementById('chatArea');
        const chatInput = document.getElementById('chatInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const csvFileInput = document.getElementById('csvFileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const uploadStatus = document.getElementById('uploadStatus');
        const schemaDisplay = document.getElementById('schemaDisplay');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const toggleDataPanelBtn = document.getElementById('toggleDataPanelBtn');
        const dataPanel = document.getElementById('data-panel');
        const chatPanel = document.getElementById('chat-panel');
        const toggleButtonText = document.getElementById('toggleButtonText');
        const toggleCommandGuideBtn = document.getElementById('toggleCommandGuideBtn');
        const commandGuideOverlay = document.getElementById('commandGuideOverlay');
        const commandGuideContent = document.getElementById('commandGuideContent');
        const commandSearchInput = document.getElementById('commandSearchInput'); // Added reference
        const closeCommandGuideBtn = document.getElementById('closeCommandGuideBtn');
        const toggleCommandGuideText = document.getElementById('toggleCommandGuideText');
        const headerContainer = document.getElementById('headerContainer');
        const showProactiveInsightsBtn = document.getElementById('showProactiveInsightsBtn');
        const proactiveInsightsOverlay = document.getElementById('proactiveInsightsOverlay');
        const proactiveInsightsContent = document.getElementById('proactiveInsightsContent');
        const closeProactiveInsightsBtn = document.getElementById('closeProactiveInsightsBtn');
        const insightSearchInput = document.getElementById('insightSearchInput');
        const filterButtons = document.querySelectorAll('.filter-btn');

        let isHeaderShrunk = false; // New flag to track header state


        // Function to parse CSV data
        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== ''); // Filter out empty lines
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(header => header.trim().replace(/"/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(value => value.trim().replace(/"/g, ''));
                if (values.length === headers.length) { // Ensure row has correct number of columns
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
            }
            return data;
        }

        // Function to infer schema (basic type inference)
        function inferSchema(data) {
            if (data.length === 0) return {};
            const inferredSchema = {};
            const sampleRow = data[0];

            for (const key in sampleRow) {
                let type = 'string';
                // Very basic type inference: check if all values in column can be parsed as numbers
                const isNumeric = data.every(row => {
                    const value = row[key];
                    return value === '' || !isNaN(Number(value)); // Empty string or parseable as number
                });

                if (isNumeric) {
                    type = 'number';
                }
                inferredSchema[key] = type;
            }
            return inferredSchema;
        }

        // Function to display schema in the UI
        function displaySchema(schema) {
            schemaDisplay.innerHTML = '';
            if (Object.keys(schema).length === 0) {
                schemaDisplay.innerHTML = '<p class="text-gray-400 text-center py-4">Upload a CSV to intelligently infer and display its schema here.</p>';
                return;
            }
            const ul = document.createElement('ul');
            ul.className = 'list-disc list-inside space-y-3'; // Added space-y for better spacing
            for (const key in schema) {
                const li = document.createElement('li');
                li.className = 'mb-1 text-gray-300';
                li.innerHTML = `<span class="font-bold text-blue-400">${key}</span>: <span class="text-blue-300 font-medium">${schema[key]}</span>`;
                ul.appendChild(li);
            }
            schemaDisplay.appendChild(ul);
        }

        // Helper function to calculate average of a numeric column
        function calculateColumnAverage(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            const sum = numericValues.reduce((acc, val) => acc + val, 0);
            return sum / numericValues.length;
        }

        // Helper function to calculate sum of a numeric column
        function calculateColumnSum(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return 0;
            return numericValues.reduce((acc, val) => acc + val, 0);
        }

        // Helper function to find min/max of a numeric column
        function calculateColumnMinMax(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return { min: null, max: null };
            return { min: Math.min(...numericValues), max: Math.max(...numericValues) };
        }

        // Helper to calculate median
        function calculateMedian(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return null;
            const mid = Math.floor(numericValues.length / 2);
            return numericValues.length % 2 === 0 ? (numericValues[mid - 1] + numericValues[mid]) / 2 : numericValues[mid];
        }

        // Helper to calculate standard deviation
        function calculateStandardDeviation(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length < 2) return null;
            const mean = calculateColumnAverage(columnName, data);
            const sumOfSquares = numericValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0);
            return Math.sqrt(sumOfSquares / (numericValues.length - 1)); // Sample standard deviation
        }

        // Helper to calculate quartiles (Q1, Median, Q3, IQR)
        function calculateQuartiles(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { q1: null, median: null, q3: null, iqr: null };

            const getMedian = arr => {
                const mid = Math.floor(arr.length / 2);
                return arr.length % 2 === 0 ? (arr[mid - 1] + arr[mid]) / 2 : arr[mid];
            };

            const median = getMedian(numericValues);
            const q1 = getMedian(numericValues.slice(0, Math.floor(numericValues.length / 2)));
            const q3 = getMedian(numericValues.slice(Math.ceil(numericValues.length / 2)));
            const iqr = q3 - q1;

            return { q1: q1.toFixed(2), median: median.toFixed(2), q3: q3.toFixed(2), iqr: iqr.toFixed(2) };
        }

        // Helper to calculate Pearson correlation coefficient
        function calculateCorrelation(col1, col2, data) {
            const validData = data.filter(row => !isNaN(Number(row[col1])) && !isNaN(Number(row[col2])));
            if (validData.length < 2) return null; // Need at least two data points

            const xValues = validData.map(row => Number(row[col1]));
            const yValues = validData.map(row => Number(row[col2]));

            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + (x * yValues[i]), 0);
            const sumX2 = xValues.reduce((sum, x) => sum + (x * x), 0);
            const sumY2 = yValues.reduce((sum, y) => sum + (y * y), 0);

            const n = validData.length;

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            if (denominator === 0) return 0; // Avoid division by zero, implies no variance
            return numerator / denominator;
        }

        // Helper to find outliers using IQR method
        function findOutliers(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n)).sort((a, b) => a - b);
            if (numericValues.length === 0) return { outliers: [], lowerBound: null, upperBound: null };

            const { q1, q3, iqr } = calculateQuartiles(columnName, data); // Uses existing function
            if (q1 === null || q3 === null || iqr === null) return { outliers: [], lowerBound: null, upperBound: null };

            const lowerBound = parseFloat(q1) - 1.5 * parseFloat(iqr);
            const upperBound = parseFloat(q3) + 1.5 * parseFloat(iqr);

            const outliers = numericValues.filter(val => val < lowerBound || val > upperBound);

            return { outliers, lowerBound: lowerBound.toFixed(2), upperBound: upperBound.toFixed(2) };
        }

        // Helper to perform simple linear regression
        function performSimpleLinearRegression(xCol, yCol, data) { // Renamed for clarity vs. multiple regression
            const validData = data.filter(row => !isNaN(Number(row[xCol])) && !isNaN(Number(row[yCol])));
            if (validData.length < 2) return null; // Need at least two points for regression

            const xValues = validData.map(row => Number(row[xCol]));
            const yValues = validData.map(row => Number(row[yCol]));

            const n = validData.length;
            const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;
            const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;

            let sumXY = 0;
            let sumX2 = 0;
            let sumY2 = 0; // For R-squared calculation

            for (let i = 0; i < n; i++) {
                sumXY += (xValues[i] - meanX) * (yValues[i] - meanY);
                sumX2 += (xValues[i] - meanX) * (xValues[i] - meanX);
                sumY2 += (yValues[i] - meanY) * (yValues[i] - meanY); // For R-squared
            }

            const slope = sumX2 === 0 ? 0 : sumXY / sumX2; // b1
            const intercept = meanY - slope * meanX; // b0

            // Calculate R-squared
            let ssResidual = 0;
            let ssTotal = 0;
            for (let i = 0; i < n; i++) {
                const yPredicted = slope * xValues[i] + intercept;
                ssResidual += Math.pow(yValues[i] - yPredicted, 2);
                ssTotal += Math.pow(yValues[i] - meanY, 2);
            }
            const rSquared = ssTotal === 0 ? 0 : (1 - (ssResidual / ssTotal));

            return { slope: slope.toFixed(4), intercept: intercept.toFixed(4), rSquared: rSquared.toFixed(4) };
        }

        // Helper for grouping and aggregating data for charts (e.g., for bar charts)
        function groupByAndAggregate(data, groupByColumn, aggregateColumn, aggregateType) {
            const groupedData = {};
            data.forEach(row => {
                const groupKey = row[groupByColumn];
                const value = Number(row[aggregateColumn]);

                if (!isNaN(value)) {
                    if (!groupedData[groupKey]) {
                        groupedData[groupKey] = { sum: 0, count: 0 };
                    }
                    groupedData[groupKey].sum += value;
                    groupedData[groupKey].count++;
                }
            });

            const labels = [];
            const values = [];

            for (const key in groupedData) {
                labels.push(key);
                if (aggregateType === 'average') {
                    values.push(groupedData[key].sum / groupedData[key].count);
                } else { // default to sum
                    values.push(groupedData[key].sum);
                }
            }
            return { labels, data: values };
        }

        // NEW HELPER: Get frequency distribution for a single categorical column
        function getFrequencyDistribution(columnName, data) {
            const values = data.map(row => row[columnName]).filter(v => v !== undefined && v !== null && v !== '');
            const valueCounts = {};
            values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });

            // Sort by count descending to make charts more readable
            const sortedEntries = Object.entries(valueCounts).sort(([,countA], [,countB]) => countB - countA);

            const labels = sortedEntries.map(entry => entry[0]);
            const counts = sortedEntries.map(entry => entry[1]);
            return { labels, data: counts };
        }


        // Advanced Feature: Check for missing values and suggest cleaning
        function checkAndSuggestDataCleaning(data, currentSchema) {
            let suggestions = [];
            for (const col in currentSchema) {
                if (currentSchema[col] === 'number') {
                    const missingCount = data.filter(row => row[col] === '' || row[col] === undefined || row[col] === null).length;
                    if (missingCount > 0) {
                        suggestions.push({
                            column: col,
                            type: 'missing_numeric',
                            count: missingCount,
                            action: 'fill_average'
                        });
                    }
                }
            }

            if (suggestions.length > 0) {
                const firstSuggestion = suggestions[0];
                pendingCleaningSuggestion = firstSuggestion;
                appendMessage('AI', `I noticed ${firstSuggestion.count} missing values in the numeric column "<strong>${firstSuggestion.column}</strong>". Would you like me to fill them with the column's average? (Type "yes" to confirm)`, 'ai');
            } else {
                pendingCleaningSuggestion = null;
            }
        }

        // --- Charting Functions ---

        // Helper to get consistent chart colors
        function getChartColors(count) {
            const colors = [
                'rgba(66, 153, 225, 0.8)', // Blue
                'rgba(144, 202, 249, 0.8)', // Light Blue
                'rgba(74, 222, 128, 0.8)', // Green
                'rgba(251, 191, 36, 0.8)', // Yellow
                'rgba(248, 113, 113, 0.8)', // Red
                'rgba(192, 132, 252, 0.8)', // Purple
                'rgba(129, 140, 248, 0.8)', // Indigo
                'rgba(244, 114, 182, 0.8)', // Pink
            ];
            // Cycle through colors if more data points than defined colors
            return Array.from({ length: count }, (_, i) => colors[i % colors.length]);
        }

        // Function to create a chart (now with axis label options)
        function createChart(chartType, chartTitle, labels, data, xAxisLabelText = '', yAxisLabelText = '', options = {}) {
            // MyChart no longer destroys, each chart is a new instance
            // Create the AI message that introduces the chart
            const chartMessageDiv = document.createElement('div');
            chartMessageDiv.className = 'flex items-start mb-4 fade-in-message';
            chartMessageDiv.innerHTML = `
                <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md">
                    <p class="leading-relaxed">Here's the **${chartType} chart** for **${chartTitle}**:</p>
                </div>
            `;
            chatArea.appendChild(chartMessageDiv); // Append the AI text bubble

            // Create the chart container
            const chartCanvas = document.createElement('canvas');
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container'; // This class has margin-top for spacing
            chartContainer.appendChild(chartCanvas);
            
            chatArea.appendChild(chartContainer); // Append the chart below the text bubble
            // Scroll to the bottom of the chat area to show the latest chart
            chatArea.scrollTop = chatArea.scrollHeight;

            // Configure datasets based on chart type
            let datasetsConfig = [];
            if (chartType === 'scatter') {
                datasetsConfig.push({
                    label: chartTitle,
                    data: data, // Data for scatter plots is already in {x, y} format
                    backgroundColor: getChartColors(1)[0], // Use a single color for all points
                    borderColor: getChartColors(1)[0].replace('0.8', '1'),
                    pointRadius: 5,
                    pointHoverRadius: 7
                });
            } else {
                datasetsConfig.push({
                    label: chartTitle,
                    data: data,
                    backgroundColor: getChartColors(data.length),
                    borderColor: getChartColors(data.length).map(color => color.replace('0.8', '1')), // Opaque borders
                    borderWidth: 1
                });
            }

            const ctx = chartCanvas.getContext('2d');
            // Create a NEW Chart.js instance for each chart
            new Chart(ctx, { // Removed 'myChart =' assignment
                type: chartType,
                data: {
                    labels: (chartType !== 'scatter') ? labels : undefined, // Labels for non-scatter charts
                    datasets: datasetsConfig
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e2e8f0' // Light text for legend on dark background
                            }
                        },
                        title: { // Chart title moved here for consistency
                            display: true,
                            text: chartTitle,
                            color: '#e2e8f0'
                        }
                    },
                    scales: {
                        x: {
                            // For scatter, ensure type 'linear'. For others, 'category' is common for labels.
                            type: (chartType === 'scatter' || chartType === 'line') ? 'linear' : 'category',
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)' // Very subtle grid lines
                            },
                            title: { // X-axis title
                                display: xAxisLabelText !== '',
                                text: xAxisLabelText,
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            type: 'linear', // Y is typically linear for quantitative data
                            ticks: {
                                color: '#a0aec0' // Light grey ticks
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            },
                            title: { // Y-axis title
                                display: yAxisLabelText !== '',
                                text: yAxisLabelText,
                                color: '#e2e8f0'
                            }
                        }
                    },
                    ...options // Merge custom options (allows overriding scales too)
                }
            });
        }

        // Function to get the HTML for the command list table
        function getCommandListHtml(searchTerm = '') { // Added searchTerm parameter
            const allCommands = [ // Define all commands as an array of objects
                { category: 'General Overview', sr: 1, command: 'Show all data', example: '<code>show all data</code>' },
                { category: 'General Overview', sr: 2, command: 'Show specific column data', example: '<code>show [column name]</code> (e.g., <code>show City</code>)' },
                { category: 'General Overview', sr: 3, command: 'Count rows', example: '<code>count rows</code>' },
                { category: 'General Overview', sr: 4, command: 'Describe dataset', example: '<code>describe my dataset</code>' },
                { category: 'General Overview', sr: 5, command: 'Show schema', example: '<code>show schema</code>' },
                { category: 'Statistical Analysis', sr: 6, command: 'Sum a numeric column', example: '<code>sum [numeric column]</code> (e.g., <code>sum sales</code>)' },
                { category: 'Statistical Analysis', sr: 7, command: 'Average a numeric column', example: '<code>average [numeric column]</code> (e.g., <code>average age</code>)' },
                { category: 'Statistical Analysis', sr: 8, command: 'Median of a numeric column', example: '<code>median [numeric column]</code> (e.g., <code>median income</code>)' },
                { category: 'Statistical Analysis', sr: 9, command: 'Standard deviation of a numeric column', example: '<code>standard deviation [numeric column]</code> (e.g., <code>standard deviation price</code>)' },
                { category: 'Statistical Analysis', sr: 10, command: 'Quartiles of a numeric column', example: '<code>quartiles [numeric column]</code> (e.g., <code>quartiles score</code>)' },
                { category: 'Statistical Analysis', sr: 11, command: 'Count unique values in a column', example: '<code>count unique [column name]</code> (e.g., <code>count unique city</code>)' },
                { category: 'Statistical Analysis', sr: 12, command: 'Show frequency/top values', example: '<code>show frequency of [column name]</code> or <code>top values in [column name]</code> (e.g., <code>show frequency of product type</code>)' },
                { category: 'Statistical Analysis', sr: 13, command: 'Min/Max of a numeric column', example: '<code>min [numeric column]</code> or <code>max [numeric column]</code> (e.g., <code>min temperature</code>)' },
                { category: 'Statistical Analysis', sr: 14, command: 'Average a numeric column by categorical group', example: '<code>average [numeric column] by [categorical column]</code> (e.g., <code>average sales by region</code>)' },
                { category: 'Statistical Analysis', sr: 15, command: 'Correlation between two numeric columns', example: '<code>show correlation between [numeric_col1] and [numeric_col2]</code> (e.g., <code>show correlation between Age and Income</code>)' },
                { category: 'Statistical Analysis', sr: 16, command: 'Find outliers in a numeric column', example: '<code>find outliers in [numeric column]</code> (e.g., <code>find outliers in Sales</code>)' },
                { category: 'Hypothesis Testing', sr: 17, command: 'Perform T-test', example: '<code>perform t-test on [numeric_col] for [categorical_col] where [group1_value] vs [group2_value]</code> (e.g., <code>perform t-test on Sales for Region where East vs West</code>)' },
                { category: 'Time Series Analysis', sr: 18, command: 'Calculate Moving Average', example: '<code>calculate moving average of [numeric_col] with window [window_size] as [new_col_name]</code> (e.g., <code>calculate moving average of Stock_Price with window 5 as MA_5_Days</code>)' },
                { category: 'Data Manipulation', sr: 19, command: 'Filter data', example: '<code>filter data where [column] [operator] [value]</code> (e.g., <code>sales > 1000</code> or <code>city = "London"</code>)' },
                { category: 'Data Manipulation', sr: 20, command: 'Add a new calculated column', example: '<code>add column [new_name] as [col1] [operator] [col2]</code> (Operators: \'plus\', \'minus\', \'times\', \'divided by\'. E.g., <code>add column profit as revenue minus cost</code>)' },
                { category: 'Data Manipulation', sr: 21, command: 'Categorize numeric data into bins', example: '<code>categorize [numeric_col] into [num_bins] bins as [new_col_name]</code> (e.g., <code>categorize Age into 5 bins as Age_Group</code>)' },
                { category: 'Data Manipulation', sr: 22, command: 'Remove duplicate rows', example: '<code>remove duplicate rows</code>' },
                { category: 'Data Manipulation', sr: 23, command: 'Rename column', example: '<code>rename column [old_name] to [new_name]</code> (e.g., <code>rename column Product_ID to SKU</code>)' },
                { category: 'Business Intelligence', sr: 24, command: 'Summarize numeric by categorical', example: '<code>summarize [numeric_col] by [categorical_col]</code> (e.g., <code>summarize Sales by Region</code>)' },
                { category: 'Business Intelligence', sr: 25, command: 'Show overall business overview', example: '<code>show overall business overview</code>' },
                { category: 'Data Export', sr: 26, command: 'Download modified dataset', example: 'Click the "Download Modified CSV" button' },
                { category: 'Charting & Visualization', sr: 27, command: 'Show Bar Chart', example: '<code>show bar chart of [numeric_col] by [categorical_col] [as sum/average]</code> (e.g., <code>show bar chart of sales by region as average</code>)' },
                { category: 'Charting & Visualization', sr: 28, command: 'Show Line Chart', example: '<code>show line chart with X as [column] and Y as [numeric_column]</code> (e.g., <code>show line chart with X as Date and Y as Stock Price</code>)' },
                { category: 'Charting & Visualization', sr: 29, command: 'Show Scatter Plot', example: '<code>show scatter plot with X as [numeric_column1] and Y as [numeric_column2]</code> (e.g., <code>show scatter plot with X as Age and Y as Income</code>)' },
                { category: 'Charting & Visualization', sr: 30, command: 'Show Pie Chart', example: '<code>show pie chart of [column]</code> (e.g., <code>show pie chart of Gender</code>) or <code>show pie chart of [numeric_col] by [categorical_col] [as sum/average]</code>' },
                { category: 'Charting & Visualization', sr: 31, command: 'Show Doughnut Chart', example: '<code>show doughnut chart of [column]</code> (e.g., <code>show doughnut chart of Region</code>) or <code>show doughnut chart of [numeric_col] by [categorical_col] [as sum/average]</code>' },
                { category: 'Charting & Visualization', sr: 32, command: 'Show Polar Area Chart', example: '<code>show polar area chart of [column]</code> (e.g., <code>show polar area chart of Status</code>) or <code>show polar area chart of [numeric_col] by [categorical_col] [as sum/average]</code>' },
                { category: 'Modeling', sr: 33, command: 'Perform Simple Linear Regression', example: '<code>perform regression with Y as [numeric_col_y] and X as [numeric_col_x]</code> (e.g., <code>perform regression with Y as Sales and X as Advertising</code>)' },
                { category: 'Advanced Modeling & Unsupervised Learning', sr: 34, command: 'Perform Multiple Linear Regression', example: '<code>perform multiple regression with Y as [dep_var] and X as [indep_var1], [indep_var2], ...</code> (e.g., <code>perform multiple regression with Y as Sales and X as Advertising, Price</code>)' },
                { category: 'Advanced Modeling & Unsupervised Learning', sr: 35, command: 'Perform Polynomial Regression', example: '<code>perform polynomial regression with Y as [dep_var] and X as [indep_var] with degree [degree]</code> (e.g., <code>perform polynomial regression with Y as Sales and X as Advertising with degree 2</code>)' },
                { category: 'Advanced Modeling & Unsupervised Learning', sr: 36, command: 'Perform K-Means Clustering', example: '<code>perform k-means clustering on [col1], [col2], ... into [k] clusters as [new_cluster_column]</code> (e.g., <code>perform k-means clustering on Age, Income, Spending_Score into 3 clusters as Customer_Segment</code>)' },
                { category: 'Data Transformation & Reshaping', sr: 37, command: 'Create Pivot Table', example: '<code>create pivot table with [row_col] as rows, [column_col] as columns, [value_col] as values aggregated by [sum/average/count]</code> (e.g., <code>create pivot table with Region as rows, Product_Category as columns, Sales as values aggregated by sum</code>)' },
                { category: 'Data Transformation & Reshaping', sr: 38, command: 'Unpivot/Melt Data', example: '<code>unpivot data keeping [id_col(s)] and melting [col1], [col2], ... into new variable [new_var_col] and value [new_val_col]</code> (e.g., <code>unpivot data keeping ID and melting Q1_Sales, Q2_Sales, Q3_Sales into new variable Quarter and value Sales_Amount</code>)' },
                { category: 'Proactive Insights', sr: 39, command: 'Show Proactive Insights', example: '<code>show proactive insights</code> or <code>what insights do you have?</code>' },
                { category: 'Reporting & Storytelling', sr: 40, command: 'Generate Data Story / Create Report', example: '<code>generate data story</code> or <code>create report</code>' },
            ];

            const lowerSearchTerm = searchTerm.toLowerCase();
            const filteredCommands = allCommands.filter(cmd =>
                cmd.category.toLowerCase().includes(lowerSearchTerm) ||
                cmd.command.toLowerCase().includes(lowerSearchTerm) ||
                cmd.example.toLowerCase().includes(lowerSearchTerm.replace(/`/g, '')) // Remove backticks for example search
            );

            let tableHtml = `<p class="command-guide-intro">I'm ready to help with your data analysis! Here's a quick guide to what I can do:</p>
                <table class="command-table">
                    <thead>
                        <tr>
                            <th>Sr. No.</th>
                            <!-- Removed Category Header -->
                            <th>Command</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>`;

            let currentCategory = '';
            filteredCommands.forEach(cmd => {
                if (cmd.category !== currentCategory) {
                    currentCategory = cmd.category;
                    // Updated Category Header Styling
                    tableHtml += `<tr class="category-header">
                                    <td colspan="3">${currentCategory}</td> <!-- colspan changed to 3 -->
                                  </tr>`;
                }
                tableHtml += `
                    <tr>
                        <td>${cmd.sr}</td>
                        <td>${cmd.command}</td>
                        <td>${cmd.example}</td>
                    </tr>`;
            });

            if (filteredCommands.length === 0) {
                tableHtml += `<tr><td colspan="3" class="text-center text-gray-400 py-4">No commands match your search.</td></tr>`;
            }

            tableHtml += `</tbody></table>
                <p class="mt-4 text-gray-400">If I've made a cleaning suggestion, you can simply type <strong>'yes'</strong> to confirm.</p>`;

            return tableHtml;
        }

        /**
         * Generates an HTML table for displaying raw data with sortable headers.
         * @param {Array<Object>} data - The raw data to display.
         * @param {Object} schema - The schema of the data.
         * @param {string} sortCol - The current column being sorted.
         * @param {string} sortDir - The current sort direction ('asc' or 'desc').
         * @returns {string} HTML string of the data table.
         */
        function createDataTableHtml(data, schema, sortCol, sortDir) {
            if (data.length === 0 || Object.keys(schema).length === 0) {
                return '<p class="text-gray-400 text-center py-4">No data available to display in a table. Please upload a CSV first!</p>';
            }

            const headers = Object.keys(schema);
            let tableHtml = `<div class="overflow-x-auto max-h-[400px] custom-scrollbar rounded-lg shadow-inner-dark border border-gray-700">
                                <table class="data-table">
                                    <thead>
                                        <tr>`;
            headers.forEach(header => {
                const isSorted = header === sortCol;
                const sortClass = isSorted ? `sorted-${sortDir}` : '';
                const sortIcon = isSorted ? (sortDir === 'asc' ? '<i class="fas fa-sort-up sort-icon"></i>' : '<i class="fas fa-sort-down sort-icon"></i>') : '<i class="fas fa-sort sort-icon"></i>';
                tableHtml += `<th class="${sortClass}" data-column-name="${header}">${header} ${sortIcon}</th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            // Display a limited number of rows for large datasets for performance
            const displayLimit = 200; // Limit to first 200 rows for preview
            const dataToDisplay = data.slice(0, displayLimit);

            dataToDisplay.forEach(row => {
                tableHtml += `<tr>`;
                headers.forEach(header => {
                    const value = row[header] !== undefined && row[header] !== null ? row[header] : '';
                    tableHtml += `<td>${value}</td>`;
                });
                tableHtml += `</tr>`;
            });
            tableHtml += `</tbody></table></div>`;

            if (data.length > displayLimit) {
                tableHtml += `<p class="text-sm text-gray-400 mt-2">Displaying first ${displayLimit} of ${data.length} rows. Scroll to see more. Data is processed entirely on your device!</p>`;
            } else {
                tableHtml += `<p class="text-sm text-gray-400 mt-2">You have a total of ${data.length} rows. Data is processed entirely on your device!</p>`;
            }


            return tableHtml;
        }

        // --- Data Preview Table Sorting Logic ---
        function attachTableSortingListeners() {
            // Find the newly rendered data table
            const dataTable = chatArea.querySelector('.data-table');
            if (!dataTable) return; // No table found

            const headers = dataTable.querySelectorAll('th[data-column-name]');
            headers.forEach(header => {
                header.addEventListener('click', (event) => {
                    const column = header.dataset.columnName;

                    if (column === currentSortColumn) {
                        currentSortDirection = (currentSortDirection === 'asc') ? 'desc' : 'asc';
                    } else {
                        currentSortColumn = column;
                        currentSortDirection = 'asc';
                    }
                    
                    // Sort the rawData
                    rawData.sort((a, b) => {
                        const valA = a[currentSortColumn];
                        const valB = b[currentSortColumn];

                        if (schema[currentSortColumn] === 'number') {
                            const numA = parseFloat(valA);
                            const numB = parseFloat(valB);
                            if (isNaN(numA) && isNaN(numB)) return 0;
                            if (isNaN(numA)) return currentSortDirection === 'asc' ? 1 : -1; // nulls/non-numbers at end
                            if (isNaN(numB)) return currentSortDirection === 'asc' ? -1 : 1;
                            return (currentSortDirection === 'asc' ? numA - numB : numB - numA);
                        } else { // string comparison
                            const strA = String(valA).toLowerCase();
                            const strB = String(valB).toLowerCase();
                            if (strA < strB) return currentSortDirection === 'asc' ? -1 : 1;
                            if (strA > strB) return currentSortDirection === 'asc' ? 1 : -1;
                            return 0;
                        }
                    });

                    // Re-render the chat area with the sorted table
                    // This is a simplified re-render for the prototype: it clears and re-adds the entire chat content
                    // For a more complex app, you might only update the table itself.
                    // To re-render only the table, we'll simulate the "show all data" command.
                    simulateAIResponse('show all data', true); // Pass true to skip appending AI message again

                });
            });
        }


        // Handle CSV file input change
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // Update upload status immediately
                fileNameDisplay.textContent = `File: ${file.name}`;
                uploadStatus.textContent = 'Loading and parsing...';
                uploadStatus.className = 'mt-1 text-xs font-semibold text-blue-400 animate-pulse';

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        rawData = parseCSV(e.target.result);
                        schema = inferSchema(rawData);
                        displaySchema(schema);
                        // Reset sorting state on new file upload
                        currentSortColumn = null;
                        currentSortDirection = 'asc';

                        // Updated success message
                        uploadStatus.textContent = `Your ${file.name} has been uploaded successfully and is ready to perform analysis on.`;
                        uploadStatus.className = 'mt-1 text-xs font-semibold text-green-500';

                        // Proactively check for data cleaning needs
                        // This function will append a message if a suggestion is found
                        checkAndSuggestDataCleaning(rawData, schema);
                        
                        // Generate and *store* proactive insights, but don't display automatically
                        generateProactiveInsights();


                    } catch (error) {
                        uploadStatus.textContent = `Error parsing CSV: ${error.message}`;
                        uploadStatus.className = 'mt-1 text-xs font-semibold text-red-500';
                        appendMessage('AI', 'Oops! There was an error loading your CSV. Please ensure it\'s a valid CSV format with correct delimiters.', 'ai');
                    }
                };
                reader.readAsText(file);
            } else {
                fileNameDisplay.textContent = '';
                uploadStatus.textContent = 'No file selected.';
                uploadStatus.className = 'mt-1 text-xs font-semibold text-gray-400';
            }
        });

        // Function to append messages to the chat area
        function appendMessage(sender, text, type = 'user', skipScroll = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex mb-4 ${type === 'user' ? 'justify-end' : 'items-start'} fade-in-message`;

            if (type === 'user') {
                messageDiv.innerHTML = `
                    <div class="bg-blue-600 text-white p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                `;
            } else { // AI message
                messageDiv.innerHTML = `
                    <div class="flex-shrink-0 w-10 h-10 ai-avatar-gradient rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 shadow-md">AI</div>
                    <div class="bg-gray-700 text-gray-200 p-4 rounded-3xl max-w-[80%] shadow-md transform hover:scale-[1.01] transition duration-200 ease-in-out">
                        <p class="leading-relaxed">${text}</p>
                    </div>
                `;
            }
            chatArea.appendChild(messageDiv);
            if (!skipScroll) { // Only scroll if not skipping
                chatArea.scrollTop = chatArea.scrollHeight; // Scroll to the bottom
            }
        }

        // Helper to find a column by name (case-insensitive and partial match)
        function findColumnByName(rawName) {
            if (!rawName) return null; // Handle null/undefined input
            const lowerRawName = rawName.toLowerCase();
            for (const col in schema) {
                // Prioritize exact case-insensitive match
                if (col.toLowerCase() === lowerRawName) {
                    return col;
                }
            }
            // Fallback to partial case-insensitive match if no exact match
            for (const col in schema) {
                if (col.toLowerCase().includes(lowerRawName)) {
                    return col;
                }
            }
            return null;
        }

        // Helper to find a numeric column by name
        function findNumericColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'number') {
                return col;
            }
            return null;
        }

        // Helper to find a categorical column by name
        function findCategoricalColumn(rawName) {
            const col = findColumnByName(rawName);
            if (col && schema[col] === 'string') {
                return col;
            }
            return null;
        }

        // Helper for basic descriptive statistics for a numeric column
        function getDescriptiveStats(columnName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0) return null;

            const sum = numericValues.reduce((a, b) => a + b, 0);
            const mean = sum / numericValues.length;

            const sorted = [...numericValues].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];

            const min = Math.min(...numericValues);
            const max = Math.max(...numericValues);

            const sumOfSquares = numericValues.reduce((s, val) => s + Math.pow(val - mean, 2), 0);
            const variance = sumOfSquares / (numericValues.length - 1);
            const stdDev = Math.sqrt(variance);

            return {
                count: numericValues.length,
                mean: mean,
                median: median,
                min: min,
                max: max,
                stdDev: stdDev,
                sum: sum
            };
        }

        // New Feature: Categorize numeric column into bins
        function categorizeNumericColumn(columnName, numBins, newColName, data) {
            const numericValues = data.map(row => Number(row[columnName])).filter(n => !isNaN(n));
            if (numericValues.length === 0 || numBins <= 0) return { success: false, message: 'Invalid data or number of bins.' };

            const minVal = Math.min(...numericValues);
            const maxVal = Math.max(...numericValues);
            const binSize = (maxVal - minVal) / numBins;

            if (binSize === 0) { // All values are the same
                rawData = rawData.map(row => ({
                    ...row,
                    [newColName]: `${minVal.toFixed(2)} - ${maxVal.toFixed(2)}`
                }));
                schema[newColName] = 'string';
                displaySchema(schema);
                return { success: true, message: `All values in "${columnName}" are the same. Created a single bin for "${newColName}".` };
            }

            rawData = rawData.map(row => {
                const value = Number(row[columnName]);
                if (isNaN(value)) {
                    return { ...row, [newColName]: 'N/A' };
                }
                let binIndex = Math.floor((value - minVal) / binSize);
                // Ensure the max value falls into the last bin
                if (binIndex === numBins) {
                    binIndex = numBins - 1;
                }

                const binStart = minVal + binIndex * binSize;
                const binEnd = minVal + (binIndex + 1) * binSize;
                return {
                    ...row,
                    [newColName]: `${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`
                };
            });
            schema[newColName] = 'string';
            displaySchema(schema);
            return { success: true, message: `Categorized "<strong>${columnName}</strong>" into <strong>${numBins} bins</strong> and created a new column "<strong>${newColName}</strong>".` };
        }

        // New Feature: Remove duplicate rows
        function removeDuplicateRows(data) {
            const initialLength = data.length;
            const seen = new Set();
            const uniqueData = [];

            data.forEach(row => {
                const rowString = JSON.stringify(row); // Simple serialization for comparison
                if (!seen.has(rowString)) {
                    seen.add(rowString);
                    uniqueData.push(row);
                }
            });
            rawData = uniqueData; // Update global rawData
            const removedCount = initialLength - rawData.length;
            return { success: true, removedCount };
        }

        // New Feature: Rename column
        function renameColumn(oldName, newName) {
            const actualOldName = findColumnByName(oldName);
            if (!actualOldOldName) {
                return { success: false, message: `Column "<strong>${oldName}</strong>" not found.` };
            }
            if (Object.keys(schema).includes(newName)) {
                return { success: false, message: `Column "<strong>${newName}</strong>" already exists.` };
            }

            rawData = rawData.map(row => {
                const newRow = {};
                for (const key in row) {
                    if (key === actualOldName) {
                        newRow[newName] = row[key];
                    } else {
                        newRow[key] = row[key];
                    }
                }
                return newRow;
            });

            // Update schema
            const newSchema = {};
            for (const key in schema) {
                if (key === actualOldName) {
                    newSchema[newName] = schema[key];
                } else {
                    newSchema[key] = schema[key];
                }
            }
            schema = newSchema;
            displaySchema(schema);
            return { success: true, message: `Column "<strong>${actualOldName}</strong>" successfully renamed to "<strong>${newName}</strong>".` };
        }

        // Function to download the current rawData as a CSV file
        function downloadCSV() {
            if (rawData.length === 0 || Object.keys(schema).length === 0) {
                appendMessage('AI', 'There is no data loaded to download. Please upload a CSV first!', 'ai');
                return;
            }

            const headers = Object.keys(schema);
            const csvRows = [];

            // Add headers row
            csvRows.push(headers.map(header => `"${header}"`).join(','));

            // Add data rows
            rawData.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header];
                    // Escape double quotes by doubling them, and wrap in quotes if contains comma or double quote
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvRows.push(values.join(','));
            });

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'CoDA_Modified_Data.csv');
            link.style.visibility = 'hidden'; // Hide the link
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link); // Clean up
            URL.revokeObjectURL(url); // Free up memory

            appendMessage('AI', 'Your modified dataset has been downloaded as **CoDA_Modified_Data.csv**!', 'ai');
        }

        // Event listener for the download button
        downloadCsvBtn.addEventListener('click', downloadCSV);

        // --- Data Panel Toggle Logic ---
        // Initial setup for data panel: ensure it starts hidden and button reflects this
        dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden'); // Ensure it starts hidden and collapses on md+
        chatPanel.classList.remove('md:w-2/3'); // Ensure chat panel takes full width initially on md+
        chatPanel.classList.add('md:w-full');
        toggleButtonText.textContent = 'Show Data Panel';
        toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2';

        toggleDataPanelBtn.addEventListener('click', () => {
            // Determine visibility by checking for 'hidden' class
            const isCurrentlyHidden = dataPanel.classList.contains('hidden');

            if (isCurrentlyHidden) {
                // Show data panel
                dataPanel.classList.remove('hidden', 'md:w-0', 'md:hidden');
                dataPanel.classList.add('flex', 'md:w-1/3');
                chatPanel.classList.remove('md:w-full');
                chatPanel.classList.add('md:w-2/3');
                toggleButtonText.textContent = 'Hide Data Panel';
                toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye-slash mr-2';
            } else {
                // Hide data panel
                dataPanel.classList.remove('flex', 'md:w-1/3');
                dataPanel.classList.add('hidden', 'md:w-0', 'md:hidden');
                chatPanel.classList.remove('md:w-2/3');
                chatPanel.classList.add('md:w-full');
                toggleButtonText.textContent = 'Show Data Panel';
                toggleDataPanelBtn.querySelector('i').className = 'fas fa-eye mr-2';
            }
        });

        // Event listener for the toggle command guide button
        toggleCommandGuideBtn.addEventListener('click', () => {
            // Show the overlay
            commandGuideOverlay.classList.remove('hidden');
            commandGuideContent.innerHTML = getCommandListHtml(); // Populate the content with no search term initially
            // Update the text/icon of the toggle button itself to reflect it's "hiding" the guide
            toggleCommandGuideText.textContent = 'Hide Command Guide';
            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
        });

        // Event listener for the close button INSIDE the overlay
        closeCommandGuideBtn.addEventListener('click', () => {
            // Hide the overlay
            commandGuideOverlay.classList.add('hidden');
            // Reset the toggle button's text/icon
            toggleCommandGuideText.textContent = 'Show Command Guide';
            toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';
            commandSearchInput.value = ''; // Clear search input when closing
        });

        // Event listener for Command Guide Search Input
        commandSearchInput.addEventListener('input', () => {
            const searchTerm = commandSearchInput.value.trim();
            commandGuideContent.innerHTML = getCommandListHtml(searchTerm); // Re-render with search term
        });


        /**
         * Helper function to parse dates. Handles common formats.
         * @param {string} dateString
         * @returns {Date | null} Parsed Date object or null if invalid.
         */
        function parseDate(dateString) {
            try {
                const date = new Date(dateString);
                // Check if date is valid (e.g., handles "Invalid Date")
                return isNaN(date.getTime()) ? null : date;
            } catch (e) {
                console.warn(`Could not parse date string: ${dateString}`);
                return null;
            }
        }

        /**
         * Helper to get sum of a numeric column for a filtered dataset.
         * @param {string} colName - The name of the numeric column.
         * @param {Array<Object>} dataSubset - The subset of data to calculate the sum for.
         * @returns {number} The sum of the column, or 0 if no valid numbers.
         */
        function getSumFromSubset(colName, dataSubset) {
            return dataSubset.reduce((acc, row) => {
                const val = Number(row[colName]);
                return acc + (isNaN(val) ? 0 : val);
            }, 0);
        }

        /**
         * Generates and returns proactive insights as an HTML string.
         * This includes anomaly detection and identifying top/bottom performers, and correlations.
         * @returns {string | null} An HTML string containing the insights, or null if no data.
         */
        function generateProactiveInsights() {
            if (rawData.length === 0) {
                lastProactiveInsights = []; // Clear previous insights if data is gone
                return; // No data to analyze
            }

            let insights = [];

            // 1. Sales Drop Anomaly Detection with Root Cause Suggestion
            const dateCol = findColumnByName('Date') || findColumnByName('Order Date') || findColumnByName('Transaction Date');
            const salesCol = findNumericColumn('Sales') || findNumericColumn('Revenue') || findColumnByName('Amount');
            const regionCol = findCategoricalColumn('Region') || findCategoricalColumn('Area') || findCategoricalColumn('Territory');
            const marketingSpendCol = findNumericColumn('Marketing_Spend') || findNumericColumn('Ad_Spend') || findNumericColumn('Campaign_Cost');

            if (dateCol && salesCol && regionCol) {
                // Get all unique dates and sort them to find the latest
                const uniqueDates = [...new Set(rawData.map(row => row[dateCol]))]
                                        .map(parseDate)
                                        .filter(d => d !== null)
                                        .sort((a, b) => a.getTime() - b.getTime());

                if (uniqueDates.length >= 8) { // Need at least 8 days for 1 current + 7 historical
                    const latestDate = uniqueDates[uniqueDates.length - 1];
                    const eightDaysAgo = new Date(latestDate.getTime());
                    eightDaysAgo.setDate(latestDate.getDate() - 7); // Start of the 7-day lookback period

                    const regions = [...new Set(rawData.map(row => row[regionCol]))].filter(r => r); // Get unique regions

                    regions.forEach(region => {
                        const regionData = rawData.filter(row => row[regionCol] === region && parseDate(row[dateCol]) !== null);

                        const currentDaySalesData = regionData.filter(row => {
                            const date = parseDate(row[dateCol]);
                            return date && date.getDate() === latestDate.getDate() &&
                                       date.getMonth() === latestDate.getMonth() &&
                                       date.getFullYear() === latestDate.getFullYear();
                        });
                        const currentDaySales = getSumFromSubset(salesCol, currentDaySalesData);

                        const last7DaysSalesData = regionData.filter(row => {
                            const date = parseDate(row[dateCol]);
                            return date && date.getTime() >= eightDaysAgo.getTime() && date.getTime() < latestDate.getTime();
                        });
                        const last7DaysAvgSales = last7DaysSalesData.length > 0 ? getSumFromSubset(salesCol, last7DaysSalesData) / last7DaysSalesData.length : 0;

                        if (last7DaysAvgSales > 0) {
                            const salesDropPercentage = ((last7DaysAvgSales - currentDaySales) / last7DaysAvgSales) * 100;
                            const dropThreshold = 15; // Define significant drop threshold

                            if (salesDropPercentage > dropThreshold) {
                                let messageToUser = `**Heads up! Sales in the ${region} region are down ${salesDropPercentage.toFixed(1)}% on ${latestDate.toLocaleDateString()}** compared to the last 7-day average. This deviation is significant.`;
                                // FIX: Use single quotes for string values and escape inner single quotes if any.
                                // The `.replace(/'/g, "\\'")` in the onclick attribute will then correctly escape this.
                                let actionForUser = `filter data where ${regionCol} = '${region.replace(/'/g, "\\'")}' and ${dateCol} = '${latestDate.toLocaleDateString('en-US', {year: 'numeric', month: '2-digit', day: '2-digit'}).replace(/'/g, "\\'")}'`;


                                // Check for consistent marketing spend
                                if (marketingSpendCol) {
                                    const currentDayMarketingSpend = getSumFromSubset(marketingSpendCol, currentDaySalesData);
                                    const last7DaysMarketingSpend = last7DaysSalesData.length > 0 ? getSumFromSubset(marketingSpendCol, last7DaysSalesData) / last7DaysSalesData.length : 0;
                                    const marketingSpendDeviation = last7DaysMarketingSpend > 0 ? Math.abs((currentDayMarketingSpend - last7DaysMarketingSpend) / last7DaysMarketingSpend) * 100 : Infinity;
                                    const marketingConsistencyThreshold = 10; // e.g., within 10% deviation

                                    if (marketingSpendDeviation <= marketingConsistencyThreshold) {
                                        messageToUser += ` This is despite a **consistent marketing spend** in the region.`;
                                    } else {
                                        messageToUser += ` It also appears **marketing spend has changed** significantly in this period.`;
                                    }
                                }
                                messageToUser += `<br>_You can find more details and suggested actions in "Proactive Insights"._`;

                                // Removed: appendMessage('AI', messageToUser, 'ai'); // This was the direct alert in chat

                                insights.push({
                                    type: 'anomaly',
                                    icon: 'fas fa-chart-line-down', // A more specific icon for drops
                                    title: `Significant Sales Drop Detected in ${region} Region!`, // More specific title
                                    message: `Sales in the **${region} region** are **down ${salesDropPercentage.toFixed(1)}%** on ${latestDate.toLocaleDateString()} compared to the last 7-day average. This deviation is significant.` + (marketingSpendCol ? (marketingSpendDeviation <= marketingConsistencyThreshold ? ` This is despite a **consistent marketing spend** in the region.` : ` It also appears **marketing spend has changed** significantly in this period.`) : '') + `<br><br><strong>Recommendation:</strong>
                                        <ol>
                                            <li><strong>Investigate Sales Transactions:</strong> Examine specific sales transactions in ${region} for ${latestDate.toLocaleDateString()} to identify immediate patterns. Type: \`${actionForUser}\`</li>
                                            <li><strong>Review External Factors:</strong> This suggests external factors may be at play. Consider reviewing recent mobile app updates, website traffic analytics, or local events that might impact sales in the ${region} region.</li>
                                            <li><strong>Engage Relevant Teams:</strong> If external analysis points to a technical issue, consider alerting your mobile development or product team.</li>
                                        </ol>
                                        <em>(Note: CoDA is a client-side tool and cannot directly interact with external systems like email or Jira.)</em>`,
                                    action: actionForUser
                                });
                            }
                        }
                    });
                }
            }


            // 2. Anomaly Detection (using existing findOutliers - now item 3)
            const numericCols = Object.keys(schema).filter(col => schema[col] === 'number');
            numericCols.forEach(col => {
                const { outliers, lowerBound, upperBound } = findOutliers(col, rawData);
                if (outliers.length > 0) {
                    insights.push({
                        type: 'anomaly',
                        icon: 'fas fa-exclamation-triangle',
                        title: `Outliers Detected in ${col} Column`, // More specific title
                        message: `I've detected **${outliers.length} potential outliers** in the numeric column "<strong>${col}</strong>". These values fall outside the IQR bounds (${lowerBound} - ${upperBound}). This could indicate data entry errors or unusual events that warrant further investigation.`,
                        action: `find outliers in ${col}`
                    });
                }
            });

            // 3. Top/Bottom Performer Identification for numeric values by categorical groups (now item 4)
            const categoricalCols = Object.keys(schema).filter(col => schema[col] === 'string');

            numericCols.forEach(numCol => {
                categoricalCols.forEach(catCol => {
                    // Skip if the categorical column is the date column as that's handled by sales drop now
                    if (catCol === dateCol) return;

                    const groupedData = {}; // Use a single object to hold sum and count

                    rawData.forEach(row => {
                        const category = row[catCol];
                        const numericValue = Number(row[numCol]);

                        if (!isNaN(numericValue)) {
                            if (!groupedData[category]) {
                                groupedData[category] = { sum: 0, count: 0 };
                            }
                            groupedData[category].sum += numericValue;
                            groupedData[category].count++;
                        }
                    });

                    // Ensure there's data before sorting and accessing properties
                    const sortedBySum = Object.entries(groupedData).sort(([, a], [, b]) => b.sum - a.sum);
                    const sortedByAvg = Object.entries(groupedData)
                                            .map(([category, data]) => [category, data.sum / data.count])
                                            .filter(([, avg]) => !isNaN(avg)) // Filter out NaNs if any categories had no numeric data
                                            .sort(([, a], [, b]) => b - a);

                    if (sortedBySum.length > 1) { // Need at least two categories to talk about top/bottom
                        const topSumCat = sortedBySum[0];
                        const bottomSumCat = sortedBySum[sortedBySum.length - 1];
                        insights.push({
                            type: 'trend',
                            icon: 'fas fa-chart-line',
                            title: `Top/Bottom ${numCol} by ${catCol} (Total)`, // More specific title
                            message: `For **total ${numCol}**, "<strong>${topSumCat[0]}</strong>" in **${catCol}** has the highest sum (${topSumCat[1].sum.toFixed(2)}), while "<strong>${bottomSumCat[0]}</strong>" has the lowest (${bottomSumCat[1].sum.toFixed(2)}). This highlights key areas of high and low aggregate performance.`,
                            action: `show bar chart of ${numCol} by ${catCol} as sum`
                        });
                    }

                    if (sortedByAvg.length > 1) { // Need at least two categories to talk about top/bottom
                        const topAvgCat = sortedByAvg[0];
                        const bottomAvgCat = sortedByAvg[sortedByAvg.length - 1];
                        insights.push({
                            type: 'trend',
                            icon: 'fas fa-chart-bar',
                            title: `Top/Bottom ${numCol} by ${catCol} (Average)`, // More specific title
                            message: `For **average ${numCol}**, "<strong>${topAvgCat[0]}</strong>" in **${catCol}** shows the highest average (${topAvgCat[1].toFixed(2)}), whereas "<strong>${bottomAvgCat[0]}</strong>" has the lowest (${bottomAvgCat[1].toFixed(2)}). This reveals efficiency or intensity per category.`,
                            action: `show bar chart of ${numCol} by ${catCol} as average`
                        });
                    }
                });
            });

            // 4. Correlation Insights between numeric columns (now item 5)
            const numericColumnNames = Object.keys(schema).filter(col => schema[col] === 'number');
            for (let i = 0; i < numericColumnNames.length; i++) {
                for (let j = i + 1; j < numericColumnNames.length; j++) {
                    const col1 = numericColumnNames[i];
                    const col2 = numericColumnNames[j];
                    const correlation = calculateCorrelation(col1, col2, rawData);
                    if (correlation !== null && !isNaN(correlation)) {
                        const absCorrelation = Math.abs(correlation);
                        let correlationStrength = '';
                        let interpretation = '';
                        if (absCorrelation >= 0.8) {
                            correlationStrength = 'a **very strong**';
                            interpretation = 'These columns move very closely together, indicating a strong direct or inverse relationship.';
                        } else if (absCorrelation >= 0.6) {
                            correlationStrength = 'a **strong**';
                            interpretation = 'A significant relationship exists, where changes in one column are consistently associated with changes in the other.';
                        } else if (absCorrelation >= 0.4) {
                            correlationStrength = 'a **moderate**';
                            interpretation = 'There is a noticeable relationship, but other factors might also be at play.';
                        } else if (absCorrelation >= 0.2) {
                            correlationStrength = 'a **weak**';
                            interpretation = 'A slight tendency for the columns to move together exists, but it is not a dominant relationship.';
                        }

                        if (correlationStrength) {
                            const direction = correlation > 0 ? 'positive' : 'negative';
                            insights.push({
                                type: 'correlation',
                                icon: 'fas fa-link',
                                title: `Correlation between ${col1} and ${col2}`, // More specific title
                                message: `There's ${correlationStrength} ${direction} correlation (${correlation.toFixed(2)}) between "<strong>${col1}</strong>" and "<strong>${col2}</strong>". ${interpretation}`,
                                action: `show scatter plot with X as ${col1} and Y as ${col2}`
                            });
                        }
                    }
                }
            };

            // 5. Categorical Distribution - Top N most/least frequent values (now item 6)
            categoricalCols.forEach(catCol => {
                // Skip if the categorical column is the date column or region column as that's handled by sales drop now
                if (catCol === dateCol || catCol === regionCol) return;

                const values = rawData.map(row => row[catCol]);
                const valueCounts = {};
                values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                if (sortedCounts.length > 0) {
                    let topValues = sortedCounts.slice(0, Math.min(3, sortedCounts.length)).map(item => `"${item[0]}" (${((item[1]/values.length)*100).toFixed(1)}%)`).join(', ');
                    insights.push({
                        type: 'distribution',
                        icon: 'fas fa-chart-pie',
                        title: `Distribution of ${catCol}`, // More specific title
                        message: `In "<strong>${catCol}</strong>", the top values are: ${topValues}. There are ${sortedCounts.length} unique values in total. Understanding these distributions is crucial for market segmentation or resource allocation.`,
                        action: `show frequency of ${catCol}`
                    });
                }
            });

            lastProactiveInsights = insights; // Store the array of insight objects
        }

        // Helper function to render insights based on current filters and search
        function renderProactiveInsights(filterType = 'all', searchTerm = '') {
            proactiveInsightsContent.innerHTML = ''; // Clear previous content

            if (lastProactiveInsights.length === 0) {
                proactiveInsightsContent.innerHTML = '<p class="text-gray-400 text-center py-4">No proactive insights available yet. Upload a CSV file to generate proactive insights.</p>';
                return;
            }

            let filteredInsights = lastProactiveInsights.filter(insight => {
                const matchesFilter = filterType === 'all' || insight.type === filterType;
                const matchesSearch = searchTerm === '' ||
                                            insight.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                            insight.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                            insight.action.toLowerCase().includes(searchTerm.toLowerCase());
                return matchesFilter && matchesSearch;
            });

            if (filteredInsights.length === 0) {
                proactiveInsightsContent.innerHTML = `<p class="text-gray-400 text-center py-4">No insights match your current filters and search criteria.</p>`;
                return;
            }

            filteredInsights.forEach((insight, index) => {
                const insightCard = document.createElement('div');
                insightCard.className = 'insight-card';
                // Replace action button with a more flexible structure for multi-line recommendations
                // The 'Suggested Action' part should now correctly parse HTML from the message.
                insightCard.innerHTML = `
                    <div class="insight-header cursor-pointer" data-insight-index="${index}">
                        <i class="mr-2 ${insight.icon}"></i>
                        <h4>${insight.title}</h4>
                        <i class="fas fa-chevron-down ml-auto transition-transform"></i>
                    </div>
                    <div class="collapsible-content">
                        <p class="insight-message">${insight.message}</p>
                        ${insight.action ? `<span class="text-sm text-blue-100 italic">Suggested Command: </span><a href="#" class="insight-action" onclick="typeIntoChatAndSubmit('${insight.action.replace(/'/g, "\\'")}'); return false;">'${insight.action}'</a>` : ''}
                    </div>
                `;
                proactiveInsightsContent.appendChild(insightCard);
            });

            // Add event listeners for collapsing
            document.querySelectorAll('.insight-header').forEach(header => {
                header.addEventListener('click', (event) => {
                    const content = header.nextElementSibling; // Get the .collapsible-content
                    const icon = header.querySelector('.fa-chevron-down');

                    if (content.classList.contains('show')) {
                        content.classList.remove('show');
                        icon.classList.remove('rotate-180');
                    } else {
                        // Hide all other open insights
                        document.querySelectorAll('.collapsible-content.show').forEach(openContent => {
                            openContent.classList.remove('show');
                            openContent.previousElementSibling.querySelector('.fa-chevron-down').classList.remove('rotate-180');
                        });
                        content.classList.add('show');
                        icon.classList.add('rotate-180');
                    }
                });
            });
        }

        // --- New Feature: Hypothesis Testing (T-test) ---
        /**
         * Performs a Welch's t-test to compare means of two independent groups.
         * @param {string} numericColName - The name of the numeric column.
         * @param {string} categoricalColName - The name of the categorical column defining groups.
         * @param {string} group1Value - The value in the categorical column for group 1.
         * @param {string} group2Value - The value in the categorical column for group 2.
         * @param {Array<Object>} data - The dataset.
         * @returns {Object} An object containing t-statistic, degrees of freedom, and interpretation.
         */
        function performTTest(numericColName, categoricalColName, group1Value, group2Value, data) {
            const group1Data = data.filter(row => row[categoricalColName] === group1Value).map(row => Number(row[numericColName])).filter(n => !isNaN(n));
            const group2Data = data.filter(row => row[categoricalColName] === group2Value).map(row => Number(row[numericColName])).filter(n => !isNaN(n));

            if (group1Data.length < 2 || group2Data.length < 2) {
                return { error: 'Not enough data points for both groups (minimum 2 per group required).' };
            }

            const n1 = group1Data.length;
            const n2 = group2Data.length;
            const mean1 = group1Data.reduce((a, b) => a + b, 0) / n1;
            const mean2 = group2Data.reduce((a, b) => a + b, 0) / n2;

            const variance1 = group1Data.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);
            const variance2 = group2Data.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);

            const numerator = mean1 - mean2;
            const denominator = Math.sqrt((variance1 / n1) + (variance2 / n2));

            if (denominator === 0) {
                return { error: 'Denominator is zero, likely due to zero variance in one or both groups. Cannot perform t-test.' };
            }

            const tStatistic = numerator / denominator;

            // Welch-Satterthwaite equation for degrees of freedom
            const dfNumerator = Math.pow((variance1 / n1) + (variance2 / n2), 2);
            const dfDenominator = (Math.pow(variance1 / n1, 2) / (n1 - 1)) + (Math.pow(variance2 / n2, 2) / (n2 - 1));
            const degreesOfFreedom = dfDenominator === 0 ? Math.min(n1, n2) - 1 : dfNumerator / dfDenominator; // Fallback if dfDenominator is zero

            let interpretation = '';
            // Simplified interpretation for t-statistic (very rough guide without p-value table)
            if (Math.abs(tStatistic) > 2) { // Common threshold for significance at alpha=0.05 for large df
                interpretation = `This suggests a statistically **significant difference** between the means of "${group1Value}" and "${group2Value}" for "${numericColName}".`;
            } else {
                interpretation = `There is **no strong evidence of a statistically significant difference** between the means of "${group1Value}" and "${group2Value}" for "${numericColName}".`;
            }

            return {
                tStatistic: tStatistic.toFixed(3),
                degreesOfFreedom: degreesOfFreedom.toFixed(2),
                interpretation: interpretation,
                group1Mean: mean1.toFixed(2),
                group2Mean: mean2.toFixed(2),
                group1Count: n1,
                group2Count: n2
            };
        }

        // --- New Feature: Time Series Analysis (Moving Average) ---
        /**
         * Calculates a simple moving average for a numeric column and adds it as a new column.
         * Assumes data might not be pre-sorted by date/time, so it processes based on row index.
         * For true time series, data should be sorted by a date column first.
         * @param {string} numericColName - The name of the numeric column.
         * @param {number} windowSize - The number of periods to include in the moving average.
         * @param {string} newColName - The name of the new column for moving average.
         * @param {Array<Object>} data - The dataset.
         * @returns {Object} Success status and message.
         */
        function calculateMovingAverage(numericColName, windowSize, newColName, data) {
            if (windowSize <= 0) {
                return { success: false, message: 'Window size must be a positive number.' };
            }
            if (!findNumericColumn(numericColName)) {
                return { success: false, message: `Numeric column "${numericColName}" not found or is not numeric.` };
            }
            if (Object.keys(schema).includes(newColName)) {
                return { success: false, message: `Column "${newColName}" already exists.` };
            }

            const updatedData = data.map((row, index, arr) => {
                const newRow = { ...row };
                let sum = 0;
                let count = 0;

                // Calculate average over the window
                // This implements a 'trailing' moving average (current point + previous windowSize-1 points)
                for (let i = Math.max(0, index - windowSize + 1); i <= index; i++) {
                    const value = Number(arr[i][numericColName]);
                    if (!isNaN(value)) {
                        sum += value;
                        count++;
                    }
                }
                newRow[newColName] = count > 0 ? (sum / count).toFixed(2) : ''; // Store as string with 2 decimal places

                return newRow;
            });

            rawData = updatedData;
            schema[newColName] = 'number'; // The new column is numeric
            displaySchema(schema);

            return { success: true, message: `Successfully calculated **${windowSize}-period moving average** for "<strong>${numericColName}</strong>" and added it as a new column "<strong>${newColName}</strong>".` };
        }

        // --- New Feature: Multiple Linear Regression (Gradient Descent) ---
        /**
         * Performs Multiple Linear Regression using Gradient Descent.
         * @param {string} dependentCol - Name of the dependent variable column.
         * @param {Array<string>} independentCols - Array of independent variable column names.
         * @param {Array<Object>} data - The dataset.
         * @param {number} learningRate - Learning rate for gradient descent.
         * @param {number} iterations - Number of iterations for gradient descent.
         * @returns {Object} Coefficients (intercept and slopes) and R-squared.
         */
        function calculateMultipleLinearRegression(dependentCol, independentCols, data, learningRate = 0.01, iterations = 5000) {
            // Filter out rows with non-numeric values in relevant columns
            const relevantCols = [dependentCol, ...independentCols];
            const filteredData = data.filter(row =>
                relevantCols.every(col => !isNaN(Number(row[col])) && row[col] !== null && row[col] !== undefined && row[col] !== '')
            );

            if (filteredData.length < independentCols.length + 1) { // Need at least (num_features + 1) data points
                return { error: 'Not enough valid data points for regression. Need at least as many points as independent variables plus one for the intercept.' };
            }

            const N = filteredData.length;
            const numFeatures = independentCols.length;

            // Initialize coefficients (including intercept) to zeros or small random values
            let coefficients = Array(numFeatures + 1).fill(0); // [intercept, beta1, beta2, ...]

            // Gradient Descent
            for (let iter = 0; iter < iterations; iter++) {
                let gradients = Array(numFeatures + 1).fill(0);

                for (let i = 0; i < N; i++) {
                    const x_i = [1]; // Start with 1 for the intercept term
                    independentCols.forEach(col => x_i.push(Number(filteredData[i][col])));

                    const y_i = Number(filteredData[i][dependentCol]);

                    // Calculate prediction (y_hat)
                    let y_hat = 0;
                    for (let j = 0; j <= numFeatures; j++) {
                        y_hat += coefficients[j] * x_i[j];
                    }

                    const error = y_i - y_hat;

                    // Update gradients
                    for (let j = 0; j <= numFeatures; j++) {
                        gradients[j] += (error * x_i[j]);
                    }
                }

                // Update coefficients
                for (let j = 0; j <= numFeatures; j++) {
                    coefficients[j] += learningRate * (gradients[j] / N);
                }
            }

            // Calculate R-squared
            let totalSumOfSquares = 0;
            let residualSumOfSquares = 0;
            const meanY = calculateColumnAverage(dependentCol, filteredData);

            for (let i = 0; i < N; i++) {
                const x_i = [1];
                independentCols.forEach(col => x_i.push(Number(filteredData[i][col])));
                const y_i = Number(filteredData[i][dependentCol]);

                let y_hat = 0;
                for (let j = 0; j <= numFeatures; j++) {
                    y_hat += coefficients[j] * x_i[j];
                }

                totalSumOfSquares += Math.pow(y_i - meanY, 2);
                residualSumOfSquares += Math.pow(y_i - y_hat, 2);
            }

            const rSquared = totalSumOfSquares === 0 ? 0 : (1 - (residualSumOfSquares / totalSumOfSquares));

            let result = {
                intercept: coefficients[0].toFixed(4),
                rSquared: rSquared.toFixed(4),
                slopes: {}
            };
            independentCols.forEach((col, index) => {
                result.slopes[col] = coefficients[index + 1].toFixed(4);
            });

            return result;
        }

        // --- Helper for Polynomial Features ---
        /**
         * Generates polynomial features for a given numeric value up to a specified degree.
         * @param {number} value - The numeric value.
         * @param {number} degree - The maximum polynomial degree.
         * @returns {Array<number>} An array of [value, value^2, ..., value^degree].
         */
        function generatePolynomialFeatures(value, degree) {
            const features = [];
            for (let i = 1; i <= degree; i++) {
                features.push(Math.pow(value, i));
            }
            return features;
        }

        // --- K-Means Clustering Helper Functions ---
        /**
         * Calculates the Euclidean distance between two points.
         * @param {Array<number>} p1 - First point.
         * @param {Array<number>} p2 - Second point.
         * @returns {number} Euclidean distance.
         */
        function euclideanDistance(p1, p2) {
            let sum = 0;
            for (let i = 0; i < p1.length; i++) {
                sum += Math.pow(p1[i] - p2[i], 2);
            }
            return Math.sqrt(sum);
        }

        /**
         * Initializes K centroids randomly from the data points.
         * @param {Array<Array<number>>} dataPoints - Array of data points (each point is an array of feature values).
         * @param {number} k - Number of clusters.
         * @returns {Array<Array<number>>} Initial centroids.
         */
        function initializeCentroids(dataPoints, k) {
            const centroids = [];
            const dataLength = dataPoints.length;
            // Ensure k is not greater than data points count
            const numCentroidsToPick = Math.min(k, dataLength);
            const indices = new Set();
            while (indices.size < numCentroidsToPick) {
                const randomIndex = Math.floor(Math.random() * dataLength);
                if (!indices.has(randomIndex)) {
                    indices.add(randomIndex);
                    centroids.push([...dataPoints[randomIndex]]); // Copy the point
                }
            }
            return centroids;
        }

        /**
         * Assigns each data point to the closest centroid.
         * @param {Array<Array<number>>} dataPoints - Array of data points.
         * @param {Array<Array<number>>} centroids - Current centroids.
         * @returns {Array<number>} Array of cluster assignments (index of closest centroid for each data point).
         */
        function assignDataToClusters(dataPoints, centroids) {
            const assignments = [];
            for (const point of dataPoints) {
                let minDistance = Infinity;
                let clusterId = -1;
                for (let i = 0; i < centroids.length; i++) {
                    const dist = euclideanDistance(point, centroids[i]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        clusterId = i;
                    }
                }
                assignments.push(clusterId);
            }
            return assignments;
        }

        /**
         * Recalculates centroids based on the mean of points in each cluster.
         * @param {Array<Array<number>>} dataPoints - Array of data points.
         * @param {Array<number>} assignments - Cluster assignments for each data point.
         * @param {number} k - Number of clusters.
         * @param {number} numFeatures - Number of features in each data point.
         * @returns {Array<Array<number>>} New centroids.
         */
        function recalculateCentroids(dataPoints, assignments, k, numFeatures) {
            const newCentroids = Array(k).fill(0).map(() => Array(numFeatures).fill(0));
            const counts = Array(k).fill(0);

            for (let i = 0; i < dataPoints.length; i++) {
                const clusterId = assignments[i];
                if (clusterId !== -1) { // Only if assigned to a cluster
                    for (let j = 0; j < numFeatures; j++) {
                        newCentroids[clusterId][j] += dataPoints[i][j];
                    }
                    counts[clusterId]++;
                }
            }

            for (let i = 0; i < k; i++) {
                if (counts[i] > 0) {
                    for (let j = 0; j < numFeatures; j++) {
                        newCentroids[i][j] /= counts[i];
                    }
                } else {
                    // Handle empty cluster: re-initialize random point or a point furthest from other centroids
                    // For simplicity in a prototype, we'll re-initialize it to a random data point
                    newCentroids[i] = dataPoints[Math.floor(Math.random() * dataPoints.length)];
                }
            }
            return newCentroids;
        }

        /**
         * Performs K-Means clustering on specified numeric columns.
         * Adds a new column to rawData with the assigned cluster ID.
         * @param {Array<string>} featureCols - Names of numeric columns to use for clustering.
         * @param {number} k - Number of clusters.
         * @param {string} newColName - Name of the new column to store cluster IDs.
         * @param {Array<Object>} data - The dataset (rawData).
         * @param {number} maxIterations - Maximum iterations for convergence.
         * @param {number} tolerance - Minimum change in centroids to continue iterating.
         * @returns {Object} Success status, message, and cluster distribution.
         */
        function performKMeansClustering(featureCols, k, newColName, data, maxIterations = 100, tolerance = 0.001) {
            // Validate columns and data
            const validFeatureCols = featureCols.filter(col => findNumericColumn(col));
            if (validFeatureCols.length === 0) {
                return { success: false, message: 'No valid numeric columns provided for clustering.' };
            }
            if (k <= 0) {
                return { success: false, message: 'Number of clusters (k) must be a positive integer.' };
            }
            if (Object.keys(schema).includes(newColName)) {
                return { success: false, message: `Column "${newColName}" already exists. Please choose a different name.` };
            }

            const dataPoints = data.map(row => validFeatureCols.map(col => Number(row[col]))).filter(point => !point.some(isNaN));

            if (dataPoints.length < k) {
                return { success: false, message: `Not enough valid data points (${dataPoints.length}) to form ${k} clusters. You need at least k data points.` };
            }

            const numFeatures = validFeatureCols.length;
            let centroids = initializeCentroids(dataPoints, k);
            let assignments = [];
            let previousCentroids = [];

            for (let iter = 0; iter < maxIterations; iter++) {
                assignments = assignDataToClusters(dataPoints, centroids);
                previousCentroids = [...centroids.map(c => [...c])]; // Deep copy
                centroids = recalculateCentroids(dataPoints, assignments, k, numFeatures);

                // Check for convergence
                let converged = true;
                for (let i = 0; i < k; i++) {
                    if (euclideanDistance(centroids[i], previousCentroids[i]) > tolerance) {
                        converged = false;
                        break;
                    }
                }
                if (converged) break;
            }

            // Add cluster assignments to the rawData
            let dataPointIndex = 0;
            rawData = rawData.map(row => {
                const numericValues = validFeatureCols.map(col => Number(row[col]));
                if (!numericValues.some(isNaN)) {
                    // This row was included in dataPoints for clustering
                    const assignedCluster = assignments[dataPointIndex];
                    dataPointIndex++; // Increment only for valid rows
                    return { ...row, [newColName]: `Cluster ${assignedCluster}` };
                } else {
                    // This row was skipped, assign a default
                    return { ...row, [newColName]: 'N/A_Cluster' };
                }
            });

            schema[newColName] = 'string'; // Cluster IDs are categorical strings
            displaySchema(schema);

            // Calculate cluster distribution
            const clusterDistribution = {};
            rawData.forEach(row => {
                const cluster = row[newColName];
                clusterDistribution[cluster] = (clusterDistribution[cluster] || 0) + 1;
            });

            return {
                success: true,
                message: `Successfully performed K-Means clustering with **${k} clusters** and added cluster assignments to the new column "<strong>${newColName}</strong>".`,
                distribution: clusterDistribution
            };
        }

        // --- New Feature: Data Pivoting (Pivot Table Creation) ---
        /**
         * Creates a pivot table from the raw data.
         * @param {string} indexColName - The column to use for rows of the pivot table.
         * @param {string} pivotColName - The column to use for new columns of the pivot table.
         * @param {string} valueColName - The numeric column to aggregate.
         * @param {string} aggregationType - 'sum', 'average', or 'count'.
         * @param {Array<Object>} data - The raw data.
         * @returns {string} An HTML string representing the pivot table.
         */
        function createPivotTable(indexColName, pivotColName, valueColName, aggregationType, data) {
            const actualIndexCol = findColumnByName(indexColName);
            const actualPivotCol = findColumnByName(pivotColName);
            const actualValueCol = findNumericColumn(valueColName);

            if (!actualIndexCol || !actualPivotCol || !actualValueCol) {
                return { error: 'Invalid column names provided for pivot table. Ensure index, pivot, and value columns exist and value column is numeric.' };
            }
            if (!['sum', 'average', 'count'].includes(aggregationType)) {
                return { error: 'Invalid aggregation type. Use "sum", "average", or "count".' };
            }

            const pivotData = {}; // Stores {rowIndex: {colName: {sum: X, count: Y}}}
            const pivotColumnHeaders = new Set();

            data.forEach(row => {
                const rowIndex = row[actualIndexCol];
                const pivotIndex = row[actualPivotCol];
                const value = Number(row[actualValueCol]);

                if (rowIndex !== undefined && pivotIndex !== undefined && !isNaN(value)) {
                    if (!pivotData[rowIndex]) {
                        pivotData[rowIndex] = {};
                    }
                    if (!pivotData[rowIndex][pivotIndex]) {
                        pivotData[rowIndex][pivotIndex] = { sum: 0, count: 0 };
                    }
                    pivotData[rowIndex][pivotIndex].sum += value;
                    pivotData[rowIndex][pivotIndex].count++;
                    pivotColumnHeaders.add(pivotIndex);
                }
            });

            const sortedRowHeaders = Object.keys(pivotData).sort();
            const sortedPivotColumnHeaders = Array.from(pivotColumnHeaders).sort();

            let tableHtml = `<table class="command-table text-gray-200">
                                <thead>
                                    <tr>
                                        <th class="bg-gray-700">${actualIndexCol} / ${actualPivotCol}</th>`;
            sortedPivotColumnHeaders.forEach(header => {
                tableHtml += `<th class="bg-gray-700">${header}</th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedRowHeaders.forEach(rowIndex => {
                tableHtml += `<tr><td class="bg-gray-800 font-semibold">${rowIndex}</td>`;
                sortedPivotColumnHeaders.forEach(colIndex => {
                    const cellData = pivotData[rowIndex] && pivotData[rowIndex][colIndex];
                    let displayValue = '';
                    if (cellData) {
                        if (aggregationType === 'sum') {
                            displayValue = cellData.sum.toFixed(2);
                        } else if (aggregationType === 'average') {
                            displayValue = (cellData.sum / cellData.count).toFixed(2);
                        } else if (aggregationType === 'count') {
                            displayValue = cellData.count;
                        }
                    }
                    tableHtml += `<td>${displayValue}</td>`;
                });
                tableHtml += `</tr>`;
            });
            tableHtml += `</tbody></table>`;

            return { success: true, tableHtml: tableHtml };
        }

        // --- New Feature: Data Unpivoting (Melt) ---
        /**
         * Unpivots (melts) specified columns into new variable and value columns.
         * Updates rawData and schema in place.
         * @param {Array<string>} idColNames - Columns to keep as identifying variables.
         * @param {Array<string>} colsToUnpivotNames - Columns to unpivot.
         * @param {string} newVarColName - Name for the new column storing original column names.
         * @param {string} newValColName - Name for the new column storing original values.
         * @param {Array<Object>} data - The raw data (will be modified).
         * @param {Object} currentSchema - The schema (will be modified).
         * @returns {Object} Success status and message.
         */
        function unpivotData(idColNames, colsToUnpivotNames, newVarColName, newValColName, data, currentSchema) {
            const actualIdCols = idColNames.map(col => findColumnByName(col)).filter(Boolean);
            const actualColsToUnpivot = colsToUnpivotNames.map(col => findColumnByName(col)).filter(Boolean);

            if (actualIdCols.length !== idColNames.length) {
                return { success: false, message: `One or more ID columns not found: ${idColNames.filter(name => !findColumnByName(name)).join(', ')}.` };
            }
            if (actualColsToUnpivot.length !== colsToUnpivotNames.length) {
                return { success: false, message: `One or more columns to unpivot not found: ${colsToUnpivotNames.filter(name => !findColumnByName(name)).join(', ')}.` };
            }
            if (Object.keys(currentSchema).includes(newVarColName) || Object.keys(currentSchema).includes(newValColName)) {
                return { success: false, message: `New column names ("${newVarColName}" or "${newValColName}") already exist.` };
            }
            if (actualColsToUnpivot.length === 0) {
                 return { success: false, message: 'No valid columns provided to unpivot.' };
            }

            const newRawData = [];
            data.forEach(row => {
                // Extract ID columns for the current row
                const idValues = {};
                actualIdCols.forEach(col => {
                    idValues[col] = row[col];
                });

                // For each column to unpivot, create a new row
                actualColsToUnpivot.forEach(unpivotCol => {
                    const newRow = {
                        ...idValues,
                        [newVarColName]: unpivotCol, // The name of the original column
                        [newValColName]: row[unpivotCol] // The value from the original column
                    };
                    newRawData.push(newRow);
                });
            });

            // Update global rawData
            rawData = newRawData;

            // Update global schema
            const newSchema = {};
            actualIdCols.forEach(col => {
                newSchema[col] = currentSchema[col];
            });
            newSchema[newVarColName] = 'string'; // The variable column will always be string
            // Infer type for the new value column (could be number or string)
            const isNewValNumeric = newRawData.every(row => row[newValColName] === '' || !isNaN(Number(newRawData[0][newValColName]))); // Check first element for type
            newSchema[newValColName] = isNewValNumeric ? 'number' : 'string';
            
            schema = newSchema;
            displaySchema(schema); // Refresh schema display

            return {
                success: true,
                message: `Successfully unpivoted data. Original columns "${actualColsToUnpivot.join(', ')}" are now in new columns "<strong>${newVarColName}</strong>" and "<strong>${newValColName}</strong>".`
            };
        }


        // Helper function to simulate typing into chat and submitting
        function typeIntoChatAndSubmit(command) {
            chatInput.value = command;
            sendMessageBtn.click();
            proactiveInsightsOverlay.classList.add('hidden'); // Close the insights overlay
        }


        // Simulate AI response based on direct command matching (NLU removed)
        function simulateAIResponse(query, isResort = false) {
            let aiResponseText = '';
            let analysisContent = '';
            const lowerQuery = query.toLowerCase();

            // Clear chat if this is a "show all data" command triggered by a sort
            // This prevents duplicate messages when sorting re-renders the table.
            if (isResort && (lowerQuery.includes('show all data') || lowerQuery.includes('display everything') || lowerQuery.includes('what\'s in the dataset'))) {
                // Remove only messages related to the previous "show all data" output.
                // A more robust solution might clear specific content divs instead of entire messages.
                // For this prototype, we'll clear all previous AI messages (which includes old tables).
                const aiMessages = chatArea.querySelectorAll('.flex.items-start');
                aiMessages.forEach(msg => {
                    // Check if the message contains a data-table.
                    if (msg.nextElementSibling && msg.nextElementSibling.querySelector('.data-table')) {
                         msg.remove(); // Remove the AI message bubble
                         msg.nextElementSibling.remove(); // Remove the data table container
                    }
                });
                 // To re-add AI message for the sorted table.
                appendMessage('AI', `Here's your data, sorted by "<strong>${currentSortColumn}</strong>" in ${currentSortDirection === 'asc' ? 'ascending' : 'descending'} order:`, 'ai', true); // Skip initial scroll
                analysisContent = createDataTableHtml(rawData, schema, currentSortColumn, currentSortDirection);
                appendMessage('AI', analysisContent, 'ai'); // Append table content
                attachTableSortingListeners(); // Re-attach listeners for the new table
                return;
            }


            if (rawData.length === 0 && !lowerQuery.includes('command guide') && !lowerQuery.includes('data story') && !lowerQuery.includes('create report')) {
                appendMessage('AI', "Please upload a CSV file first before asking questions. I'm ready when you are!", 'ai');
                return;
            }

            // Handle cleaning confirmation
            if (pendingCleaningSuggestion && (lowerQuery === 'yes' || lowerQuery.includes('confirm') || lowerQuery.includes('go ahead'))) {
                const colToClean = pendingCleaningSuggestion.column;
                if (pendingCleaningSuggestion.action === 'fill_average') {
                    const average = calculateColumnAverage(colToClean, rawData);
                    rawData = rawData.map(row => {
                        if (row[colToClean] === '' || isNaN(Number(row[colToClean])) || row[colToClean] === null || row[colToClean] === undefined) {
                            row[colToClean] = average.toFixed(2); // Fill with average, keeping two decimal places
                        }
                        return row;
                    });
                    aiResponseText = `Great! I've successfully filled the ${pendingCleaningSuggestion.count} missing values in the column "<strong>${colToClean}</strong>" with the calculated average of <strong>${average.toFixed(2)}</strong>. Your data has been updated locally and privately.`;
                    pendingCleaningSuggestion = null; // Clear the suggestion after execution
                }
                appendMessage('AI', aiResponseText, 'ai');
                return;
            }

            // --- Command Parsing Logic (Manual instead of NLU) ---

            // General Overview
            if (lowerQuery.includes('show all data') || lowerQuery.includes('display everything') || lowerQuery.includes('what\'s in the dataset')) {
                analysisContent = createDataTableHtml(rawData, schema, currentSortColumn, currentSortDirection);
                aiResponseText = `Understood! Here's your data:`;
            } else if (lowerQuery.startsWith('show ') && lowerQuery.includes(' column')) {
                const colNameMatch = query.match(/show\s+(.+)\s+column/i);
                const colName = colNameMatch ? colNameMatch[1].trim() : null;
                const foundColumn = findColumnByName(colName);
                if (foundColumn) {
                    const columnValues = rawData.map(row => row[foundColumn]);
                    analysisContent = `<p class="text-gray-300 mt-2">Here are the **first 10 values** from the "<strong>${foundColumn}</strong>" column:</p>
                                        <div class="code-block mt-2">${columnValues.slice(0, 10).join('\n')}</div>
                                        <p class="text-sm text-gray-400 mt-2">There are ${columnValues.length} total values in this column.</p>`;
                    aiResponseText = `Absolutely! Here's the data for column "${foundColumn}", retrieved instantly from your local dataset.`;
                } else {
                    aiResponseText = `I couldn't find the column "<strong>${colName}</strong>". Please check your column name.`;
                }
            } else if (lowerQuery.includes('count rows') || lowerQuery.includes('number of records')) {
                const numRows = rawData.length;
                aiResponseText = `Your dataset currently contains **${numRows} rows** (records).`;
            } else if (lowerQuery.includes('describe my dataset') || lowerQuery.includes('overview of data')) {
                let numRows = rawData.length;
                let numCols = Object.keys(schema).length;
                let descriptionNarrative = `<p class="text-gray-300 leading-relaxed mb-3">Alright, let's take a look at your dataset. It appears you have <strong>${numRows} rows</strong>, which means ${numRows} individual records, and <strong>${numCols} columns</strong>, representing ${numCols} different types of information.</p>
                                             <h5 class="text-md font-semibold mt-3 mb-2 text-gray-200">Here's a breakdown of what I found in each column:</h5>
                                             <ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">`;

                for (const col in schema) {
                    descriptionNarrative += `<li class="font-medium">${col}: (<span class="text-blue-400">${schema[col]}</span> type) `;
                    const values = rawData.map(row => row[col]);

                    if (schema[col] === 'number') {
                        const numericValues = values.map(Number).filter(n => !isNaN(n));
                        const { min: minVal, max: maxVal } = calculateColumnMinMax(col, rawData);
                        const avgVal = calculateColumnAverage(col, rawData);
                        const medianVal = calculateMedian(col, rawData);
                        const stdDevVal = calculateStandardDeviation(col, rawData);
                        const quartiles = calculateQuartiles(col, rawData);

                        if (numericValues.length > 0) {
                            descriptionNarrative += `This column contains numerical data, ranging from <strong>${minVal}</strong> to <strong>${maxVal}</strong>, with an average value of approximately <strong>${avgVal.toFixed(2)}</strong>.`;
                            if (medianVal !== null) descriptionNarrative += ` The median is <strong>${medianVal.toFixed(2)}</strong>.`;
                            if (stdDevVal !== null) descriptionNarrative += ` Standard deviation is <strong>${stdDevVal.toFixed(2)}</strong>.`;
                            if (quartiles.q1 !== null) descriptionNarrative += ` Q1 is <strong>${quartiles.q1}</strong>, Q3 is <strong>${quartiles.q3}</strong>, and the IQR is <strong>${quartiles.iqr}</strong>.`;
                            const correlationWithOtherNumerics = [];
                            for (const otherCol in schema) {
                                if (otherCol !== col && schema[otherCol] === 'number') {
                                    const corr = calculateCorrelation(col, otherCol, rawData);
                                    if (corr !== null && !isNaN(corr)) {
                                        correlationWithOtherNumerics.push(`${otherCol}: ${corr.toFixed(2)}`);
                                    }
                                }
                            }
                            if (correlationWithOtherNumerics.length > 0) {
                                descriptionNarrative += ` It shows correlations with other numeric columns: ${correlationWithOtherNumerics.join(', ')}.`;
                            }
                        } else {
                            descriptionNarrative += `This numeric column currently has no valid numerical entries.`;
                        }
                    } else { // string type
                        const uniqueValues = [...new Set(values)];
                        const valueCounts = {};
                        values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                        const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);
                        descriptionNarrative += `This column holds text information. I found <strong>${uniqueValues.length} unique values</strong>. The most frequent entries are: ${sortedCounts.slice(0, 5).map(item => `"${item[0]}" appearing ${item[1]} times`).join(', ')}.`;
                    }
                    descriptionNarrative += `</li>`;
                }
                descriptionNarrative += `</ul>`;
                analysisContent = descriptionNarrative;
                aiResponseText = `Certainly! Here's a comprehensive overview and description of your dataset, crafted to give you quick insights. This analysis was performed entirely client-side, ensuring your data's privacy.`;
            } else if (lowerQuery.includes('show schema')) {
                analysisContent = `<p class="text-gray-300 mt-2">Here's the **schema I inferred** from your uploaded data:</p>
                                    <div class="code-block mt-2">${JSON.stringify(schema, null, 2)}</div>`;
                aiResponseText = `Certainly! I've extracted the schema for you. All schema inference happens privately in your browser.`;
            }

            // Statistical Analysis
            else if (lowerQuery.startsWith('sum ')) {
                const colName = query.substring(4).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const sum = calculateColumnSum(foundColumn, rawData);
                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The sum of "${foundColumn}" is: ${sum.toFixed(2)}</p>`;
                    aiResponseText = `Alright, I've calculated the **total sum** for the column "<strong>${foundColumn}</strong>". Here's the result:`;
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the sum for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('average ') || lowerQuery.startsWith('avg ')) {
                const colName = lowerQuery.startsWith('average ') ? query.substring(8).trim() : query.substring(4).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const average = calculateColumnAverage(foundColumn, rawData);
                    analysisContent = `<p class="text-xl text-blue-400 font-bold mt-2">The average of "${foundColumn}" is: ${average.toFixed(2)}</p>`;
                    aiResponseText = `Understood! Here's the **average value** for the "<strong>${foundColumn}</strong>" column:`;
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the average for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('median ')) {
                const colName = query.substring(7).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const median = calculateMedian(foundColumn, rawData);
                    if (median !== null) {
                        aiResponseText = `The **median** for the column "<strong>${foundColumn}</strong>" is: <strong>${median.toFixed(2)}</strong>.`;
                    } else {
                        aiResponseText = `I couldn't calculate the median for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the median for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('standard deviation ') || lowerQuery.startsWith('std dev ')) {
                const colName = lowerQuery.startsWith('standard deviation ') ? query.substring(19).trim() : query.substring(8).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const stdDev = calculateStandardDeviation(foundColumn, rawData);
                    if (stdDev !== null) {
                        aiResponseText = `The **standard deviation** for the column "<strong>${foundColumn}</strong>" is: <strong>${stdDev.toFixed(2)}</strong>.`;
                    } else {
                        aiResponseText = `I couldn't calculate the standard deviation for "<strong>${foundColumn}</strong>" as it contains insufficient numeric data (at least 2 values are needed).`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the standard deviation for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('quartiles ')) {
                const colName = query.substring(10).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const quartiles = calculateQuartiles(foundColumn, rawData);
                    if (quartiles.median !== null) {
                        aiResponseText = `For the column "<strong>${foundColumn}</strong>":<br>
                                            **Q1 (25th percentile)**: <strong>${quartiles.q1}</strong><br>
                                            **Median (50th percentile)**: <strong>${quartiles.median}</strong><br>
                                            **Q3 (75th percentile)**: <strong>${quartiles.q3}</strong><br>
                                            **IQR (Interquartile Range)**: <strong>${quartiles.iqr}</strong>.`;
                    } else {
                        aiResponseText = `I couldn't calculate quartiles for "<strong>${foundColumn}</strong>" as it contains no valid numeric data.`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate quartiles for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('count unique ')) {
                const colName = query.substring(13).trim();
                const foundColumn = findColumnByName(colName);
                if (foundColumn) {
                    const values = rawData.map(row => row[foundColumn]);
                    const uniqueCount = new Set(values).size;
                    aiResponseText = `The column "<strong>${foundColumn}</strong>" has **${uniqueCount} unique values**.`;
                } else {
                    aiResponseText = `I couldn't find the column "<strong>${colName}</strong>" to count unique values. Please specify a valid column name.`;
                }
            } else if (lowerQuery.startsWith('show frequency of ') || lowerQuery.startsWith('top values in ')) {
                const colName = lowerQuery.startsWith('show frequency of ') ? query.substring(18).trim() : query.substring(14).trim();
                const foundColumn = findColumnByName(colName);
                if (foundColumn) {
                    const values = rawData.map(row => row[foundColumn]);
                    const valueCounts = {};
                    values.forEach(v => { valueCounts[v] = (valueCounts[v] || 0) + 1; });
                    const sortedCounts = Object.entries(valueCounts).sort(([,a],[,b]) => b-a);

                    let frequencyList = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                    sortedCounts.slice(0, 5).forEach(([value, count]) => {
                        const percentage = ((count / values.length) * 100).toFixed(1);
                        frequencyList += `<li>"<strong>${value}</strong>": ${count} occurrences (${percentage}%)</li>`;
                    });
                    frequencyList += `</ul>`;
                    aiResponseText = `Here's the **frequency distribution** for "<strong>${foundColumn}</strong>", showing the top 5 most common values:`;
                    analysisContent = frequencyList;
                } else {
                    aiResponseText = `I couldn't find the column "<strong>${colName}</strong>" to show its frequency. Please specify a valid column name.`;
                }
            } else if (lowerQuery.startsWith('min ')) {
                const colName = query.substring(4).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const { min } = calculateColumnMinMax(foundColumn, rawData);
                    if (min !== null) {
                        aiResponseText = `For the numeric column "<strong>${foundColumn}</strong>":<br>The **minimum value** is: <strong>${min}</strong>.`;
                    } else {
                        aiResponseText = `There are no valid numeric entries in "<strong>${foundColumn}</strong>" to calculate the minimum.`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the minimum for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('max ')) {
                const colName = query.substring(4).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const { max } = calculateColumnMinMax(foundColumn, rawData);
                    if (max !== null) {
                        aiResponseText = `For the numeric column "<strong>${foundColumn}</strong>":<br>The **maximum value** is: <strong>${max}</strong>.`;
                    } else {
                        aiResponseText = `There are no valid numeric entries in "<strong>${foundColumn}</strong>" to calculate the maximum.`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to calculate the maximum for. Please specify a valid numeric column.`;
                }
            } else if (lowerQuery.startsWith('average ') && lowerQuery.includes(' by ')) {
                const parts = query.match(/average\s+(.+)\s+by\s+(.+)/i);
                if (parts && parts.length === 3) {
                    const numericColName = parts[1].trim();
                    const categoricalColName = parts[2].trim();
                    const numericColumn = findNumericColumn(numericColName);
                    const categoricalColumn = findCategoricalColumn(categoricalColName);

                    if (numericColumn && categoricalColumn) {
                        const groupedAverages = {};
                        const counts = {};

                        rawData.forEach(row => {
                            const category = row[categoricalColumn];
                            const numericValue = Number(row[numericColumn]);

                            if (!isNaN(numericValue)) {
                                if (!groupedAverages[category]) {
                                    groupedAverages[category] = 0;
                                    counts[category] = 0;
                                }
                                groupedAverages[category] += numericValue;
                                counts[category]++;
                            }
                        });

                        let resultsHtml = `<ul class="list-disc list-inside text-gray-300 ml-4 mt-2 space-y-1">`;
                        for (const category in groupedAverages) {
                            const avg = (groupedAverages[category] / counts[category]).toFixed(2);
                            resultsHtml += `<li><strong>${category}</strong>: Average ${numericColumn} is <strong>${avg}</strong> (${counts[category]} entries)</li>`;
                        }
                        resultsHtml += `</ul>`;
                        aiResponseText = `Here's the **average of "${numericColumn}" grouped by "${categoricalColumn}"**:`;
                        analysisContent = resultsHtml;
                    } else {
                        aiResponseText = `I need both a valid numeric column and a valid categorical column to perform that aggregation. Please check your column names and types.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the format for 'average by category'. Example: 'average sales by region'.`;
                }
            } else if (lowerQuery.startsWith('show correlation between ')) {
                const parts = query.match(/show correlation between\s+(.+)\s+and\s+(.+)/i);
                if (parts && parts.length === 3) {
                    const col1Name = parts[1].trim();
                    const col2Name = parts[2].trim();
                    const col1 = findNumericColumn(col1Name);
                    const col2 = findNumericColumn(col2Name);

                    if (col1 && col2) {
                        const correlation = calculateCorrelation(col1, col2, rawData);
                        if (correlation !== null) {
                            let interpretation = '';
                            if (correlation >= 0.7) interpretation = 'a **strong positive correlation**';
                            else if (correlation >= 0.3) interpretation = 'a **moderate positive correlation**';
                            else if (correlation > -0.3 && correlation < 0.3) interpretation = 'a **very weak or no linear correlation**';
                            else if (correlation > -0.7) interpretation = 'a **moderate negative correlation**';
                            else interpretation = 'a **strong negative correlation**';
                            aiResponseText = `The **Pearson correlation coefficient** between "<strong>${col1}</strong>" and "<strong>${col2}</strong>" is: <strong>${correlation.toFixed(4)}</strong>. This indicates ${interpretation}.`;
                        } else {
                            aiResponseText = `I couldn't calculate the correlation between "<strong>${col1}</strong>" and "<strong>${col2}</strong>" due to insufficient or invalid numeric data.`;
                        }
                    } else {
                        aiResponseText = `I need two valid numeric columns. Please check your column names and types.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the format for 'correlation'. Example: 'show correlation between Age and Income'.`;
                }
            } else if (lowerQuery.startsWith('find outliers in ')) {
                const colName = query.substring(17).trim();
                const foundColumn = findNumericColumn(colName);
                if (foundColumn) {
                    const { outliers, lowerBound, upperBound } = findOutliers(foundColumn, rawData);
                    if (outliers.length > 0) {
                        aiResponseText = `I found **${outliers.length} potential outliers** in the column "<strong>${foundColumn}</strong>".<br>
                                            These values fall outside the IQR bounds of <strong>${lowerBound}</strong> and <strong>${upperBound}</strong>.<br>
                                            Outlier values (first 10): <strong>${outliers.slice(0, 10).join(', ')}</strong>.`;
                    } else {
                        aiResponseText = `No significant outliers were detected in the column "<strong>${foundColumn}</strong>" based on the IQR method.`;
                    }
                } else {
                    aiResponseText = `I couldn't find a numeric column named "<strong>${colName}</strong>" to find outliers. Please specify a valid numeric column.`;
                }
            }

            // --- New Command: Hypothesis Testing (T-test) ---
            else if (lowerQuery.startsWith('perform t-test on ') && lowerQuery.includes(' for ') && lowerQuery.includes(' where ') && lowerQuery.includes(' vs ')) {
                const regex = /perform t-test on\s+(.+)\s+for\s+(.+)\s+where\s+(.+)\s+vs\s+(.+)/i;
                const match = query.match(regex);
                if (match && match.length === 5) {
                    const numericColName = match[1].trim();
                    const categoricalColName = match[2].trim();
                    const group1Value = match[3].trim();
                    const group2Value = match[4].trim();

                    const numericCol = findNumericColumn(numericColName);
                    const categoricalCol = findCategoricalColumn(categoricalColName);

                    if (numericCol && categoricalCol) {
                        const tTestResult = performTTest(numericCol, categoricalCol, group1Value, group2Value, rawData);
                        if (tTestResult.error) {
                            aiResponseText = `Error performing T-test: ${tTestResult.error}`;
                        } else {
                            aiResponseText = `**T-Test Results** for **${numericCol}** between "${group1Value}" and "${group2Value}" in **${categoricalCol}**:<br>
                                            - Mean for "${group1Value}": <strong>${tTestResult.group1Mean}</strong> (n=${tTestResult.group1Count})<br>
                                            - Mean for "${group2Value}": <strong>${tTestResult.group2Mean}</strong> (n=${tTestResult.group2Count})<br>
                                            - Calculated T-Statistic: <strong>${tTestResult.tStatistic}</strong><br>
                                            - Degrees of Freedom: <strong>${tTestResult.degreesOfFreedom}</strong><br>
                                            - **Interpretation**: ${tTestResult.interpretation}`;
                        }
                    } else {
                        aiResponseText = `To perform a T-test, I need a valid numeric column and a valid categorical column to define the groups. Please check your column names.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the T-test command format. Example: 'perform t-test on Sales for Region where East vs West'.`;
                }
            }

            // --- New Command: Time Series Analysis (Moving Average) ---
            else if (lowerQuery.startsWith('calculate moving average of ') && lowerQuery.includes(' with window ') && lowerQuery.includes(' as ')) {
                const regex = /calculate moving average of\s+(.+)\s+with window\s+(\d+)\s+as\s+(.+)/i;
                const match = query.match(regex);
                if (match && match.length === 4) {
                    const numericColName = match[1].trim();
                    const windowSize = parseInt(match[2].trim());
                    const newColName = match[3].trim().replace(/\s/g, '_');

                    const numericCol = findNumericColumn(numericColName);

                    if (numericCol) {
                        const result = calculateMovingAverage(numericCol, windowSize, newColName, rawData);
                        aiResponseText = result.message;
                    } else {
                        aiResponseText = `I couldn't find a numeric column named "<strong>${numericColName}</strong>" to calculate moving average. Please specify a valid numeric column.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the moving average command format. Example: 'calculate moving average of Stock_Price with window 5 as MA_5_Days'.`;
                }
            }

            // --- New Command: Multiple Linear Regression ---
            else if (lowerQuery.startsWith('perform multiple regression with y as ') && lowerQuery.includes(' and x as ')) {
                const regex = /perform multiple regression with y as\s+(.+?)\s+and x as\s+(.+)/i; // Changed to non-greedy for y
                const match = query.match(regex);
                if (match && match.length === 3) {
                    const dependentColName = match[1].trim();
                    const independentColsString = match[2].trim();
                    const independentColNames = independentColsString.split(',').map(col => col.trim());

                    const dependentCol = findNumericColumn(dependentColName);
                    const independentCols = independentColNames.map(col => findNumericColumn(col)).filter(Boolean); // Filter out nulls

                    if (!dependentCol) {
                        aiResponseText = `Dependent variable "<strong>${dependentColName}</strong>" not found or is not numeric.`;
                    } else if (independentCols.length !== independentColNames.length) {
                        aiResponseText = `One or more independent variables (${independentColNames.filter(name => !findNumericColumn(name)).join(', ')}) not found or are not numeric.`;
                    } else if (independentCols.length === 0) {
                        aiResponseText = `Please provide at least one independent variable for multiple regression.`;
                    } else {
                        const regressionResult = calculateMultipleLinearRegression(dependentCol, independentCols, rawData);
                        if (regressionResult.error) {
                            aiResponseText = `Error performing multiple linear regression: ${regressionResult.error}`;
                        } else {
                            let slopesHtml = '';
                            for (const col in regressionResult.slopes) {
                                slopesHtml += `<li><strong>${col}</strong>: ${regressionResult.slopes[col]}</li>`;
                            }
                            aiResponseText = `**Multiple Linear Regression Results** (Y: ${dependentCol}):<br>
                                            - **Intercept**: <strong>${regressionResult.intercept}</strong><br>
                                            - **Slopes**: <ul>${slopesHtml}</ul>
                                            - **R-squared**: <strong>${regressionResult.rSquared}</strong><br>
                                            This model explains **${(parseFloat(regressionResult.rSquared) * 100).toFixed(2)}%** of the variance in "${dependentCol}".`;
                        }
                    }
                } else {
                    aiResponseText = `I didn't understand the multiple regression command format. Example: 'perform multiple regression with Y as Sales and X as Advertising, Price'.`;
                }
            }

            // --- New Command: Polynomial Regression ---
            else if (lowerQuery.startsWith('perform polynomial regression with y as ') && lowerQuery.includes(' and x as ') && lowerQuery.includes(' with degree ')) {
                const regex = /perform polynomial regression with y as\s+(.+?)\s+and x as\s+(.+?)\s+with degree\s+(\d+)/i; // Changed to non-greedy
                const match = query.match(regex);
                if (match && match.length === 4) {
                    const dependentColName = match[1].trim();
                    const independentColName = match[2].trim();
                    const degree = parseInt(match[3].trim());

                    const dependentCol = findNumericColumn(dependentColName);
                    const independentCol = findNumericColumn(independentColName);

                    if (!dependentCol) {
                        aiResponseText = `Dependent variable "<strong>${dependentColName}</strong>" not found or is not numeric.`;
                    } else if (!independentCol) {
                        aiResponseText = `Independent variable "<strong>${independentColName}</strong>" not found or is not numeric.`;
                    } else if (degree < 2 || degree > 5) { // Limit degree to avoid overfitting and computational burden
                        aiResponseText = `Polynomial degree must be between 2 and 5 for practical analysis.`;
                    } else {
                        // Create temporary columns for polynomial features
                        const tempIndependentCols = [];
                        const tempRawData = JSON.parse(JSON.stringify(rawData)); // Deep copy to avoid modifying original rawData directly

                        for (let i = 1; i <= degree; i++) {
                            const newPolyColName = `${independentCol}_poly_${i}`;
                            tempIndependentCols.push(newPolyColName);
                            tempRawData.forEach(row => {
                                const originalValue = Number(row[independentCol]);
                                if (!isNaN(originalValue)) {
                                    row[newPolyColName] = Math.pow(originalValue, i);
                                } else {
                                    row[newPolyColName] = NaN; // Mark as NaN if original is not a number
                                }
                            });
                        }

                        const regressionResult = calculateMultipleLinearRegression(dependentCol, tempIndependentCols, tempRawData);

                        if (regressionResult.error) {
                            aiResponseText = `Error performing polynomial regression: ${regressionResult.error}`;
                        } else {
                            let slopesHtml = '';
                            for (const col of tempIndependentCols) { // Use tempIndependentCols to iterate through generated columns
                                slopesHtml += `<li><strong>${col}</strong>: ${regressionResult.slopes[col]}</li>`;
                            }
                            aiResponseText = `**Polynomial Regression Results** (Y: ${dependentCol}, X: ${independentCol}, Degree: ${degree}):<br>
                                            - **Intercept**: <strong>${regressionResult.intercept}</strong><br>
                                            - **Coefficients for polynomial terms**: <ul>${slopesHtml}</ul>
                                            - **R-squared**: <strong>${regressionResult.rSquared}</strong><br>
                                            This model explains **${(parseFloat(regressionResult.rSquared) * 100).toFixed(2)}%** of the variance in "${dependentCol}" using polynomial terms of "${independentCol}".`;
                        }
                    }
                } else {
                    aiResponseText = `I didn't understand the polynomial regression command format. Example: 'perform polynomial regression with Y as Sales and X as Advertising with degree 2'.`;
                }
            }

            // --- New Command: K-Means Clustering ---
            else if (lowerQuery.startsWith('perform k-means clustering on ') && lowerQuery.includes(' into ') && lowerQuery.includes(' clusters as ')) {
                const regex = /perform k-means clustering on\s+([^,]+(?:,\s*[^,]+)*?)\s+into\s+(\d+)\s+clusters as\s+(.+)/i; // Changed to non-greedy for cols and newColName
                const match = query.match(regex);
                if (match && match.length === 4) {
                    const featureColsString = match[1].trim();
                    const k = parseInt(match[2].trim());
                    const newColName = match[3].trim().replace(/\s/g, '_');

                    const requestedFeatureCols = featureColsString.split(',').map(col => col.trim());
                    const validFeatureCols = requestedFeatureCols.filter(name => findNumericColumn(name));

                    if (validFeatureCols.length !== requestedFeatureCols.length) {
                        aiResponseText = `One or more specified columns for clustering (${requestedFeatureCols.filter(name => !findNumericColumn(name)).join(', ')}) are not found or not numeric.`;
                    } else {
                        const clusteringResult = performKMeansClustering(validFeatureCols, k, newColName, rawData);
                        if (clusteringResult.success) {
                            let distributionHtml = '<ul>';
                            for (const cluster in clusteringResult.distribution) {
                                distributionHtml += `<li>${cluster}: <strong>${clusteringResult.distribution[cluster]} data points</strong></li>`;
                            }
                            distributionHtml += '</ul>';
                            aiResponseText = `${clusteringResult.message}<br><br>
                                            **Cluster Distribution**:<br>${distributionHtml}`;
                        } else {
                            aiResponseText = `Error performing K-Means clustering: ${clusteringResult.message}`;
                        }
                    }
                } else {
                    aiResponseText = `I didn't understand the K-Means clustering command format. Example: 'perform k-means clustering on Age, Income, Spending_Score into 3 clusters as Customer_Segment'.`;
                }
            }

            // --- New Command: Data Pivoting ---
            else if (lowerQuery.startsWith('create pivot table with ') && lowerQuery.includes(' as rows, ') && lowerQuery.includes(' as columns, ') && lowerQuery.includes(' as values aggregated by ')) {
                const regex = /create pivot table with\s+(.+?)\s+as rows,\s+(.+?)\s+as columns,\s+(.+?)\s+as values aggregated by\s+(.+)/i; // Changed to non-greedy
                const match = query.match(regex);
                if (match && match.length === 5) {
                    const indexCol = match[1].trim();
                    const pivotCol = match[2].trim();
                    const valueCol = match[3].trim();
                    const aggType = match[4].trim();

                    const pivotResult = createPivotTable(indexCol, pivotCol, valueCol, aggType, rawData);
                    if (pivotResult.error) {
                        aiResponseText = `Error creating pivot table: ${pivotResult.error}`;
                    } else {
                        aiResponseText = `Here's your **pivot table** for ${valueCol} aggregated by ${aggType}:`;
                        analysisContent = `<div class="mt-4 overflow-x-auto">${pivotResult.tableHtml}</div>
                                            <p class="mt-4 text-sm text-gray-400">This pivot table provides a summarized view of your data, transformed entirely client-side.</p>`;
                    }
                } else {
                    aiResponseText = `I didn't understand the pivot table command format. Example: 'create pivot table with Region as rows, Product_Category as columns, Sales as values aggregated by sum'.`;
                }
            }
            // --- New Command: Data Unpivoting (Melt) ---
            else if (lowerQuery.startsWith('unpivot data keeping ') && lowerQuery.includes(' and melting ') && lowerQuery.includes(' into new variable ') && lowerQuery.includes(' and value ')) {
                const regex = /unpivot data keeping\s+([^,]+(?:,\s*[^,]+)*?)\s+and melting\s+([^,]+(?:,\s*[^,]+)*?)\s+into new variable\s+(.+?)\s+and value\s+(.+)/i; // Changed to non-greedy
                const match = query.match(regex);
                if (match && match.length === 5) {
                    const idColsString = match[1].trim();
                    const colsToUnpivotString = match[2].trim();
                    const newVarCol = match[3].trim();
                    const newValCol = match[4].trim();

                    const idCols = idColsString.split(',').map(col => col.trim());
                    const colsToUnpivot = colsToUnpivotString.split(',').map(col => col.trim());

                    const unpivotResult = unpivotData(idCols, colsToUnpivot, newVarCol, newValCol, rawData, schema);
                    if (unpivotResult.success) {
                        aiResponseText = unpivotResult.message;
                        analysisContent = `<p class="text-gray-300 mt-2">Your data has been unpivoted successfully. Here's a preview of the **first 10 rows** of the transformed dataset:</p>
                                            <div class="code-block mt-2">${rawData.slice(0, 10).map(row => JSON.stringify(row, null, 2)).join('\n')}</div>
                                            <p class="text-sm text-gray-400 mt-2">The schema has also been updated to reflect these changes.</p>`;
                    } else {
                        aiResponseText = `Error unpivoting data: ${unpivotResult.message}`;
                    }
                } else {
                    aiResponseText = `I didn't understand the unpivot data command format. Example: 'unpivot data keeping ID and melting Q1_Sales, Q2_Sales, Q3_Sales into new variable Quarter and value Sales_Amount'.`;
                }
            }


            // Automated Insights
            else if (lowerQuery.includes('show proactive insights') || lowerQuery.includes('what insights do you have?')) {
                if (rawData.length === 0) {
                    appendMessage('AI', 'Please upload a CSV file before I can generate proactive insights. I need data to analyze!', 'ai');
                    return;
                }
                generateProactiveInsights(); // Ensure insights are fresh
                renderProactiveInsights(); // Render the insights into the overlay
                proactiveInsightsOverlay.classList.remove('hidden'); // Show the overlay
                return; // Don't append an AI message to chat, the overlay handles it
            }

            // Charting & Visualization
            else if (lowerQuery.startsWith('show bar chart of ') && lowerQuery.includes(' by ')) {
                const parts = query.match(/show bar chart of\s+(.+)\s+by\s+(.+)(?:\s+as\s+(sum|average))?/i);
                if (parts && parts.length >= 3) {
                    const numericColName = parts[1].trim();
                    const categoricalColName = parts[2].trim();
                    const aggregateType = parts[4] ? parts[4].toLowerCase() : 'sum'; // Default to sum

                    const numericCol = findNumericColumn(numericColName);
                    const categoricalCol = findCategoricalColumn(categoricalColName);

                    if (numericCol && categoricalCol) {
                        const { labels, data: aggregatedData } = groupByAndAggregate(rawData, categoricalCol, numericCol, aggregateType);
                        if (labels.length > 0) {
                            createChart('bar', `${numericCol} by ${categoricalCol} (${aggregateType})`, labels, aggregatedData, categoricalCol, `${numericCol} (${aggregateType})`);
                            // No aiResponseText here, createChart handles the message
                        } else {
                            aiResponseText = `No valid data to create a bar chart for "<strong>${numericCol}</strong>" by "<strong>${categoricalCol}</strong>". Ensure columns have data.`;
                        }
                    } else {
                        aiResponseText = `To show a bar chart, I need a valid numeric column and a valid categorical column. Please check your column names.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the bar chart command format. Example: 'show bar chart of sales by region as average'.`;
                }
            } else if (lowerQuery.startsWith('show line chart with x as ') && lowerQuery.includes(' and y as ')) {
                const parts = query.match(/show line chart with x as\s+(.+)\s+and y as\s+(.+)/i);
                if (parts && parts.length === 3) {
                    const xColName = parts[1].trim();
                    const yColName = parts[2].trim();
                    const xCol = findColumnByName(xColName); // X can be string (e.g., date) or number
                    const yCol = findNumericColumn(yColName);

                    if (xCol && yCol) {
                        // For line chart, prepare data as array of {x,y} for potentially mixed X-axis types
                        // Chart.js `linear` type for X-axis works best with numbers, `category` for strings.
                        // `time` adapter would be needed for proper date plotting, but keeping it simpler for now.
                        const lineData = rawData.map(row => {
                            const xVal = row[xCol]; // Keep original for labels
                            const yVal = Number(row[yCol]);
                            return (!isNaN(yVal)) ? { x: xVal, y: yVal } : null;
                        }).filter(Boolean); // Filter out nulls/invalid y values

                        if (lineData.length > 0) {
                            // Sort by X value if X is numeric, or alphabetically if string (for better line flow)
                            if (schema[xCol] === 'number') {
                                lineData.sort((a, b) => a.x - b.x);
                            } else { // Assume string, sort alphabetically
                                lineData.sort((a, b) => String(a.x).localeCompare(String(b.x)));
                            }
                            
                            // Extract labels and data (y values) for Chart.js
                            const labels = lineData.map(d => d.x);
                            const data = lineData.map(d => d.y);

                            createChart('line', `${yCol} over ${xCol}`, labels, data, xCol, yCol);
                            // No aiResponseText here, createChart handles the message
                        } else {
                            aiResponseText = `No valid numeric data in "<strong>${yCol}</strong>" to create a line chart.`;
                        }
                    } else {
                        aiResponseText = `To show a line chart, I need valid X and Y columns. Y must be numeric. Please check your column names.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the line chart command format. Example: 'show line chart with X as Date and Y as Stock Price'.`;
                }
            } else if (lowerQuery.startsWith('show scatter plot with x as ') && lowerQuery.includes(' and y as ')) {
                const parts = query.match(/show scatter plot with x as\s+(.+)\s+and y as\s+(.+)/i);
                if (parts && parts.length === 3) {
                    const xColName = parts[1].trim();
                    const yColName = parts[2].trim();
                    const xCol = findNumericColumn(xColName);
                    const yCol = findNumericColumn(yColName);

                    if (xCol && yCol) {
                        // For scatter, Chart.js expects data in {x, y} pairs
                        const scatterData = rawData.map(row => {
                            const xVal = Number(row[xCol]);
                            const yVal = Number(row[yCol]);
                            return (!isNaN(xVal) && !isNaN(yVal)) ? { x: xVal, y: yVal } : null;
                        }).filter(Boolean); // Filter out nulls

                        if (scatterData.length > 0) {
                            // Scatter plot labels are not typically used for the X axis, but rather for tooltips.
                            // The actual X axis values come from the 'x' property of the data points.
                            const chartOptions = {
                                scales: {
                                    x: {
                                        type: 'linear', // Ensure x-axis is linear for scatter plot
                                        position: 'bottom',
                                        title: {
                                            display: true,
                                            text: xCol,
                                            color: '#e2e8f0'
                                        }
                                    },
                                    y: {
                                        type: 'linear', // Ensure y-axis is linear
                                        title: {
                                            display: true,
                                            text: yCol,
                                            color: '#e2e8f0'
                                        }
                                    }
                                }
                            };
                            createChart('scatter', `Scatter Plot: ${yCol} vs ${xCol}`, [], scatterData, xCol, yCol, chartOptions); // Pass empty labels as data contains x,y
                            // No aiResponseText here, createChart handles the message
                        } else {
                            aiResponseText = `No valid numeric data in both "<strong>${xCol}</strong>" and "<strong>${yCol}</strong>" to create a scatter plot.`;
                        }
                    } else {
                        aiResponseText = `To show a scatter plot, I need two valid numeric columns. Please check your column names.`;
                    }
                } else {
                    aiResponseText = `I didn't understand the scatter plot command format. Example: 'show scatter plot with X as Age and Y as Income'.`;
                }
            } else if (lowerQuery.startsWith('show pie chart of ') || lowerQuery.startsWith('show doughnut chart of ') || lowerQuery.startsWith('show polar area chart of ')) {
                let chartType = '';
                let queryRemainder = '';
                if (lowerQuery.startsWith('show pie chart of ')) {
                    chartType = 'pie';
                    queryRemainder = query.substring('show pie chart of '.length).trim();
                } else if (lowerQuery.startsWith('show doughnut chart of ')) {
                    chartType = 'doughnut';
                    queryRemainder = query.substring('show doughnut chart of '.length).trim();
                } else if (lowerQuery.startsWith('show polar area chart of ')) {
                    chartType = 'polarArea';
                    queryRemainder = query.substring('show polar area chart of '.length).trim();
                }

                // Attempt to parse for aggregated charts first (e.g., Sales by Region as sum)
                const aggregatedParts = queryRemainder.match(/(.+)\s+by\s+(.+)(?:\s+as\s+(sum|average))?/i);
                if (aggregatedParts && aggregatedParts.length >= 3) {
                    const numericColName = aggregatedParts[1].trim();
                    const categoricalColName = aggregatedParts[2].trim();
                    const aggregateType = aggregatedParts[4] ? parts[4].toLowerCase() : 'sum'; // Default to sum

                    const numericCol = findNumericColumn(numericColName);
                    const categoricalCol = findCategoricalColumn(categoricalColName);

                    if (numericCol && categoricalCol) {
                        const { labels, data: aggregatedData } = groupByAndAggregate(rawData, categoricalCol, numericCol, aggregateType);
                        if (labels.length > 0) {
                            createChart(chartType, `${numericCol} by ${categoricalCol} (${aggregateType})`, labels, aggregatedData);
                            // No aiResponseText here, createChart handles the message
                        } else {
                            aiResponseText = `No valid data to create a ${chartType} chart for "<strong>${numericCol}</strong>" by "<strong>${categoricalCol}</strong>". Ensure columns have data.`;
                        }
                    } else {
                        aiResponseText = `To show a ${chartType} chart with aggregation, I need a valid numeric column and a valid categorical column. Please check your column names.`;
                    }
                } else {
                    // If not aggregated, try to parse for simple categorical distribution (e.g., Gender)
                    const categoricalColName = queryRemainder; // The whole remainder should be the column name
                    const categoricalCol = findCategoricalColumn(categoricalColName);

                    if (categoricalCol) {
                        const { labels, data: counts } = getFrequencyDistribution(categoricalCol, rawData);
                        if (labels.length > 0) {
                            createChart(chartType, `Distribution of ${categoricalCol}`, labels, counts);
                            // No aiResponseText here, createChart handles the message
                        } else {
                            aiResponseText = `No valid data to create a ${chartType} chart for "<strong>${categoricalCol}</strong>". Ensure the column has data.`;
                        }
                    } else {
                        aiResponseText = `I couldn't find a valid categorical column named "<strong>${categoricalColName}</strong>" or I didn't understand the command format for this chart. Example: 'show ${chartType} chart of Gender' or 'show ${chartType} chart of Sales by Region as sum'.`;
                    }
                }
            }
            // Command Guide
            else if (lowerQuery.includes('show command guide')) {
                commandGuideOverlay.classList.remove('hidden');
                commandGuideContent.innerHTML = getCommandListHtml();
                toggleCommandGuideText.textContent = 'Hide Command Guide';
                toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book-open mr-2';
                return; // Don't append another AI message, the overlay handles it
            }
            // New: Automated Report Generation & Data Storytelling
            else if (lowerQuery.includes('generate data story') || lowerQuery.includes('create report')) {
                if (rawData.length === 0) {
                    appendMessage('AI', 'Please upload a CSV file before I can generate a data story. I need data to tell a story about!', 'ai');
                    return;
                }
                const reportResult = generateDataStory(); // This function is not provided in current context, assuming it exists externally
                if (reportResult && reportResult.success) {
                    aiResponseText = `Here's a concise **Data Story** based on your loaded dataset. This provides a high-level narrative of key findings.<br>`;
                    analysisContent = `<div class="bg-gray-700 p-6 rounded-lg mt-4 shadow-xl overflow-y-auto custom-scrollbar max-h-[400px] text-gray-200">${reportResult.reportHtml}</div>
                                        <button id="downloadDataStoryBtn" class="send-button-gradient text-white p-3 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center space-x-2 mt-4 text-base font-bold mx-auto">
                                            <i class="fas fa-file-download"></i>
                                            <span>Download Data Story (.txt)</span>
                                        </button>`;
                    // Add event listener for the download button after it's rendered
                    setTimeout(() => {
                        const downloadBtn = document.getElementById('downloadDataStoryBtn');
                        if (downloadBtn) {
                            downloadBtn.addEventListener('click', () => {
                                // Make sure downloadDataStory function is defined
                                if (typeof downloadDataStory === 'function') {
                                    downloadDataStory(reportResult.reportHtml.replace(/<[^>]*>/g, '')); // Remove HTML tags for plain text download
                                } else {
                                    console.error("downloadDataStory function is not defined.");
                                }
                            });
                        }
                    }, 0); // Use setTimeout to ensure the button is in DOM
                } else {
                    aiResponseText = `Error generating data story: ${reportResult ? reportResult.message : 'Unknown error.'}`;
                }
            }


            // Unrecognized command
            else {
                aiResponseText = `I'm sorry, I didn't understand that command. Please refer to the command list by typing 'show command guide' for examples, or try rephrasing your request.`;
            }
            
            // Only append an AI message if aiResponseText has content. Chart commands will now be silent here.
            if (aiResponseText || analysisContent) { // Ensure something is being appended
                appendMessage('AI', aiResponseText + (analysisContent ? `<div class="mt-4">${analysisContent}</div>` : ''), 'ai');
            }

            // Attach listeners after the message has been appended to the DOM
            if (lowerQuery.includes('show all data') || lowerQuery.includes('display everything') || lowerQuery.includes('what\'s in the dataset')) {
                attachTableSortingListeners();
            }
        }

        // Handle sending messages
        sendMessageBtn.addEventListener('click', () => {
            const query = chatInput.value.trim();
            if (query) {
                appendMessage('You', query, 'user');
                chatInput.value = ''; // Clear input

                if (!isHeaderShrunk) {
                    headerContainer.classList.add('header-shrunk');
                    isHeaderShrunk = true;
                }

                simulateAIResponse(query);
            }
        });

        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessageBtn.click();
            }
        });

        // Event listener for the "Show Proactive Insights" button in the Data Panel
        showProactiveInsightsBtn.addEventListener('click', () => {
            if (rawData.length === 0) {
                appendMessage('AI', 'Please upload a CSV file before I can generate proactive insights. I need data to analyze!', 'ai');
                return;
            }
            generateProactiveInsights(); // Ensure insights are fresh
            renderProactiveInsights(); // Render the insights into the overlay
            proactiveInsightsOverlay.classList.remove('hidden'); // Show the overlay
        });

        // Event listener for the "Close Insights" button
        closeProactiveInsightsBtn.addEventListener('click', () => {
            proactiveInsightsOverlay.classList.add('hidden'); // Hide the overlay
        });

        // Event listeners for filter buttons
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'active' class from all filter buttons
                filterButtons.forEach(btn => {
                    btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                });

                // Add 'active' class to the clicked button
                button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');

                const filterType = button.dataset.filter;
                const searchTerm = insightSearchInput.value.trim();
                renderProactiveInsights(filterType, searchTerm);
            });
        });

        // Event listener for search input
        insightSearchInput.addEventListener('input', () => {
            const activeFilterButton = document.querySelector('.filter-btn.bg-blue-600');
            const filterType = activeFilterButton ? activeFilterButton.dataset.filter : 'all'; // Get currently active filter
            const searchTerm = insightSearchInput.value.trim();
            renderProactiveInsights(filterType, searchTerm);
        });

        // Initial setup for command guide toggle button: it will initially show "Show Command Guide"
        toggleCommandGuideText.textContent = 'Show Command Guide';
        toggleCommandGuideBtn.querySelector('i').className = 'fas fa-book mr-2';

        // Initial schema display
        displaySchema(schema);

        // Placeholder for generateDataStory and downloadDataStory, if not provided elsewhere.
        // In a real application, these would be defined or imported.
        function generateDataStory() {
            // This is a placeholder. You would implement logic to generate a narrative report here.
            // For example, summarize key insights from `lastProactiveInsights`,
            // or generate descriptions based on descriptive statistics, top values, etc.
            if (rawData.length === 0) {
                return { success: false, message: "No data loaded to generate a story." };
            }

            let storyHtml = `<h3 class="text-2xl font-bold text-blue-400 mb-4">Your Data Story: Initial Overview</h3>
                            <p class="mb-4">This report provides a high-level summary of your dataset and key insights.</p>`;

            const numRows = rawData.length;
            const numCols = Object.keys(schema).length;
            storyHtml += `<h4 class="text-xl font-semibold text-gray-300 mb-2">Dataset Summary:</h4>
                          <p class="mb-4">Your dataset contains <strong>${numRows} rows</strong> and <strong>${numCols} columns</strong>.</p>`;

            const numericColumns = Object.keys(schema).filter(col => schema[col] === 'number');
            if (numericColumns.length > 0) {
                storyHtml += `<h4 class="text-xl font-semibold text-gray-300 mb-2">Key Numeric Trends:</h4><ul>`;
                numericColumns.slice(0, 3).forEach(col => {
                    const stats = getDescriptiveStats(col, rawData);
                    if (stats) {
                        storyHtml += `<li><strong>${col}</strong>: Average of ${stats.mean.toFixed(2)}, ranging from ${stats.min.toFixed(2)} to ${stats.max.toFixed(2)}.</li>`;
                    }
                });
                storyHtml += `</ul>`;
            }

            if (lastProactiveInsights.length > 0) {
                storyHtml += `<h4 class="text-xl font-semibold text-gray-300 mt-4 mb-2">Highlighted Insights:</h4>`;
                lastProactiveInsights.slice(0, 5).forEach(insight => { // Include top 5 insights
                    storyHtml += `<div class="insight-card p-4 my-2 border border-gray-600 rounded-lg">
                                    <h5 class="font-bold text-blue-300 mb-1 flex items-center"><i class="${insight.icon} mr-2"></i>${insight.title}</h5>
                                    <p class="text-sm text-gray-300">${insight.message.split('<br>')[0].replace('<strong>', '').replace('</strong>', '')}</p>
                                  </div>`;
                });
                storyHtml += `<p class="mt-4">For a full list and details, click "Show Proactive Insights".</p>`;
            } else {
                storyHtml += `<p class="mt-4 text-gray-400">No specific proactive insights generated yet. Upload data and look for the "Show Proactive Insights" button!</p>`;
            }

            storyHtml += `<p class="mt-6 text-gray-400 italic">This story is automatically generated and provides a starting point for your analysis.</p>`;

            return { success: true, reportHtml: storyHtml };
        }

        function downloadDataStory(text) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'CoDA_Data_Story.txt');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            appendMessage('AI', 'Your data story has been downloaded as **CoDA_Data_Story.txt**!', 'ai');
        }
    </script>
</body>
</html>
